{"version":3,"file":"hot-module-state.js","sourceRoot":"","sources":["../src/hot-module-state.ts"],"names":[],"mappings":"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","sourcesContent":["// Farm's HMR client is compatible with Vite, see https://vitejs.dev/guide/api-hmr.html.\n// And it's inspired by both Vite and esm-hmr, see https://github.com/FredKSchott/esm-hmr\nimport { HmrClient } from './hmr-client.js';\nimport { logger } from './logger.js';\n\nexport class HotModuleState {\n  acceptCallbacks: Array<{ deps: string[]; fn: (mods: any[]) => void }> = [];\n  data = {};\n  id: string;\n  hmrClient: HmrClient;\n\n  constructor(id: string, hmrClient: HmrClient) {\n    this.id = id;\n    this.hmrClient = hmrClient;\n  }\n\n  // the same as vite's hot.accept\n  accept(deps?: any, callback?: (mods: any[]) => void) {\n    if (typeof deps === 'function' || !deps) {\n      // self-accept hot.accept(() => {})\n      this.acceptCallbacks.push({\n        deps: [this.id],\n        fn: ([mod]) => deps?.(mod)\n      });\n    } else if (typeof deps === 'string') {\n      // accept a single dependency hot.accept('./dep.js', () => {})\n      this.acceptCallbacks.push({\n        deps: [deps],\n        fn: ([mod]) => callback?.(mod)\n      });\n    } else if (Array.isArray(deps)) {\n      // accept multiple dependencies hot.accept(['./dep1.js', './dep2.js'], () => {})\n      this.acceptCallbacks.push({ deps, fn: callback });\n    } else {\n      throw new Error('invalid hot.accept call');\n    }\n  }\n\n  dispose(callback: (data: any) => void) {\n    this.hmrClient.disposeMap.set(this.id, callback);\n  }\n\n  prune(callback: (data: any[]) => void) {\n    this.hmrClient.pruneMap.set(this.id, callback);\n  }\n\n  acceptExports(\n    _: string | readonly string[],\n    _callback: (data: any) => void\n  ): void {\n    logger.debug('acceptExports is not supported for now');\n  }\n\n  decline() {\n    /** does no thing */\n  }\n\n  invalidate(message?: string) {\n    this.hmrClient.notifyListeners('vite:invalidate', {\n      path: this.id,\n      message\n    });\n    // notify the server to find the boundary starting from the parents of this module\n    this.send('vite:invalidate', { path: this.id, message });\n    this.send('farm:invalidate', { path: this.id, message });\n    logger.debug(`invalidate ${this.id}${message ? `: ${message}` : ''}`);\n  }\n\n  on<T extends string>(event: T, cb: (payload: any) => void): void {\n    const addToMap = (map: Map<string, any[]>) => {\n      const existing = map.get(event) || [];\n      existing.push(cb);\n      map.set(event, existing);\n    };\n    addToMap(this.hmrClient.customListenersMap);\n  }\n\n  off<T extends string>(event: T, cb: (payload: any) => void): void {\n    const removeFromMap = (map: Map<string, any[]>) => {\n      const existing = map.get(event);\n      if (existing === undefined) {\n        return;\n      }\n      const pruned = existing.filter((l) => l !== cb);\n      if (pruned.length === 0) {\n        map.delete(event);\n        return;\n      }\n      map.set(event, pruned);\n    };\n    removeFromMap(this.hmrClient.customListenersMap);\n  }\n\n  send<T extends string>(event: T, data?: any): void {\n    if (this.hmrClient.socket.readyState === WebSocket.OPEN) {\n      this.hmrClient.socket.send(\n        JSON.stringify({ type: 'custom', event, data })\n      );\n    }\n  }\n}\n\nexport function createHotContext(id: string, hmrClient: HmrClient) {\n  if (hmrClient.registeredHotModulesMap.has(id)) {\n    const hotModuleState = hmrClient.registeredHotModulesMap.get(id);\n    hotModuleState.acceptCallbacks = []; // clear the accept callbacks when hot reloading\n    return hotModuleState;\n  }\n\n  const state = new HotModuleState(id, hmrClient);\n  hmrClient.registeredHotModulesMap.set(id, state);\n  return state;\n}\n"]}