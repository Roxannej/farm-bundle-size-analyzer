{"version":3,"file":"type.js","sourceRoot":"","sources":["../../src/plugin/type.ts"],"names":[],"mappings":"AAiQA,OAAO,EAAE,kBAAkB,EAAE,MAAM,8BAA8B,CAAC","sourcesContent":["import { Compiler, ResolvedUserConfig, Server, UserConfig } from '../index.js';\nimport {\n  Config,\n  ModuleType,\n  PluginLoadHookParam,\n  PluginLoadHookResult,\n  PluginResolveHookParam,\n  PluginResolveHookResult,\n  PluginTransformHookParam,\n  PluginTransformHookResult\n} from '../types/binding.js';\n\n// https://stackoverflow.com/questions/61047551/typescript-union-of-string-and-string-literals\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport type LiteralUnion<T extends string> = T | (string & {});\n\ntype ResourcePotType = LiteralUnion<\n  'runtime' | 'js' | 'css' | 'html' | 'asset'\n>;\n\nexport interface CompilationContextEmitFileParams {\n  resolvedPath: string;\n  name: string;\n  content: number[];\n  resourceType: 'runtime' | 'js' | 'css' | 'html' | string;\n}\n\nexport interface ViteModule {\n  url: string;\n  id: string;\n  file: string;\n  type: 'js' | 'css';\n}\n\nexport interface CompilationContext {\n  resolve(\n    param: PluginResolveHookParam,\n    hookContext: { meta: Record<string, unknown>; caller: string }\n  ): Promise<PluginResolveHookResult>;\n\n  addWatchFile(currentFile: string, targetFile: string): void;\n  emitFile(params: CompilationContextEmitFileParams): void;\n  getWatchFiles(): string[];\n  warn(message: string): void;\n  error(message: string): void;\n  sourceMapEnabled(id: string): boolean;\n\n  viteGetModulesByFile(file: string): ViteModule[];\n  viteGetModuleById(id: string): ViteModule;\n  viteGetImporters(file: string): ViteModule[];\n}\n\ntype ModuleId = string;\nexport interface ResourcePot {\n  id: string;\n  name: string;\n  resourcePotType: ResourcePotType;\n  modules: ModuleId[];\n  meta: {\n    renderedModules: Record<ModuleId, RenderedModule>;\n    renderedContent: string;\n    renderedMapChain: string[];\n    customData: Record<string, string>;\n  };\n  entryModule?: ModuleId;\n  resources: string[];\n  moduleGroups: string[];\n  immutable: boolean;\n  info: ResourcePotInfo;\n}\n\nexport interface RenderedModule {\n  id: ModuleId;\n  renderedContent: string;\n  renderedMap?: string;\n  renderedLength: number;\n  originalLength: number;\n}\n\nexport interface ResourcePotInfo {\n  id: string;\n  name: string;\n  resourcePotType: ResourcePotType;\n  map?: string;\n  modules: Record<ModuleId, RenderedModule>;\n  moduleIds: ModuleId[];\n  data: JsResourcePotInfoData;\n  custom: Record<string, string>;\n}\n\nexport interface JsResourcePotInfoData {\n  dynamicImports: string[];\n  exports: string[];\n  imports: string[];\n  importedBindings: Record<string, string[]>;\n  isDynamicEntry: boolean;\n  isEntry: boolean;\n  isImplicitEntry: boolean;\n}\n\nexport interface PluginRenderResourcePotParams {\n  content: string;\n  sourceMapChain: string[];\n  resourcePotInfo: ResourcePotInfo;\n}\nexport interface PluginRenderResourcePotResult {\n  content: string;\n  sourceMap?: string;\n}\n\nexport interface Resource {\n  name: string;\n  bytes: number[];\n  emitted: boolean;\n  resourceType: string;\n  origin: { type: 'ResourcePot' | 'Module'; value: string };\n  info?: ResourcePotInfo;\n}\n\nexport type PluginFinalizeResourcesHookParams = {\n  resourcesMap: Record<string, Resource>;\n  config: Config['config'];\n};\n\ntype Callback<P, R> = (\n  param: P,\n  context?: CompilationContext,\n  hookContext?: { caller?: string; meta: Record<string, unknown> }\n) => Promise<R | null | undefined> | R | null | undefined;\ntype JsPluginHook<F, P, R> = { filters: F; executor: Callback<P, R> };\n\nexport interface PluginProcessModuleParams {\n  moduleId: string;\n  moduleType: ModuleType;\n  content: string;\n}\n\nexport interface PluginProcessModuleResult {\n  content: string;\n}\n\ntype NormalizeFilterParams = {\n  moduleTypes?: ModuleType[];\n  resolvedPaths?: string[];\n};\n\nexport interface JsPlugin {\n  name: string;\n  priority?: number;\n\n  config?: (config: UserConfig) => UserConfig | Promise<UserConfig>;\n\n  configResolved?: (config: ResolvedUserConfig) => void | Promise<void>;\n\n  /**\n   * runs in development mode only\n   * @param server\n   * @returns\n   */\n  configureDevServer?: (server: Server) => void | Promise<void>;\n  /**\n   * @param compiler\n   * @returns\n   */\n  configureCompiler?: (compiler: Compiler) => void | Promise<void>;\n\n  buildStart?: { executor: Callback<Record<string, never>, void> };\n\n  resolve?: JsPluginHook<\n    {\n      importers: string[];\n      sources: string[];\n    },\n    PluginResolveHookParam,\n    PluginResolveHookResult\n  >;\n\n  load?: JsPluginHook<\n    { resolvedPaths: string[] },\n    PluginLoadHookParam,\n    PluginLoadHookResult\n  >;\n\n  transform?: JsPluginHook<\n    { resolvedPaths?: string[]; moduleTypes?: string[] },\n    PluginTransformHookParam,\n    PluginTransformHookResult\n  >;\n\n  processModule?: JsPluginHook<\n    NormalizeFilterParams,\n    PluginProcessModuleParams,\n    PluginProcessModuleResult\n  >;\n\n  buildEnd?: { executor: Callback<Record<string, never>, void> };\n\n  renderStart?: {\n    executor: Callback<Config['config'], void>;\n  };\n\n  renderResourcePot?: JsPluginHook<\n    {\n      resourcePotTypes?: ResourcePotType[];\n      moduleIds?: string[];\n    },\n    PluginRenderResourcePotParams,\n    PluginRenderResourcePotResult\n  >;\n\n  augmentResourceHash?: JsPluginHook<\n    {\n      resourcePotTypes?: ResourcePotType[];\n      moduleIds?: string[];\n    },\n    ResourcePotInfo,\n    string\n  >;\n\n  finalizeResources?: {\n    executor: Callback<\n      PluginFinalizeResourcesHookParams,\n      PluginFinalizeResourcesHookParams['resourcesMap']\n    >;\n  };\n\n  transformHtml?: {\n    /** 0: pre, 1: normal, 2: post */\n    order?: 0 | 1 | 2;\n    executor: Callback<{ htmlResource: Resource }, Resource>;\n  };\n\n  writeResources?: {\n    executor: (\n      param: PluginFinalizeResourcesHookParams\n    ) => void | Promise<void>;\n  };\n\n  pluginCacheLoaded?: {\n    executor: Callback<number[], undefined | null | void>;\n  };\n\n  writePluginCache?: {\n    executor: Callback<undefined, number[]>;\n  };\n\n  finish?: { executor: Callback<Record<string, never>, void> };\n  updateFinished?: { executor: Callback<Record<string, never>, void> };\n\n  updateModules?: {\n    executor: Callback<\n      { paths: [string, string][] },\n      string[] | undefined | null | void\n    >;\n  };\n}\n\nexport { rustPluginResolver } from './rust/rustPluginResolver.js';\nexport type {\n  PluginResolveHookParam,\n  PluginResolveHookResult,\n  PluginLoadHookParam,\n  PluginLoadHookResult,\n  PluginTransformHookParam,\n  PluginTransformHookResult\n} from '../types/binding.js';\n"]}