import module from 'node:module';
import { existsSync, readFileSync } from 'node:fs';
import path from 'node:path';
import { safeJsonParse } from '../../utils/json.js';
import { isObject } from '../../utils/share.js';
import { CUSTOM_KEYS } from '../constants.js';
export function partialExternal(externalConfig = []) {
    const stringExternal = [];
    const recordExternal = {};
    /**
     *
     * `["^node:.*$", { "jquery": "$" }]`
     * =>
     * `["^node:.*$"]`
     * `{ "jquery": "$" }`
     */
    for (const external of externalConfig) {
        if (typeof external === 'string') {
            stringExternal.push(external);
        }
        else if (isObject(external)) {
            Object.assign(recordExternal, external);
        }
    }
    return [stringExternal, recordExternal];
}
export function normalizeExternal(config, resolvedCompilation) {
    const defaultExternals = [];
    const externalNodeBuiltins = config.compilation?.externalNodeBuiltins ?? true;
    if (externalNodeBuiltins) {
        if (Array.isArray(externalNodeBuiltins)) {
            defaultExternals.push(...externalNodeBuiltins);
        }
        else if (externalNodeBuiltins === true) {
            let packageJson = {};
            const pkgPath = path.join(resolvedCompilation.root || process.cwd(), 'package.json');
            // the project installed polyfill
            if (existsSync(pkgPath)) {
                try {
                    packageJson = JSON.parse(readFileSync(pkgPath, 'utf8'));
                }
                catch {
                    /**/
                }
            }
            defaultExternals.push(...[...module.builtinModules].filter((m) => !resolvedCompilation.resolve?.alias?.[m] &&
                !packageJson?.devDependencies?.[m] &&
                !packageJson?.dependencies?.[m]));
        }
    }
    if (!config?.compilation?.custom) {
        config.compilation.custom = {};
    }
    if (!resolvedCompilation?.custom) {
        resolvedCompilation.custom = {};
    }
    const [stringExternal, recordExternal] = mergeCustomExternal(config.compilation, mergeCustomExternal(resolvedCompilation, partialExternal(config.compilation.external)));
    resolvedCompilation.custom[CUSTOM_KEYS.external_record] =
        JSON.stringify(recordExternal);
    resolvedCompilation.external = [
        ...stringExternal,
        '^node:',
        ...defaultExternals.map((m) => `^${m}($|/promises$)`)
    ];
}
export function mergeCustomExternal(compilation, external) {
    const [stringExternal, recordExternal] = external;
    if (!compilation?.custom) {
        compilation.custom = {};
    }
    const oldRecordExternal = compilation.custom[CUSTOM_KEYS.external_record]
        ? safeJsonParse(compilation.custom[CUSTOM_KEYS.external_record], {}) || {}
        : {};
    return [
        [...new Set(stringExternal)],
        isObject(oldRecordExternal)
            ? { ...oldRecordExternal, ...recordExternal }
            : recordExternal
    ];
}
//# sourceMappingURL=normalize-external.js.map