global.nodeRequire = require;global['973501ed6cc362643bd39f42d007cdf1'] = {__FARM_TARGET_ENV__: 'node'};function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}function _export_star(from, to) {
    Object.keys(from).forEach(function(k) {
        if (k !== "default" && !Object.prototype.hasOwnProperty.call(to, k)) {
            Object.defineProperty(to, k, {
                enumerable: true,
                get: function() {
                    return from[k];
                }
            });
        }
    });
    return from;
}function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) return obj;
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") return {
        default: obj
    };
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) Object.defineProperty(newObj, key, desc);
            else newObj[key] = obj[key];
        }
    }
    newObj.default = obj;
    if (cache) cache.set(obj, newObj);
    return newObj;
}function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}const __global_this__ = typeof globalThis !== 'undefined' ? globalThis : window;
var index_js_default = {
    name: 'farm-runtime-import-meta',
    _moduleSystem: {},
    bootstrap (system) {
        this._moduleSystem = system;
    },
    moduleCreated (module) {
        const publicPath = this._moduleSystem.publicPaths?.[0] || "";
        const isSSR = this._moduleSystem.targetEnv === "node";
        const { location } = __global_this__;
        let baseUrl;
        try {
            baseUrl = (location ? new URL(publicPath, `${location.protocol}//${location.host}`) : new URL(module.resource_pot)).pathname;
        } catch (_) {
            baseUrl = '/';
        }
        module.meta.env = {
            ...{
                "FARM_PUBLISH": "true",
                "NODE_ENV": "production",
                "mode": "production"
            } ?? {},
            dev: process.env.NODE_ENV === 'development',
            prod: process.env.NODE_ENV === 'production',
            BASE_URL: baseUrl,
            SSR: isSSR
        };
        const url = location ? `${location.protocol}//${location.host}${publicPath.replace(/\/$/, '')}/${module.id}?t=${Date.now()}` : module.resource_pot;
        module.meta.url = url;
    }
};

class Module {
    constructor(id, require){
        this.resource_pot = "";
        this.id = id;
        this.exports = {};
        this.meta = {
            env: {}
        };
        this.require = require;
    }
    o(to, to_k, get) {
        Object.defineProperty(to, to_k, {
            enumerable: true,
            get
        });
    }
    d(to, to_k, val) {
        this.o(to, to_k, function() {
            return val;
        });
    }
    _m(to) {
        const key = '__esModule';
        if (to[key]) return;
        Object.defineProperty(to, key, {
            value: true
        });
    }
    _e(to, from) {
        Object.keys(from).forEach(function(k) {
            if (k !== "default" && !Object.prototype.hasOwnProperty.call(to, k)) {
                Object.defineProperty(to, k, {
                    value: from[k],
                    enumerable: true,
                    configurable: true
                });
            }
        });
        return from;
    }
    i(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    _g(nodeInterop) {
        if (typeof WeakMap !== "function") return null;
        var cacheBabelInterop = new WeakMap();
        var cacheNodeInterop = new WeakMap();
        return (this._g = function(nodeInterop) {
            return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
    }
    w(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) return obj;
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") return {
            default: obj
        };
        var cache = this._g(nodeInterop);
        if (cache && cache.has(obj)) return cache.get(obj);
        var newObj = {
            __proto__: null
        };
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for(var key$1 in obj){
            if (key$1 !== "default" && Object.prototype.hasOwnProperty.call(obj, key$1)) {
                var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key$1) : null;
                if (desc && (desc.get || desc.set)) Object.defineProperty(newObj, key$1, desc);
                else newObj[key$1] = obj[key$1];
            }
        }
        newObj.default = obj;
        if (cache) cache.set(obj, newObj);
        return newObj;
    }
    _(to, to_k, from, from_k) {
        this.d(to, to_k, from[from_k || to_k]);
    }
    p(to, val) {
        for (const key$2 of Object.keys(val)){
            const newKey = to[key$2];
            if (newKey && !Object.prototype.hasOwnProperty.call(val, newKey)) {
                this.d(val, newKey, val[key$2]);
            }
        }
    }
    f(v) {
        if (typeof v.default !== 'undefined') {
            return v.default;
        }
        return v;
    }
}

class FarmRuntimePluginContainer {
    constructor(plugins){
        this.plugins = [];
        this.plugins = plugins;
    }
    hookSerial(hookName, ...args) {
        for (const plugin of this.plugins){
            const hook = plugin[hookName];
            if (hook) {
                hook.apply(plugin, args);
            }
        }
    }
    hookBail(hookName, ...args) {
        for (const plugin$1 of this.plugins){
            const hook$1 = plugin$1[hookName];
            if (hook$1) {
                const result = hook$1.apply(plugin$1, args);
                if (result) {
                    return result;
                }
            }
        }
        return undefined;
    }
}

const __farm_global_this__ = global['973501ed6cc362643bd39f42d007cdf1'];
const __global_this__$1 = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : {};
const targetEnv = __farm_global_this__.__FARM_TARGET_ENV__ || 'node';
const isBrowser = targetEnv === 'browser' && __global_this__$1.document;
class ResourceLoader {
    constructor(moduleSystem, publicPaths){
        this.moduleSystem = moduleSystem;
        this._loadedResources = {};
        this._loadingResources = {};
        this.publicPaths = publicPaths;
    }
    load(resource, index = 0) {
        if (!isBrowser) {
            const result$1 = this.moduleSystem.pluginContainer.hookBail('loadResource', resource);
            if (result$1) {
                return result$1.then((res)=>{
                    if (!res.success && res.retryWithDefaultResourceLoader) {
                        if (resource.type === 0) {
                            return this._loadScript(`./${resource.path}`);
                        } else if (resource.type === 1) {
                            return this._loadLink(`./${resource.path}`);
                        }
                    } else if (!res.success) {
                        throw new Error(`[Farm] Failed to load resource: "${resource.path}, type: ${resource.type}". Original Error: ${res.err}`);
                    }
                });
            } else {
                if (resource.type === 0) {
                    return this._loadScript(`./${resource.path}`);
                } else if (resource.type === 1) {
                    return this._loadLink(`./${resource.path}`);
                }
            }
        }
        const publicPath = this.publicPaths[index];
        const url = `${publicPath.endsWith('/') ? publicPath.slice(0, -1) : publicPath}/${resource.path}`;
        if (this._loadedResources[resource.path]) {
            return Promise.resolve();
        } else if (this._loadingResources[resource.path]) {
            return this._loadingResources[resource.path];
        }
        const result$2 = this.moduleSystem.pluginContainer.hookBail('loadResource', resource);
        if (result$2) {
            return result$2.then((res)=>{
                if (res.success) {
                    this.setLoadedResource(resource.path);
                } else if (res.retryWithDefaultResourceLoader) {
                    return this._load(url, resource, index);
                } else {
                    throw new Error(`[Farm] Failed to load resource: "${resource.path}, type: ${resource.type}". Original Error: ${res.err}`);
                }
            });
        } else {
            return this._load(url, resource, index);
        }
    }
    setLoadedResource(path, loaded = true) {
        this._loadedResources[path] = loaded;
    }
    isResourceLoaded(path) {
        return this._loadedResources[path];
    }
    _load(url, resource, index) {
        let promise = Promise.resolve();
        if (resource.type === 0) {
            promise = this._loadScript(url);
        } else if (resource.type === 1) {
            promise = this._loadLink(url);
        }
        this._loadingResources[resource.path] = promise;
        promise.then(()=>{
            this._loadedResources[resource.path] = true;
            this._loadingResources[resource.path] = null;
        }).catch((e)=>{
            console.warn(`[Farm] Failed to load resource "${url}" using publicPath: ${this.publicPaths[index]}`);
            index++;
            if (index < this.publicPaths.length) {
                return this._load(url, resource, index);
            } else {
                this._loadingResources[resource.path] = null;
                throw new Error(`[Farm] Failed to load resource: "${resource.path}, type: ${resource.type}". ${e}`);
            }
        });
        return promise;
    }
    _loadScript(path) {
        if ("node" !== 'browser') {
            return import(path);
        } else {
            return new Promise((resolve, reject)=>{
                const script = document.createElement('script');
                script.src = path;
                document.body.appendChild(script);
                script.onload = ()=>{
                    resolve();
                };
                script.onerror = (e)=>{
                    reject(e);
                };
            });
        }
    }
    _loadLink(path) {
        if ("node" !== 'browser') {
            return Promise.resolve();
        } else {
            return new Promise((resolve, reject)=>{
                const link = document.createElement('link');
                link.rel = 'stylesheet';
                link.href = path;
                document.head.appendChild(link);
                link.onload = ()=>{
                    resolve();
                };
                link.onerror = (e)=>{
                    reject(e);
                };
            });
        }
    }
}
var resource_loader_js_ns = {
    ResourceLoader: ResourceLoader,
    __farm_global_this__: __farm_global_this__,
    __global_this__: __global_this__$1,
    isBrowser: isBrowser,
    targetEnv: targetEnv,
    __esModule: true
};

class ModuleSystem {
    constructor(){
        this.dynamicResources = [];
        this.modules = {};
        this.cache = {};
        this.publicPaths = [];
        this.dynamicModuleResourcesMap = {};
        this.resourceLoader = new ResourceLoader(this, this.publicPaths);
        this.pluginContainer = new FarmRuntimePluginContainer([]);
        this.targetEnv = targetEnv;
        this.externalModules = {};
        this.reRegisterModules = false;
    }
    require(moduleId, isCJS = false) {
        if (this.cache[moduleId]) {
            const shouldSkip = this.pluginContainer.hookBail("readModuleCache", this.cache[moduleId]);
            if (!shouldSkip) {
                const cachedModule = this.cache[moduleId];
                return cachedModule.initializer || cachedModule.exports;
            }
        }
        const initializer = this.modules[moduleId];
        if (!initializer) {
            if (this.externalModules[moduleId]) {
                const exports = this.externalModules[moduleId];
                if (isCJS) {
                    return exports.default || exports;
                }
                return exports;
            }
            if ((this.targetEnv === "node" || !isBrowser) && nodeRequire) {
                const externalModule = nodeRequire(moduleId);
                return externalModule;
            }
            this.pluginContainer.hookSerial("moduleNotFound", moduleId);
            console.debug(`[Farm] Module "${moduleId}" is not registered`);
            return {};
        }
        const module = new Module(moduleId, this.require.bind(this));
        module.resource_pot = initializer.__farm_resource_pot__;
        this.pluginContainer.hookSerial("moduleCreated", module);
        this.cache[moduleId] = module;
        if (!__global_this__$1.require) {
            __global_this__$1.require = this.require.bind(this);
        }
        const result$3 = initializer(module, module.exports, this.require.bind(this), this.farmDynamicRequire.bind(this));
        if (result$3 && result$3 instanceof Promise) {
            module.initializer = result$3.then(()=>{
                this.pluginContainer.hookSerial("moduleInitialized", module);
                module.initializer = undefined;
                return module.exports;
            });
            return module.initializer;
        } else {
            this.pluginContainer.hookSerial("moduleInitialized", module);
            return module.exports;
        }
    }
    farmDynamicRequire(moduleId) {
        if (this.modules[moduleId]) {
            const exports$1 = this.require(moduleId);
            if (exports$1.__farm_async) {
                return exports$1.default;
            } else {
                return Promise.resolve(exports$1);
            }
        }
        return this.loadDynamicResources(moduleId);
    }
    loadDynamicResourcesOnly(moduleId, force = false) {
        const resources = this.dynamicModuleResourcesMap[moduleId].map((index)=>this.dynamicResources[index]);
        if (!resources || resources.length === 0) {
            throw new Error(`Dynamic imported module "${moduleId}" does not belong to any resource`);
        }
        if (force) {
            this.clearCache(moduleId);
        }
        return Promise.all(resources.map((resource)=>{
            if (force) {
                const resourceLoaded = this.resourceLoader.isResourceLoaded(resource.path);
                this.resourceLoader.setLoadedResource(resource.path, false);
                if (resourceLoaded) {
                    return this.resourceLoader.load({
                        ...resource,
                        path: `${resource.path}?t=${Date.now()}`
                    });
                }
            }
            return this.resourceLoader.load(resource);
        }));
    }
    loadDynamicResources(moduleId, force = false) {
        const resources$1 = this.dynamicModuleResourcesMap[moduleId].map((index)=>this.dynamicResources[index]);
        return this.loadDynamicResourcesOnly(moduleId, force).then(()=>{
            if (resources$1.every((resource)=>resource.type !== 0)) {
                return;
            }
            if (!this.modules[moduleId]) {
                throw new Error(`Dynamic imported module "${moduleId}" is not registered.`);
            }
            const result$4 = this.require(moduleId);
            if (result$4.__farm_async) {
                return result$4.default;
            } else {
                return result$4;
            }
        }).catch((err)=>{
            console.error(`[Farm] Error loading dynamic module "${moduleId}"`, err);
            throw err;
        });
    }
    register(moduleId, initializer) {
        if (this.modules[moduleId] && !this.reRegisterModules) {
            console.warn(`Module "${moduleId}" has registered! It should not be registered twice`);
            return;
        }
        this.modules[moduleId] = initializer;
    }
    update(moduleId, init) {
        this.modules[moduleId] = init;
        this.clearCache(moduleId);
    }
    delete(moduleId) {
        if (this.modules[moduleId]) {
            this.clearCache(moduleId);
            delete this.modules[moduleId];
            return true;
        } else {
            return false;
        }
    }
    getModuleUrl(moduleId) {
        const publicPath$1 = this.publicPaths[0] ?? "";
        if (isBrowser) {
            const url$1 = `${window.location.protocol}//${window.location.host}${publicPath$1.endsWith("/") ? publicPath$1.slice(0, -1) : publicPath$1}/${this.modules[moduleId].__farm_resource_pot__}`;
            return url$1;
        } else {
            return this.modules[moduleId].__farm_resource_pot__;
        }
    }
    getCache(moduleId) {
        return this.cache[moduleId];
    }
    clearCache(moduleId) {
        if (this.cache[moduleId]) {
            delete this.cache[moduleId];
            return true;
        } else {
            return false;
        }
    }
    setInitialLoadedResources(resources) {
        for (const resource of resources){
            this.resourceLoader.setLoadedResource(resource);
        }
    }
    setDynamicModuleResourcesMap(dynamicResources, dynamicModuleResourcesMap) {
        this.dynamicResources = dynamicResources;
        this.dynamicModuleResourcesMap = dynamicModuleResourcesMap;
    }
    setPublicPaths(publicPaths) {
        this.publicPaths = publicPaths;
        this.resourceLoader.publicPaths = this.publicPaths;
    }
    setPlugins(plugins) {
        this.pluginContainer.plugins = plugins;
    }
    addPlugin(plugin) {
        if (this.pluginContainer.plugins.every((p)=>p.name !== plugin.name)) {
            this.pluginContainer.plugins.push(plugin);
        }
    }
    removePlugin(pluginName) {
        this.pluginContainer.plugins = this.pluginContainer.plugins.filter((p)=>p.name !== pluginName);
    }
    setExternalModules(externalModules) {
        Object.assign(this.externalModules, externalModules || {});
    }
    bootstrap() {
        this.pluginContainer.hookSerial("bootstrap", this);
    }
}

__farm_global_this__.__farm_module_system__ = (function() {
    const moduleSystem = new ModuleSystem();
    return function() {
        return moduleSystem;
    };
})()();
global['973501ed6cc362643bd39f42d007cdf1'].__farm_module_system__.setPlugins([
    index_js_default
]);
var __farm_external_module_child_process = require("child_process");var __farm_external_module_chokidar = require("chokidar");var __farm_external_module_farm_browserslist_generator = require("farm-browserslist-generator");var __farm_external_module_fs = require("fs");var __farm_external_module_fs_promises = require("fs/promises");var __farm_external_module_http = require("http");var __farm_external_module_module = require("module");var __farm_external_module_node_buffer = require("node:buffer");var __farm_external_module_node_child_process = require("node:child_process");var __farm_external_module_node_crypto = require("node:crypto");var __farm_external_module_node_fs = require("node:fs");var __farm_external_module_node_fs_promises = require("node:fs/promises");var __farm_external_module_node_http = require("node:http");var __farm_external_module_node_http2 = require("node:http2");var __farm_external_module_node_https = require("node:https");var __farm_external_module_node_module = require("node:module");var __farm_external_module_node_os = require("node:os");var __farm_external_module_node_path = require("node:path");var __farm_external_module_node_perf_hooks = require("node:perf_hooks");var __farm_external_module_node_process = require("node:process");var __farm_external_module_node_querystring = require("node:querystring");var __farm_external_module_node_readline = require("node:readline");var __farm_external_module_node_url = require("node:url");var __farm_external_module_node_util = require("node:util");var __farm_external_module_os = require("os");var __farm_external_module_path = require("path");var __farm_external_module_url = require("url");global['973501ed6cc362643bd39f42d007cdf1'].__farm_module_system__.setExternalModules({"child_process": __farm_external_module_child_process,"chokidar": __farm_external_module_chokidar,"farm-browserslist-generator": __farm_external_module_farm_browserslist_generator,"fs": __farm_external_module_fs,"fs/promises": __farm_external_module_fs_promises,"http": __farm_external_module_http,"module": __farm_external_module_module,"node:buffer": __farm_external_module_node_buffer,"node:child_process": __farm_external_module_node_child_process,"node:crypto": __farm_external_module_node_crypto,"node:fs": __farm_external_module_node_fs,"node:fs/promises": __farm_external_module_node_fs_promises,"node:http": __farm_external_module_node_http,"node:http2": __farm_external_module_node_http2,"node:https": __farm_external_module_node_https,"node:module": __farm_external_module_node_module,"node:os": __farm_external_module_node_os,"node:path": __farm_external_module_node_path,"node:perf_hooks": __farm_external_module_node_perf_hooks,"node:process": __farm_external_module_node_process,"node:querystring": __farm_external_module_node_querystring,"node:readline": __farm_external_module_node_readline,"node:url": __farm_external_module_node_url,"node:util": __farm_external_module_node_util,"os": __farm_external_module_os,"path": __farm_external_module_path,"url": __farm_external_module_url});(function(_){var filename = ((function(){var _documentCurrentScript = typeof document !== "undefined" ? document.currentScript : null;return typeof document === "undefined" ? require("url").pathToFileURL(__filename).href : _documentCurrentScript && _documentCurrentScript.src || new URL("index.js", document.baseURI).href})());for(var r in _){_[r].__farm_resource_pot__=filename;global['973501ed6cc362643bd39f42d007cdf1'].__farm_module_system__.register(r,_[r])}})({"000f5984":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const kDone = Symbol('kDone');
    const kRun = Symbol('kRun');
    class Limiter {
        constructor(concurrency){
            this[kDone] = ()=>{
                this.pending--;
                this[kRun]();
            };
            this.concurrency = concurrency || Infinity;
            this.jobs = [];
            this.pending = 0;
        }
        add(job) {
            this.jobs.push(job);
            this[kRun]();
        }
        [kRun]() {
            if (this.pending === this.concurrency) return;
            if (this.jobs.length) {
                const job = this.jobs.shift();
                this.pending++;
                job(this[kDone]);
            }
        }
    }
    module.exports = Limiter;
}
,
"00193f2e":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "isNonEmptyArray", ()=>isNonEmptyArray);
    function isNonEmptyArray(value) {
        return value.length !== 0;
    }
}
,
"001be097":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.Settings = exports.scandirSync = exports.scandir = void 0;
    const async = farmRequire("240e7692", true);
    const sync = farmRequire("71758cda", true);
    const settings_1 = farmRequire("a29d9e0e", true);
    exports.Settings = settings_1.default;
    function scandir(path, optionsOrSettingsOrCallback, callback) {
        if (typeof optionsOrSettingsOrCallback === 'function') {
            async.read(path, getSettings(), optionsOrSettingsOrCallback);
            return;
        }
        async.read(path, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports.scandir = scandir;
    function scandirSync(path, optionsOrSettings) {
        const settings = getSettings(optionsOrSettings);
        return sync.read(path, settings);
    }
    exports.scandirSync = scandirSync;
    function getSettings(settingsOrOptions = {}) {
        if (settingsOrOptions instanceof settings_1.default) {
            return settingsOrOptions;
        }
        return new settings_1.default(settingsOrOptions);
    }
}
,
"00c72d38":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const constants = farmRequire("685edf14", true);
    const utils = farmRequire("48dceba4", true);
    const { MAX_LENGTH, POSIX_REGEX_SOURCE, REGEX_NON_SPECIAL_CHARS, REGEX_SPECIAL_CHARS_BACKREF, REPLACEMENTS } = constants;
    const expandRange = (args, options)=>{
        if (typeof options.expandRange === 'function') {
            return options.expandRange(...args, options);
        }
        args.sort();
        const value = `[${args.join('-')}]`;
        try {
            new RegExp(value);
        } catch (ex) {
            return args.map((v)=>utils.escapeRegex(v)).join('..');
        }
        return value;
    };
    const syntaxError = (type, char)=>{
        return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    const parse = (input, options)=>{
        if (typeof input !== 'string') {
            throw new TypeError('Expected a string');
        }
        input = REPLACEMENTS[input] || input;
        const opts = {
            ...options
        };
        const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
        let len = input.length;
        if (len > max) {
            throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
        }
        const bos = {
            type: 'bos',
            value: '',
            output: opts.prepend || ''
        };
        const tokens = [
            bos
        ];
        const capture = opts.capture ? '' : '?:';
        const win32 = utils.isWindows(options);
        const PLATFORM_CHARS = constants.globChars(win32);
        const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
        const { DOT_LITERAL, PLUS_LITERAL, SLASH_LITERAL, ONE_CHAR, DOTS_SLASH, NO_DOT, NO_DOT_SLASH, NO_DOTS_SLASH, QMARK, QMARK_NO_DOT, STAR, START_ANCHOR } = PLATFORM_CHARS;
        const globstar = (opts)=>{
            return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
        };
        const nodot = opts.dot ? '' : NO_DOT;
        const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
        let star = opts.bash === true ? globstar(opts) : STAR;
        if (opts.capture) {
            star = `(${star})`;
        }
        if (typeof opts.noext === 'boolean') {
            opts.noextglob = opts.noext;
        }
        const state = {
            input,
            index: -1,
            start: 0,
            dot: opts.dot === true,
            consumed: '',
            output: '',
            prefix: '',
            backtrack: false,
            negated: false,
            brackets: 0,
            braces: 0,
            parens: 0,
            quotes: 0,
            globstar: false,
            tokens
        };
        input = utils.removePrefix(input, state);
        len = input.length;
        const extglobs = [];
        const braces = [];
        const stack = [];
        let prev = bos;
        let value;
        const eos = ()=>state.index === len - 1;
        const peek = state.peek = (n = 1)=>input[state.index + n];
        const advance = state.advance = ()=>input[++state.index] || '';
        const remaining = ()=>input.slice(state.index + 1);
        const consume = (value = '', num = 0)=>{
            state.consumed += value;
            state.index += num;
        };
        const append = (token)=>{
            state.output += token.output != null ? token.output : token.value;
            consume(token.value);
        };
        const negate = ()=>{
            let count = 1;
            while(peek() === '!' && (peek(2) !== '(' || peek(3) === '?')){
                advance();
                state.start++;
                count++;
            }
            if (count % 2 === 0) {
                return false;
            }
            state.negated = true;
            state.start++;
            return true;
        };
        const increment = (type)=>{
            state[type]++;
            stack.push(type);
        };
        const decrement = (type)=>{
            state[type]--;
            stack.pop();
        };
        const push = (tok)=>{
            if (prev.type === 'globstar') {
                const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');
                const isExtglob = tok.extglob === true || extglobs.length && (tok.type === 'pipe' || tok.type === 'paren');
                if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {
                    state.output = state.output.slice(0, -prev.output.length);
                    prev.type = 'star';
                    prev.value = '*';
                    prev.output = star;
                    state.output += prev.output;
                }
            }
            if (extglobs.length && tok.type !== 'paren') {
                extglobs[extglobs.length - 1].inner += tok.value;
            }
            if (tok.value || tok.output) append(tok);
            if (prev && prev.type === 'text' && tok.type === 'text') {
                prev.value += tok.value;
                prev.output = (prev.output || '') + tok.value;
                return;
            }
            tok.prev = prev;
            tokens.push(tok);
            prev = tok;
        };
        const extglobOpen = (type, value)=>{
            const token = {
                ...EXTGLOB_CHARS[value],
                conditions: 1,
                inner: ''
            };
            token.prev = prev;
            token.parens = state.parens;
            token.output = state.output;
            const output = (opts.capture ? '(' : '') + token.open;
            increment('parens');
            push({
                type,
                value,
                output: state.output ? '' : ONE_CHAR
            });
            push({
                type: 'paren',
                extglob: true,
                value: advance(),
                output
            });
            extglobs.push(token);
        };
        const extglobClose = (token)=>{
            let output = token.close + (opts.capture ? ')' : '');
            let rest;
            if (token.type === 'negate') {
                let extglobStar = star;
                if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {
                    extglobStar = globstar(opts);
                }
                if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
                    output = token.close = `)$))${extglobStar}`;
                }
                if (token.inner.includes('*') && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
                    const expression = parse(rest, {
                        ...options,
                        fastpaths: false
                    }).output;
                    output = token.close = `)${expression})${extglobStar})`;
                }
                if (token.prev.type === 'bos') {
                    state.negatedExtglob = true;
                }
            }
            push({
                type: 'paren',
                extglob: true,
                value,
                output
            });
            decrement('parens');
        };
        if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
            let backslashes = false;
            let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index)=>{
                if (first === '\\') {
                    backslashes = true;
                    return m;
                }
                if (first === '?') {
                    if (esc) {
                        return esc + first + (rest ? QMARK.repeat(rest.length) : '');
                    }
                    if (index === 0) {
                        return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');
                    }
                    return QMARK.repeat(chars.length);
                }
                if (first === '.') {
                    return DOT_LITERAL.repeat(chars.length);
                }
                if (first === '*') {
                    if (esc) {
                        return esc + first + (rest ? star : '');
                    }
                    return star;
                }
                return esc ? m : `\\${m}`;
            });
            if (backslashes === true) {
                if (opts.unescape === true) {
                    output = output.replace(/\\/g, '');
                } else {
                    output = output.replace(/\\+/g, (m)=>{
                        return m.length % 2 === 0 ? '\\\\' : m ? '\\' : '';
                    });
                }
            }
            if (output === input && opts.contains === true) {
                state.output = input;
                return state;
            }
            state.output = utils.wrapOutput(output, state, options);
            return state;
        }
        while(!eos()){
            value = advance();
            if (value === '\u0000') {
                continue;
            }
            if (value === '\\') {
                const next = peek();
                if (next === '/' && opts.bash !== true) {
                    continue;
                }
                if (next === '.' || next === ';') {
                    continue;
                }
                if (!next) {
                    value += '\\';
                    push({
                        type: 'text',
                        value
                    });
                    continue;
                }
                const match = /^\\+/.exec(remaining());
                let slashes = 0;
                if (match && match[0].length > 2) {
                    slashes = match[0].length;
                    state.index += slashes;
                    if (slashes % 2 !== 0) {
                        value += '\\';
                    }
                }
                if (opts.unescape === true) {
                    value = advance();
                } else {
                    value += advance();
                }
                if (state.brackets === 0) {
                    push({
                        type: 'text',
                        value
                    });
                    continue;
                }
            }
            if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {
                if (opts.posix !== false && value === ':') {
                    const inner = prev.value.slice(1);
                    if (inner.includes('[')) {
                        prev.posix = true;
                        if (inner.includes(':')) {
                            const idx = prev.value.lastIndexOf('[');
                            const pre = prev.value.slice(0, idx);
                            const rest = prev.value.slice(idx + 2);
                            const posix = POSIX_REGEX_SOURCE[rest];
                            if (posix) {
                                prev.value = pre + posix;
                                state.backtrack = true;
                                advance();
                                if (!bos.output && tokens.indexOf(prev) === 1) {
                                    bos.output = ONE_CHAR;
                                }
                                continue;
                            }
                        }
                    }
                }
                if (value === '[' && peek() !== ':' || value === '-' && peek() === ']') {
                    value = `\\${value}`;
                }
                if (value === ']' && (prev.value === '[' || prev.value === '[^')) {
                    value = `\\${value}`;
                }
                if (opts.posix === true && value === '!' && prev.value === '[') {
                    value = '^';
                }
                prev.value += value;
                append({
                    value
                });
                continue;
            }
            if (state.quotes === 1 && value !== '"') {
                value = utils.escapeRegex(value);
                prev.value += value;
                append({
                    value
                });
                continue;
            }
            if (value === '"') {
                state.quotes = state.quotes === 1 ? 0 : 1;
                if (opts.keepQuotes === true) {
                    push({
                        type: 'text',
                        value
                    });
                }
                continue;
            }
            if (value === '(') {
                increment('parens');
                push({
                    type: 'paren',
                    value
                });
                continue;
            }
            if (value === ')') {
                if (state.parens === 0 && opts.strictBrackets === true) {
                    throw new SyntaxError(syntaxError('opening', '('));
                }
                const extglob = extglobs[extglobs.length - 1];
                if (extglob && state.parens === extglob.parens + 1) {
                    extglobClose(extglobs.pop());
                    continue;
                }
                push({
                    type: 'paren',
                    value,
                    output: state.parens ? ')' : '\\)'
                });
                decrement('parens');
                continue;
            }
            if (value === '[') {
                if (opts.nobracket === true || !remaining().includes(']')) {
                    if (opts.nobracket !== true && opts.strictBrackets === true) {
                        throw new SyntaxError(syntaxError('closing', ']'));
                    }
                    value = `\\${value}`;
                } else {
                    increment('brackets');
                }
                push({
                    type: 'bracket',
                    value
                });
                continue;
            }
            if (value === ']') {
                if (opts.nobracket === true || prev && prev.type === 'bracket' && prev.value.length === 1) {
                    push({
                        type: 'text',
                        value,
                        output: `\\${value}`
                    });
                    continue;
                }
                if (state.brackets === 0) {
                    if (opts.strictBrackets === true) {
                        throw new SyntaxError(syntaxError('opening', '['));
                    }
                    push({
                        type: 'text',
                        value,
                        output: `\\${value}`
                    });
                    continue;
                }
                decrement('brackets');
                const prevValue = prev.value.slice(1);
                if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {
                    value = `/${value}`;
                }
                prev.value += value;
                append({
                    value
                });
                if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
                    continue;
                }
                const escaped = utils.escapeRegex(prev.value);
                state.output = state.output.slice(0, -prev.value.length);
                if (opts.literalBrackets === true) {
                    state.output += escaped;
                    prev.value = escaped;
                    continue;
                }
                prev.value = `(${capture}${escaped}|${prev.value})`;
                state.output += prev.value;
                continue;
            }
            if (value === '{' && opts.nobrace !== true) {
                increment('braces');
                const open = {
                    type: 'brace',
                    value,
                    output: '(',
                    outputIndex: state.output.length,
                    tokensIndex: state.tokens.length
                };
                braces.push(open);
                push(open);
                continue;
            }
            if (value === '}') {
                const brace = braces[braces.length - 1];
                if (opts.nobrace === true || !brace) {
                    push({
                        type: 'text',
                        value,
                        output: value
                    });
                    continue;
                }
                let output = ')';
                if (brace.dots === true) {
                    const arr = tokens.slice();
                    const range = [];
                    for(let i = arr.length - 1; i >= 0; i--){
                        tokens.pop();
                        if (arr[i].type === 'brace') {
                            break;
                        }
                        if (arr[i].type !== 'dots') {
                            range.unshift(arr[i].value);
                        }
                    }
                    output = expandRange(range, opts);
                    state.backtrack = true;
                }
                if (brace.comma !== true && brace.dots !== true) {
                    const out = state.output.slice(0, brace.outputIndex);
                    const toks = state.tokens.slice(brace.tokensIndex);
                    brace.value = brace.output = '\\{';
                    value = output = '\\}';
                    state.output = out;
                    for (const t of toks){
                        state.output += t.output || t.value;
                    }
                }
                push({
                    type: 'brace',
                    value,
                    output
                });
                decrement('braces');
                braces.pop();
                continue;
            }
            if (value === '|') {
                if (extglobs.length > 0) {
                    extglobs[extglobs.length - 1].conditions++;
                }
                push({
                    type: 'text',
                    value
                });
                continue;
            }
            if (value === ',') {
                let output = value;
                const brace = braces[braces.length - 1];
                if (brace && stack[stack.length - 1] === 'braces') {
                    brace.comma = true;
                    output = '|';
                }
                push({
                    type: 'comma',
                    value,
                    output
                });
                continue;
            }
            if (value === '/') {
                if (prev.type === 'dot' && state.index === state.start + 1) {
                    state.start = state.index + 1;
                    state.consumed = '';
                    state.output = '';
                    tokens.pop();
                    prev = bos;
                    continue;
                }
                push({
                    type: 'slash',
                    value,
                    output: SLASH_LITERAL
                });
                continue;
            }
            if (value === '.') {
                if (state.braces > 0 && prev.type === 'dot') {
                    if (prev.value === '.') prev.output = DOT_LITERAL;
                    const brace = braces[braces.length - 1];
                    prev.type = 'dots';
                    prev.output += value;
                    prev.value += value;
                    brace.dots = true;
                    continue;
                }
                if (state.braces + state.parens === 0 && prev.type !== 'bos' && prev.type !== 'slash') {
                    push({
                        type: 'text',
                        value,
                        output: DOT_LITERAL
                    });
                    continue;
                }
                push({
                    type: 'dot',
                    value,
                    output: DOT_LITERAL
                });
                continue;
            }
            if (value === '?') {
                const isGroup = prev && prev.value === '(';
                if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
                    extglobOpen('qmark', value);
                    continue;
                }
                if (prev && prev.type === 'paren') {
                    const next = peek();
                    let output = value;
                    if (next === '<' && !utils.supportsLookbehinds()) {
                        throw new Error('Node.js v10 or higher is required for regex lookbehinds');
                    }
                    if (prev.value === '(' && !/[!=<:]/.test(next) || next === '<' && !/<([!=]|\w+>)/.test(remaining())) {
                        output = `\\${value}`;
                    }
                    push({
                        type: 'text',
                        value,
                        output
                    });
                    continue;
                }
                if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {
                    push({
                        type: 'qmark',
                        value,
                        output: QMARK_NO_DOT
                    });
                    continue;
                }
                push({
                    type: 'qmark',
                    value,
                    output: QMARK
                });
                continue;
            }
            if (value === '!') {
                if (opts.noextglob !== true && peek() === '(') {
                    if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {
                        extglobOpen('negate', value);
                        continue;
                    }
                }
                if (opts.nonegate !== true && state.index === 0) {
                    negate();
                    continue;
                }
            }
            if (value === '+') {
                if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
                    extglobOpen('plus', value);
                    continue;
                }
                if (prev && prev.value === '(' || opts.regex === false) {
                    push({
                        type: 'plus',
                        value,
                        output: PLUS_LITERAL
                    });
                    continue;
                }
                if (prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace') || state.parens > 0) {
                    push({
                        type: 'plus',
                        value
                    });
                    continue;
                }
                push({
                    type: 'plus',
                    value: PLUS_LITERAL
                });
                continue;
            }
            if (value === '@') {
                if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
                    push({
                        type: 'at',
                        extglob: true,
                        value,
                        output: ''
                    });
                    continue;
                }
                push({
                    type: 'text',
                    value
                });
                continue;
            }
            if (value !== '*') {
                if (value === '$' || value === '^') {
                    value = `\\${value}`;
                }
                const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
                if (match) {
                    value += match[0];
                    state.index += match[0].length;
                }
                push({
                    type: 'text',
                    value
                });
                continue;
            }
            if (prev && (prev.type === 'globstar' || prev.star === true)) {
                prev.type = 'star';
                prev.star = true;
                prev.value += value;
                prev.output = star;
                state.backtrack = true;
                state.globstar = true;
                consume(value);
                continue;
            }
            let rest = remaining();
            if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
                extglobOpen('star', value);
                continue;
            }
            if (prev.type === 'star') {
                if (opts.noglobstar === true) {
                    consume(value);
                    continue;
                }
                const prior = prev.prev;
                const before = prior.prev;
                const isStart = prior.type === 'slash' || prior.type === 'bos';
                const afterStar = before && (before.type === 'star' || before.type === 'globstar');
                if (opts.bash === true && (!isStart || rest[0] && rest[0] !== '/')) {
                    push({
                        type: 'star',
                        value,
                        output: ''
                    });
                    continue;
                }
                const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');
                const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');
                if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {
                    push({
                        type: 'star',
                        value,
                        output: ''
                    });
                    continue;
                }
                while(rest.slice(0, 3) === '/**'){
                    const after = input[state.index + 4];
                    if (after && after !== '/') {
                        break;
                    }
                    rest = rest.slice(3);
                    consume('/**', 3);
                }
                if (prior.type === 'bos' && eos()) {
                    prev.type = 'globstar';
                    prev.value += value;
                    prev.output = globstar(opts);
                    state.output = prev.output;
                    state.globstar = true;
                    consume(value);
                    continue;
                }
                if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {
                    state.output = state.output.slice(0, -(prior.output + prev.output).length);
                    prior.output = `(?:${prior.output}`;
                    prev.type = 'globstar';
                    prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');
                    prev.value += value;
                    state.globstar = true;
                    state.output += prior.output + prev.output;
                    consume(value);
                    continue;
                }
                if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {
                    const end = rest[1] !== void 0 ? '|$' : '';
                    state.output = state.output.slice(0, -(prior.output + prev.output).length);
                    prior.output = `(?:${prior.output}`;
                    prev.type = 'globstar';
                    prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
                    prev.value += value;
                    state.output += prior.output + prev.output;
                    state.globstar = true;
                    consume(value + advance());
                    push({
                        type: 'slash',
                        value: '/',
                        output: ''
                    });
                    continue;
                }
                if (prior.type === 'bos' && rest[0] === '/') {
                    prev.type = 'globstar';
                    prev.value += value;
                    prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
                    state.output = prev.output;
                    state.globstar = true;
                    consume(value + advance());
                    push({
                        type: 'slash',
                        value: '/',
                        output: ''
                    });
                    continue;
                }
                state.output = state.output.slice(0, -prev.output.length);
                prev.type = 'globstar';
                prev.output = globstar(opts);
                prev.value += value;
                state.output += prev.output;
                state.globstar = true;
                consume(value);
                continue;
            }
            const token = {
                type: 'star',
                value,
                output: star
            };
            if (opts.bash === true) {
                token.output = '.*?';
                if (prev.type === 'bos' || prev.type === 'slash') {
                    token.output = nodot + token.output;
                }
                push(token);
                continue;
            }
            if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {
                token.output = value;
                push(token);
                continue;
            }
            if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {
                if (prev.type === 'dot') {
                    state.output += NO_DOT_SLASH;
                    prev.output += NO_DOT_SLASH;
                } else if (opts.dot === true) {
                    state.output += NO_DOTS_SLASH;
                    prev.output += NO_DOTS_SLASH;
                } else {
                    state.output += nodot;
                    prev.output += nodot;
                }
                if (peek() !== '*') {
                    state.output += ONE_CHAR;
                    prev.output += ONE_CHAR;
                }
            }
            push(token);
        }
        while(state.brackets > 0){
            if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));
            state.output = utils.escapeLast(state.output, '[');
            decrement('brackets');
        }
        while(state.parens > 0){
            if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));
            state.output = utils.escapeLast(state.output, '(');
            decrement('parens');
        }
        while(state.braces > 0){
            if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));
            state.output = utils.escapeLast(state.output, '{');
            decrement('braces');
        }
        if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {
            push({
                type: 'maybe_slash',
                value: '',
                output: `${SLASH_LITERAL}?`
            });
        }
        if (state.backtrack === true) {
            state.output = '';
            for (const token of state.tokens){
                state.output += token.output != null ? token.output : token.value;
                if (token.suffix) {
                    state.output += token.suffix;
                }
            }
        }
        return state;
    };
    parse.fastpaths = (input, options)=>{
        const opts = {
            ...options
        };
        const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
        const len = input.length;
        if (len > max) {
            throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
        }
        input = REPLACEMENTS[input] || input;
        const win32 = utils.isWindows(options);
        const { DOT_LITERAL, SLASH_LITERAL, ONE_CHAR, DOTS_SLASH, NO_DOT, NO_DOTS, NO_DOTS_SLASH, STAR, START_ANCHOR } = constants.globChars(win32);
        const nodot = opts.dot ? NO_DOTS : NO_DOT;
        const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
        const capture = opts.capture ? '' : '?:';
        const state = {
            negated: false,
            prefix: ''
        };
        let star = opts.bash === true ? '.*?' : STAR;
        if (opts.capture) {
            star = `(${star})`;
        }
        const globstar = (opts)=>{
            if (opts.noglobstar === true) return star;
            return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
        };
        const create = (str)=>{
            switch(str){
                case '*':
                    return `${nodot}${ONE_CHAR}${star}`;
                case '.*':
                    return `${DOT_LITERAL}${ONE_CHAR}${star}`;
                case '*.*':
                    return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
                case '*/*':
                    return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
                case '**':
                    return nodot + globstar(opts);
                case '**/*':
                    return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
                case '**/*.*':
                    return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
                case '**/.*':
                    return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
                default:
                    {
                        const match = /^(.*?)\.(\w+)$/.exec(str);
                        if (!match) return;
                        const source = create(match[1]);
                        if (!source) return;
                        return source + DOT_LITERAL + match[2];
                    }
            }
        };
        const output = utils.removePrefix(input, state);
        let source = create(output);
        if (source && opts.strictSlashes !== true) {
            source += `${SLASH_LITERAL}?`;
        }
        return source;
    };
    module.exports = parse;
}
,
"02c34790":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "checkPublicFile", ()=>checkPublicFile);
    module.o(exports, "initPublicFiles", ()=>initPublicFiles);
    var _f_fs = module.i(farmRequire('fs'));
    var _f_path = module.i(farmRequire('path'));
    var _f_file = farmRequire("ac9f1e68");
    var _f_path1 = farmRequire("e1334335");
    var _f_share = farmRequire("bc6cc539");
    var _f_url = farmRequire("189f7617");
    const publicFilesMap = new WeakMap();
    async function checkPublicFile(url, config) {
        const { publicDir } = config;
        if (!publicDir || url[0] !== '/') {
            return;
        }
        await initPublicFiles(config);
        const fileName = _f_url.cleanUrl(url);
        const publicFiles = getPublicFiles(config);
        if (publicFiles) {
            return publicFiles.has(fileName) ? _f_share.normalizePath(module.f(_f_path).join(publicDir, fileName)) : undefined;
        }
        const publicFile = _f_share.normalizePath(module.f(_f_path).join(publicDir, fileName));
        if (!publicFile.startsWith(_f_path1.withTrailingSlash(publicDir))) {
            return;
        }
        return module.f(_f_fs).existsSync(publicFile) ? publicFile : undefined;
    }
    async function initPublicFiles(config) {
        let fileNames;
        try {
            fileNames = await _f_file.recursiveReaddir(config.publicDir);
        } catch (e) {
            if (e.code === _f_file.ERR_SYMLINK_IN_RECURSIVE_READDIR) {
                return;
            }
            throw e;
        }
        const publicFiles = new Set(fileNames.map((fileName)=>fileName.slice(config.publicDir.length)));
        publicFilesMap.set(config, publicFiles);
        return publicFiles;
    }
    function getPublicFiles(config) {
        return publicFilesMap.get(config);
    }
}
,
"0403cc2d":function  (module, exports, farmRequire, farmDynamicRequire) {
    const fs = global.nodeRequire('fs', true);
    const util = global.nodeRequire('util', true);
    const debug = farmRequire("d6403b64")('koa-send');
    const resolvePath = farmRequire("544e7bac", true);
    const createError = farmRequire("48aa4d88", true);
    const assert = global.nodeRequire('assert', true);
    const stat = util.promisify(fs.stat);
    const access = util.promisify(fs.access);
    async function exists(path) {
        try {
            await access(path);
            return true;
        } catch (e) {
            return false;
        }
    }
    const { normalize, basename, extname, resolve, parse, sep } = global.nodeRequire('path', true);
    module.exports = send;
    async function send(ctx, path, opts = {}) {
        assert(ctx, 'koa context required');
        assert(path, 'pathname required');
        debug('send "%s" %j', path, opts);
        const root = opts.root ? normalize(resolve(opts.root)) : '';
        const trailingSlash = path[path.length - 1] === '/';
        path = path.substr(parse(path).root.length);
        const index = opts.index;
        const maxage = opts.maxage || opts.maxAge || 0;
        const immutable = opts.immutable || false;
        const hidden = opts.hidden || false;
        const format = opts.format !== false;
        const extensions = Array.isArray(opts.extensions) ? opts.extensions : false;
        const brotli = opts.brotli !== false;
        const gzip = opts.gzip !== false;
        const setHeaders = opts.setHeaders;
        if (setHeaders && typeof setHeaders !== 'function') {
            throw new TypeError('option setHeaders must be function');
        }
        path = decode(path);
        if (path === -1) return ctx.throw(400, 'failed to decode');
        if (index && trailingSlash) path += index;
        path = resolvePath(root, path);
        if (!hidden && isHidden(root, path)) return;
        let encodingExt = '';
        if (ctx.acceptsEncodings('br', 'identity') === 'br' && brotli && await exists(path + '.br')) {
            path = path + '.br';
            ctx.set('Content-Encoding', 'br');
            ctx.res.removeHeader('Content-Length');
            encodingExt = '.br';
        } else if (ctx.acceptsEncodings('gzip', 'identity') === 'gzip' && gzip && await exists(path + '.gz')) {
            path = path + '.gz';
            ctx.set('Content-Encoding', 'gzip');
            ctx.res.removeHeader('Content-Length');
            encodingExt = '.gz';
        }
        if (extensions && !/\./.exec(basename(path))) {
            const list = [].concat(extensions);
            for(let i = 0; i < list.length; i++){
                let ext = list[i];
                if (typeof ext !== 'string') {
                    throw new TypeError('option extensions must be array of strings or false');
                }
                if (!/^\./.exec(ext)) ext = `.${ext}`;
                if (await exists(`${path}${ext}`)) {
                    path = `${path}${ext}`;
                    break;
                }
            }
        }
        let stats;
        try {
            stats = await stat(path);
            if (stats.isDirectory()) {
                if (format && index) {
                    path += `/${index}`;
                    stats = await stat(path);
                } else {
                    return;
                }
            }
        } catch (err) {
            const notfound = [
                'ENOENT',
                'ENAMETOOLONG',
                'ENOTDIR'
            ];
            if (notfound.includes(err.code)) {
                throw createError(404, err);
            }
            err.status = 500;
            throw err;
        }
        if (setHeaders) setHeaders(ctx.res, path, stats);
        ctx.set('Content-Length', stats.size);
        if (!ctx.response.get('Last-Modified')) ctx.set('Last-Modified', stats.mtime.toUTCString());
        if (!ctx.response.get('Cache-Control')) {
            const directives = [
                `max-age=${maxage / 1000 | 0}`
            ];
            if (immutable) {
                directives.push('immutable');
            }
            ctx.set('Cache-Control', directives.join(','));
        }
        if (!ctx.type) ctx.type = type(path, encodingExt);
        ctx.body = fs.createReadStream(path);
        return path;
    }
    function isHidden(root, path) {
        path = path.substr(root.length).split(sep);
        for(let i = 0; i < path.length; i++){
            if (path[i][0] === '.') return true;
        }
        return false;
    }
    function type(file, ext) {
        return ext !== '' ? extname(basename(file, ext)) : extname(file);
    }
    function decode(path) {
        try {
            return decodeURIComponent(path);
        } catch (err) {
            return -1;
        }
    }
}
,
"05993fde":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    class LRU {
        constructor(max){
            this.max = max;
            this.size = 0;
            this.cache = new Map();
            this._cache = new Map();
        }
        get(key, options) {
            let item = this.cache.get(key);
            const maxAge = options && options.maxAge;
            let now;
            function getNow() {
                now = now || Date.now();
                return now;
            }
            if (item) {
                if (item.expired && getNow() > item.expired) {
                    item.expired = 0;
                    item.value = undefined;
                } else {
                    if (maxAge !== undefined) {
                        const expired = maxAge ? getNow() + maxAge : 0;
                        item.expired = expired;
                    }
                }
                return item.value;
            }
            item = this._cache.get(key);
            if (item) {
                if (item.expired && getNow() > item.expired) {
                    item.expired = 0;
                    item.value = undefined;
                } else {
                    this._update(key, item);
                    if (maxAge !== undefined) {
                        const expired = maxAge ? getNow() + maxAge : 0;
                        item.expired = expired;
                    }
                }
                return item.value;
            }
        }
        set(key, value, options) {
            const maxAge = options && options.maxAge;
            const expired = maxAge ? Date.now() + maxAge : 0;
            let item = this.cache.get(key);
            if (item) {
                item.expired = expired;
                item.value = value;
            } else {
                item = {
                    value,
                    expired
                };
                this._update(key, item);
            }
        }
        keys() {
            const cacheKeys = new Set();
            const now = Date.now();
            for (const entry of this.cache.entries()){
                checkEntry(entry);
            }
            for (const entry of this._cache.entries()){
                checkEntry(entry);
            }
            function checkEntry(entry) {
                const key = entry[0];
                const item = entry[1];
                if (entry[1].value && !entry[1].expired || item.expired >= now) {
                    cacheKeys.add(key);
                }
            }
            return Array.from(cacheKeys.keys());
        }
        _update(key, item) {
            this.cache.set(key, item);
            this.size++;
            if (this.size >= this.max) {
                this.size = 0;
                this._cache = this.cache;
                this.cache = new Map();
            }
        }
    }
    module.exports = LRU;
}
,
"05a93efb":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const u = farmRequire("712c2dd4", true).fromPromise;
    const fs = farmRequire("f2e2163e", true);
    function pathExists(path) {
        return fs.access(path).then(()=>true).catch(()=>false);
    }
    module.exports = {
        pathExists: u(pathExists),
        pathExistsSync: fs.existsSync
    };
}
,
"05c5e7d0":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const events_1 = global.nodeRequire("events", true);
    const fsScandir = farmRequire("001be097", true);
    const fastq = farmRequire("bb66ff9f", true);
    const common = farmRequire("625d23a2", true);
    const reader_1 = farmRequire("3f56675d", true);
    class AsyncReader extends reader_1.default {
        constructor(_root, _settings){
            super(_root, _settings);
            this._settings = _settings;
            this._scandir = fsScandir.scandir;
            this._emitter = new events_1.EventEmitter();
            this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
            this._isFatalError = false;
            this._isDestroyed = false;
            this._queue.drain = ()=>{
                if (!this._isFatalError) {
                    this._emitter.emit('end');
                }
            };
        }
        read() {
            this._isFatalError = false;
            this._isDestroyed = false;
            setImmediate(()=>{
                this._pushToQueue(this._root, this._settings.basePath);
            });
            return this._emitter;
        }
        get isDestroyed() {
            return this._isDestroyed;
        }
        destroy() {
            if (this._isDestroyed) {
                throw new Error('The reader is already destroyed');
            }
            this._isDestroyed = true;
            this._queue.killAndDrain();
        }
        onEntry(callback) {
            this._emitter.on('entry', callback);
        }
        onError(callback) {
            this._emitter.once('error', callback);
        }
        onEnd(callback) {
            this._emitter.once('end', callback);
        }
        _pushToQueue(directory, base) {
            const queueItem = {
                directory,
                base
            };
            this._queue.push(queueItem, (error)=>{
                if (error !== null) {
                    this._handleError(error);
                }
            });
        }
        _worker(item, done) {
            this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries)=>{
                if (error !== null) {
                    done(error, undefined);
                    return;
                }
                for (const entry of entries){
                    this._handleEntry(entry, item.base);
                }
                done(null, undefined);
            });
        }
        _handleError(error) {
            if (this._isDestroyed || !common.isFatalError(this._settings, error)) {
                return;
            }
            this._isFatalError = true;
            this._isDestroyed = true;
            this._emitter.emit('error', error);
        }
        _handleEntry(entry, base) {
            if (this._isDestroyed || this._isFatalError) {
                return;
            }
            const fullpath = entry.path;
            if (base !== undefined) {
                entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
            }
            if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
                this._emitEntry(entry);
            }
            if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
                this._pushToQueue(fullpath, base === undefined ? undefined : entry.path);
            }
        }
        _emitEntry(entry) {
            this._emitter.emit('entry', entry);
        }
    }
    exports.default = AsyncReader;
}
,
"0630d65a":function  (module, exports, farmRequire, farmDynamicRequire) {
    const errors = farmRequire("48aa4d88", true);
    const zlib = global.nodeRequire('zlib', true);
    class Encodings {
        constructor(options = {}){
            this.wildcardAcceptEncoding = options.wildcardAcceptEncoding || Encodings.wildcardAcceptEncoding;
            this.preferredEncodings = options.preferredEncodings || Encodings.preferredEncodings;
            this.reDirective = options.reDirective || Encodings.reDirective;
            this.encodingWeights = new Map();
        }
        parseAcceptEncoding(acceptEncoding = '*') {
            const { encodingWeights, reDirective } = this;
            acceptEncoding.split(',').forEach((directive)=>{
                const match = reDirective.exec(directive);
                if (!match) return;
                const encoding = match[1];
                let weight = match[2] && !isNaN(match[2]) ? parseFloat(match[2], 10) : 1;
                weight = Math.max(weight, 0);
                weight = Math.min(weight, 1);
                if (encoding === '*') {
                    this.wildcardAcceptEncoding.forEach((enc)=>{
                        if (!encodingWeights.has(enc)) encodingWeights.set(enc, weight);
                    });
                    return;
                }
                encodingWeights.set(encoding, weight);
            });
        }
        getPreferredContentEncoding() {
            const { encodingWeights, preferredEncodings } = this;
            const acceptedEncodings = Array.from(encodingWeights.keys()).sort((a, b)=>encodingWeights.get(b) - encodingWeights.get(a)).filter((encoding)=>encoding === 'identity' || typeof Encodings.encodingMethods[encoding] === 'function');
            const weightClasses = new Map();
            acceptedEncodings.forEach((encoding)=>{
                const weight = encodingWeights.get(encoding);
                if (!weightClasses.has(weight)) weightClasses.set(weight, new Set());
                weightClasses.get(weight).add(encoding);
            });
            const weights = Array.from(weightClasses.keys()).sort((a, b)=>b - a);
            for(let i = 0; i < weights.length; i++){
                const encodings = weightClasses.get(weights[i]);
                for(let j = 0; j < preferredEncodings.length; j++){
                    const preferredEncoding = preferredEncodings[j];
                    if (encodings.has(preferredEncoding)) return preferredEncoding;
                }
            }
            if (encodingWeights.get('identity') === 0) throw errors(406, 'Please accept br, gzip, deflate, or identity.');
            return 'identity';
        }
    }
    Encodings.encodingMethods = {
        gzip: zlib.createGzip,
        deflate: zlib.createDeflate,
        br: zlib.createBrotliCompress
    };
    Encodings.encodingMethodDefaultOptions = {
        gzip: {},
        deflate: {},
        br: {
            params: {
                [zlib.constants.BROTLI_PARAM_QUALITY]: 4
            }
        }
    };
    Encodings.wildcardAcceptEncoding = [
        'gzip',
        'deflate'
    ];
    Encodings.preferredEncodings = [
        'br',
        'gzip',
        'deflate'
    ];
    Encodings.reDirective = /^\s*(gzip|compress|deflate|br|identity|\*)\s*(?:;\s*q\s*=\s*(\d(?:\.\d)?))?\s*$/;
    module.exports = Encodings;
}
,
"0d0a2382":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "npmRunPath", ()=>npmRunPath);
    module.o(exports, "npmRunPathEnv", ()=>npmRunPathEnv);
    var _f_node_process = module.i(farmRequire('node:process'));
    var _f_node_path = module.i(farmRequire('node:path'));
    var _f_node_url = module.i(farmRequire('node:url'));
    var _f_path_key = module.i(farmRequire("e82dd834"));
    function npmRunPath(options = {}) {
        const { cwd = module.f(_f_node_process).cwd(), path: path_ = module.f(_f_node_process).env[module.f(_f_path_key)()], execPath = module.f(_f_node_process).execPath } = options;
        let previous;
        const cwdString = cwd instanceof URL ? module.f(_f_node_url).fileURLToPath(cwd) : cwd;
        let cwdPath = module.f(_f_node_path).resolve(cwdString);
        const result = [];
        while(previous !== cwdPath){
            result.push(module.f(_f_node_path).join(cwdPath, 'node_modules/.bin'));
            previous = cwdPath;
            cwdPath = module.f(_f_node_path).resolve(cwdPath, '..');
        }
        result.push(module.f(_f_node_path).resolve(cwdString, execPath, '..'));
        return [
            ...result,
            path_
        ].join(module.f(_f_node_path).delimiter);
    }
    function npmRunPathEnv({ env = module.f(_f_node_process).env, ...options } = {}) {
        env = {
            ...env
        };
        const path = module.f(_f_path_key)({
            env
        });
        options.path = env[path];
        env[path] = npmRunPath(options);
        return env;
    }
}
,
"0d2d0a9a":function  (module, exports, farmRequire, farmDynamicRequire) {
    var url = global.nodeRequire('url', true), common = farmRequire("eac2581d", true);
    var redirectRegex = /^201|30(1|2|7|8)$/;
    /*!
 * Array of passes.
 *
 * A `pass` is just a function that is executed on `req, res, options`
 * so that you can easily add new checks while still keeping the base
 * flexible.
 */ module.exports = {
        removeChunked: function removeChunked(req, res, proxyRes) {
            if (req.httpVersion === '1.0') {
                delete proxyRes.headers['transfer-encoding'];
            }
        },
        setConnection: function setConnection(req, res, proxyRes) {
            if (req.httpVersion === '1.0') {
                proxyRes.headers.connection = req.headers.connection || 'close';
            } else if (req.httpVersion !== '2.0' && !proxyRes.headers.connection) {
                proxyRes.headers.connection = req.headers.connection || 'keep-alive';
            }
        },
        setRedirectHostRewrite: function setRedirectHostRewrite(req, res, proxyRes, options) {
            if ((options.hostRewrite || options.autoRewrite || options.protocolRewrite) && proxyRes.headers['location'] && redirectRegex.test(proxyRes.statusCode)) {
                var target = url.parse(options.target);
                var u = url.parse(proxyRes.headers['location']);
                if (target.host != u.host) {
                    return;
                }
                if (options.hostRewrite) {
                    u.host = options.hostRewrite;
                } else if (options.autoRewrite) {
                    u.host = req.headers['host'];
                }
                if (options.protocolRewrite) {
                    u.protocol = options.protocolRewrite;
                }
                proxyRes.headers['location'] = u.format();
            }
        },
        writeHeaders: function writeHeaders(req, res, proxyRes, options) {
            var rewriteCookieDomainConfig = options.cookieDomainRewrite, rewriteCookiePathConfig = options.cookiePathRewrite, preserveHeaderKeyCase = options.preserveHeaderKeyCase, rawHeaderKeyMap, setHeader = function(key, header) {
                if (header == undefined) return;
                if (rewriteCookieDomainConfig && key.toLowerCase() === 'set-cookie') {
                    header = common.rewriteCookieProperty(header, rewriteCookieDomainConfig, 'domain');
                }
                if (rewriteCookiePathConfig && key.toLowerCase() === 'set-cookie') {
                    header = common.rewriteCookieProperty(header, rewriteCookiePathConfig, 'path');
                }
                res.setHeader(String(key).trim(), header);
            };
            if (typeof rewriteCookieDomainConfig === 'string') {
                rewriteCookieDomainConfig = {
                    '*': rewriteCookieDomainConfig
                };
            }
            if (typeof rewriteCookiePathConfig === 'string') {
                rewriteCookiePathConfig = {
                    '*': rewriteCookiePathConfig
                };
            }
            if (preserveHeaderKeyCase && proxyRes.rawHeaders != undefined) {
                rawHeaderKeyMap = {};
                for(var i = 0; i < proxyRes.rawHeaders.length; i += 2){
                    var key = proxyRes.rawHeaders[i];
                    rawHeaderKeyMap[key.toLowerCase()] = key;
                }
            }
            Object.keys(proxyRes.headers).forEach(function(key) {
                var header = proxyRes.headers[key];
                if (preserveHeaderKeyCase && rawHeaderKeyMap) {
                    key = rawHeaderKeyMap[key] || key;
                }
                setHeader(key, header);
            });
        },
        writeStatusCode: function writeStatusCode(req, res, proxyRes) {
            if (proxyRes.statusMessage) {
                res.statusCode = proxyRes.statusCode;
                res.statusMessage = proxyRes.statusMessage;
            } else {
                res.statusCode = proxyRes.statusCode;
            }
        }
    };
}
,
"0d38b53d":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "ValidationError", ()=>ValidationError);
    module.o(exports, "fromZodError", ()=>fromZodError);
    var _f_joinPath = farmRequire("357260bd");
    var _f_NonEmptyArray = farmRequire("00193f2e");
    const MAX_ISSUES_IN_MESSAGE = 99;
    const ISSUE_SEPARATOR = '; ';
    const UNION_SEPARATOR = ', or ';
    const PREFIX = 'Validation error';
    const PREFIX_SEPARATOR = ': ';
    class ValidationError extends Error {
        details;
        name;
        constructor(message, details = []){
            super(message);
            this.details = details;
            this.name = 'ZodValidationError';
        }
        toString() {
            return this.message;
        }
    }
    function getMessageFromZodIssue(issue, issueSeparator, unionSeparator) {
        if (issue.code === 'invalid_union') {
            return issue.unionErrors.reduce((acc, zodError)=>{
                const newIssues = zodError.issues.map((issue)=>getMessageFromZodIssue(issue, issueSeparator, unionSeparator)).join(issueSeparator);
                if (!acc.includes(newIssues)) {
                    acc.push(newIssues);
                }
                return acc;
            }, []).join(unionSeparator);
        }
        if (_f_NonEmptyArray.isNonEmptyArray(issue.path)) {
            if (issue.path.length === 1) {
                const identifier = issue.path[0];
                if (typeof identifier === 'number') {
                    return `${issue.message} at index ${identifier}`;
                }
            }
            return `${issue.message} at "${_f_joinPath.joinPath(issue.path)}"`;
        }
        return issue.message;
    }
    function conditionallyPrefixMessage(reason, prefix, prefixSeparator) {
        if (prefix !== null) {
            if (reason.length > 0) {
                return [
                    prefix,
                    reason
                ].join(prefixSeparator);
            }
            return prefix;
        }
        if (reason.length > 0) {
            return reason;
        }
        return PREFIX;
    }
    function fromZodError(zodError, options = {}) {
        const { maxIssuesInMessage = MAX_ISSUES_IN_MESSAGE, issueSeparator = ISSUE_SEPARATOR, unionSeparator = UNION_SEPARATOR, prefixSeparator = PREFIX_SEPARATOR, prefix = PREFIX } = options;
        const reason = zodError.errors.slice(0, maxIssuesInMessage).map((issue)=>getMessageFromZodIssue(issue, issueSeparator, unionSeparator)).join(issueSeparator);
        const message = conditionallyPrefixMessage(reason, prefix, prefixSeparator);
        return new ValidationError(message, zodError.errors);
    }
}
,
"0d467a9b":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "cors", ()=>cors);
    var _f_cors = farmRequire("4cd3082d");
    function cors(devSeverContext) {
        const { config } = devSeverContext;
        if (!config.cors) return;
        return _f_cors.default(typeof config.cors === 'boolean' ? {} : config.cors);
    }
}
,
"0da0eee3":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.responseInterceptor = void 0;
    const zlib = global.nodeRequire("zlib", true);
    const debug_1 = farmRequire("2f90b0a5", true);
    const function_1 = farmRequire("f8468536", true);
    const debug = debug_1.Debug.extend('response-interceptor');
    function responseInterceptor(interceptor) {
        return async function proxyResResponseInterceptor(proxyRes, req, res) {
            debug('intercept proxy response');
            const originalProxyRes = proxyRes;
            let buffer = Buffer.from('', 'utf8');
            const _proxyRes = decompress(proxyRes, proxyRes.headers['content-encoding']);
            _proxyRes.on('data', (chunk)=>buffer = Buffer.concat([
                    buffer,
                    chunk
                ]));
            _proxyRes.on('end', async ()=>{
                copyHeaders(proxyRes, res);
                debug('call interceptor function: %s', (0, function_1.getFunctionName)(interceptor));
                const interceptedBuffer = Buffer.from(await interceptor(buffer, originalProxyRes, req, res));
                debug('set content-length: %s', Buffer.byteLength(interceptedBuffer, 'utf8'));
                res.setHeader('content-length', Buffer.byteLength(interceptedBuffer, 'utf8'));
                debug('write intercepted response');
                res.write(interceptedBuffer);
                res.end();
            });
            _proxyRes.on('error', (error)=>{
                res.end(`Error fetching proxied request: ${error.message}`);
            });
        };
    }
    exports.responseInterceptor = responseInterceptor;
    function decompress(proxyRes, contentEncoding) {
        let _proxyRes = proxyRes;
        let decompress;
        switch(contentEncoding){
            case 'gzip':
                decompress = zlib.createGunzip();
                break;
            case 'br':
                decompress = zlib.createBrotliDecompress();
                break;
            case 'deflate':
                decompress = zlib.createInflate();
                break;
            default:
                break;
        }
        if (decompress) {
            debug(`decompress proxy response with 'content-encoding': %s`, contentEncoding);
            _proxyRes.pipe(decompress);
            _proxyRes = decompress;
        }
        return _proxyRes;
    }
    function copyHeaders(originalResponse, response) {
        debug('copy original response headers');
        response.statusCode = originalResponse.statusCode;
        response.statusMessage = originalResponse.statusMessage;
        if (response.setHeader) {
            let keys = Object.keys(originalResponse.headers);
            keys = keys.filter((key)=>![
                    'content-encoding',
                    'transfer-encoding'
                ].includes(key));
            keys.forEach((key)=>{
                let value = originalResponse.headers[key];
                if (key === 'set-cookie') {
                    value = Array.isArray(value) ? value : [
                        value
                    ];
                    value = value.map((x)=>x.replace(/Domain=[^;]+?/i, ''));
                }
                response.setHeader(key, value);
            });
        } else {
            response.headers = originalResponse.headers;
        }
    }
}
,
"0da219b5":/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    module.exports = function isExtglob(str) {
        if (typeof str !== 'string' || str === '') {
            return false;
        }
        var match;
        while(match = /(\\).|([@?!+*]\(.*\))/g.exec(str)){
            if (match[2]) return true;
            str = str.slice(match.index + match[0].length);
        }
        return false;
    };
}
,
"0db3db94":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    var _f_mimic_fn = module.i(farmRequire("19589191"));
    const calledFunctions = new WeakMap();
    const onetime = (function_, options = {})=>{
        if (typeof function_ !== 'function') {
            throw new TypeError('Expected a function');
        }
        let returnValue;
        let callCount = 0;
        const functionName = function_.displayName || function_.name || '<anonymous>';
        const onetime = function(...arguments_) {
            calledFunctions.set(onetime, ++callCount);
            if (callCount === 1) {
                returnValue = function_.apply(this, arguments_);
                function_ = null;
            } else if (options.throw === true) {
                throw new Error(`Function \`${functionName}\` can only be called once`);
            }
            return returnValue;
        };
        module.f(_f_mimic_fn)(onetime, function_);
        calledFunctions.set(onetime, callCount);
        return onetime;
    };
    onetime.callCount = (function_)=>{
        if (!calledFunctions.has(function_)) {
            throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
        }
        return calledFunctions.get(function_);
    };
    exports.default = onetime;
}
,
"0de2fb33":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const util = global.nodeRequire('util', true);
    const braces = farmRequire("1e432c39", true);
    const picomatch = farmRequire("146f3673", true);
    const utils = farmRequire("48dceba4", true);
    const isEmptyString = (val)=>val === '' || val === './';
    const micromatch = (list, patterns, options)=>{
        patterns = [].concat(patterns);
        list = [].concat(list);
        let omit = new Set();
        let keep = new Set();
        let items = new Set();
        let negatives = 0;
        let onResult = (state)=>{
            items.add(state.output);
            if (options && options.onResult) {
                options.onResult(state);
            }
        };
        for(let i = 0; i < patterns.length; i++){
            let isMatch = picomatch(String(patterns[i]), {
                ...options,
                onResult
            }, true);
            let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
            if (negated) negatives++;
            for (let item of list){
                let matched = isMatch(item, true);
                let match = negated ? !matched.isMatch : matched.isMatch;
                if (!match) continue;
                if (negated) {
                    omit.add(matched.output);
                } else {
                    omit.delete(matched.output);
                    keep.add(matched.output);
                }
            }
        }
        let result = negatives === patterns.length ? [
            ...items
        ] : [
            ...keep
        ];
        let matches = result.filter((item)=>!omit.has(item));
        if (options && matches.length === 0) {
            if (options.failglob === true) {
                throw new Error(`No matches found for "${patterns.join(', ')}"`);
            }
            if (options.nonull === true || options.nullglob === true) {
                return options.unescape ? patterns.map((p)=>p.replace(/\\/g, '')) : patterns;
            }
        }
        return matches;
    };
    micromatch.match = micromatch;
    micromatch.matcher = (pattern, options)=>picomatch(pattern, options);
    micromatch.isMatch = (str, patterns, options)=>picomatch(patterns, options)(str);
    micromatch.any = micromatch.isMatch;
    micromatch.not = (list, patterns, options = {})=>{
        patterns = [].concat(patterns).map(String);
        let result = new Set();
        let items = [];
        let onResult = (state)=>{
            if (options.onResult) options.onResult(state);
            items.push(state.output);
        };
        let matches = new Set(micromatch(list, patterns, {
            ...options,
            onResult
        }));
        for (let item of items){
            if (!matches.has(item)) {
                result.add(item);
            }
        }
        return [
            ...result
        ];
    };
    micromatch.contains = (str, pattern, options)=>{
        if (typeof str !== 'string') {
            throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
        }
        if (Array.isArray(pattern)) {
            return pattern.some((p)=>micromatch.contains(str, p, options));
        }
        if (typeof pattern === 'string') {
            if (isEmptyString(str) || isEmptyString(pattern)) {
                return false;
            }
            if (str.includes(pattern) || str.startsWith('./') && str.slice(2).includes(pattern)) {
                return true;
            }
        }
        return micromatch.isMatch(str, pattern, {
            ...options,
            contains: true
        });
    };
    micromatch.matchKeys = (obj, patterns, options)=>{
        if (!utils.isObject(obj)) {
            throw new TypeError('Expected the first argument to be an object');
        }
        let keys = micromatch(Object.keys(obj), patterns, options);
        let res = {};
        for (let key of keys)res[key] = obj[key];
        return res;
    };
    micromatch.some = (list, patterns, options)=>{
        let items = [].concat(list);
        for (let pattern of [].concat(patterns)){
            let isMatch = picomatch(String(pattern), options);
            if (items.some((item)=>isMatch(item))) {
                return true;
            }
        }
        return false;
    };
    micromatch.every = (list, patterns, options)=>{
        let items = [].concat(list);
        for (let pattern of [].concat(patterns)){
            let isMatch = picomatch(String(pattern), options);
            if (!items.every((item)=>isMatch(item))) {
                return false;
            }
        }
        return true;
    };
    micromatch.all = (str, patterns, options)=>{
        if (typeof str !== 'string') {
            throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
        }
        return [].concat(patterns).every((p)=>picomatch(p, options)(str));
    };
    micromatch.capture = (glob, input, options)=>{
        let posix = utils.isWindows(options);
        let regex = picomatch.makeRe(String(glob), {
            ...options,
            capture: true
        });
        let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);
        if (match) {
            return match.slice(1).map((v)=>v === void 0 ? '' : v);
        }
    };
    micromatch.makeRe = (...args)=>picomatch.makeRe(...args);
    micromatch.scan = (...args)=>picomatch.scan(...args);
    micromatch.parse = (patterns, options)=>{
        let res = [];
        for (let pattern of [].concat(patterns || [])){
            for (let str of braces(String(pattern), options)){
                res.push(picomatch.parse(str, options));
            }
        }
        return res;
    };
    micromatch.braces = (pattern, options)=>{
        if (typeof pattern !== 'string') throw new TypeError('Expected a string');
        if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
            return [
                pattern
            ];
        }
        return braces(pattern, options);
    };
    micromatch.braceExpand = (pattern, options)=>{
        if (typeof pattern !== 'string') throw new TypeError('Expected a string');
        return micromatch.braces(pattern, {
            ...options,
            expand: true
        });
    };
    module.exports = micromatch;
}
,
"0e4db454":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.verifyConfig = void 0;
    const errors_1 = farmRequire("12559428", true);
    function verifyConfig(options) {
        if (!options.target && !options.router) {
            throw new Error(errors_1.ERRORS.ERR_CONFIG_FACTORY_TARGET_MISSING);
        }
    }
    exports.verifyConfig = verifyConfig;
}
,
"0f80e9b2":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.getSignals = void 0;
    var _os = global.nodeRequire("os", true);
    var _core = farmRequire("2ae89d77", true);
    var _realtime = farmRequire("54541ffb", true);
    const getSignals = function() {
        const realtimeSignals = (0, _realtime.getRealtimeSignals)();
        const signals = [
            ..._core.SIGNALS,
            ...realtimeSignals
        ].map(normalizeSignal);
        return signals;
    };
    exports.getSignals = getSignals;
    const normalizeSignal = function({ name, number: defaultNumber, description, action, forced = false, standard }) {
        const { signals: { [name]: constantSignal } } = _os.constants;
        const supported = constantSignal !== undefined;
        const number = supported ? constantSignal : defaultNumber;
        return {
            name,
            number,
            description,
            supported,
            action,
            forced,
            standard
        };
    };
}
,
"11116ee2":/*!
 * parseurl
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    var url = global.nodeRequire('url', true);
    var parse = url.parse;
    var Url = url.Url;
    module.exports = parseurl;
    module.exports.original = originalurl;
    function parseurl(req) {
        var url = req.url;
        if (url === undefined) {
            return undefined;
        }
        var parsed = req._parsedUrl;
        if (fresh(url, parsed)) {
            return parsed;
        }
        parsed = fastparse(url);
        parsed._raw = url;
        return req._parsedUrl = parsed;
    }
    ;
    function originalurl(req) {
        var url = req.originalUrl;
        if (typeof url !== 'string') {
            return parseurl(req);
        }
        var parsed = req._parsedOriginalUrl;
        if (fresh(url, parsed)) {
            return parsed;
        }
        parsed = fastparse(url);
        parsed._raw = url;
        return req._parsedOriginalUrl = parsed;
    }
    ;
    function fastparse(str) {
        if (typeof str !== 'string' || str.charCodeAt(0) !== 0x2f) {
            return parse(str);
        }
        var pathname = str;
        var query = null;
        var search = null;
        for(var i = 1; i < str.length; i++){
            switch(str.charCodeAt(i)){
                case 0x3f:
                    if (search === null) {
                        pathname = str.substring(0, i);
                        query = str.substring(i + 1);
                        search = str.substring(i);
                    }
                    break;
                case 0x09:
                case 0x0a:
                case 0x0c:
                case 0x0d:
                case 0x20:
                case 0x23:
                case 0xa0:
                case 0xfeff:
                    return parse(str);
            }
        }
        var url = Url !== undefined ? new Url() : {};
        url.path = str;
        url.href = str;
        url.pathname = pathname;
        if (search !== null) {
            url.query = query;
            url.search = search;
        }
        return url;
    }
    function fresh(url, parsedUrl) {
        return typeof parsedUrl === 'object' && parsedUrl !== null && (Url === undefined || parsedUrl instanceof Url) && parsedUrl._raw === url;
    }
}
,
"115e919a":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "getDynamicResources", ()=>getDynamicResources);
    function getDynamicResources(dynamicResourcesMap) {
        let dynamicResources = null;
        let dynamicModuleResourcesMap = null;
        let visitedMap = new Map();
        if (dynamicResourcesMap) {
            dynamicResources = [];
            dynamicModuleResourcesMap = {};
            for (const [key, value] of Object.entries(dynamicResourcesMap)){
                for (const r of value){
                    const visitedKey = r[0] + '.' + r[1];
                    if (visitedMap.has(visitedKey)) {
                        dynamicModuleResourcesMap[key] ??= [];
                        dynamicModuleResourcesMap[key].push(visitedMap.get(visitedKey));
                        continue;
                    }
                    dynamicResources.push({
                        path: r[0],
                        type: r[1] === 'script' ? 0 : 1
                    });
                    dynamicModuleResourcesMap[key] ??= [];
                    dynamicModuleResourcesMap[key].push(dynamicResources.length - 1);
                    visitedMap.set(visitedKey, dynamicResources.length - 1);
                }
            }
        }
        return {
            dynamicResources,
            dynamicModuleResourcesMap
        };
    }
}
,
"12559428":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.ERRORS = void 0;
    var ERRORS;
    (function(ERRORS) {
        ERRORS["ERR_CONFIG_FACTORY_TARGET_MISSING"] = "[HPM] Missing \"target\" option. Example: {target: \"http://www.example.org\"}";
        ERRORS["ERR_CONTEXT_MATCHER_GENERIC"] = "[HPM] Invalid context. Expecting something like: \"/api\" or [\"/api\", \"/ajax\"]";
        ERRORS["ERR_CONTEXT_MATCHER_INVALID_ARRAY"] = "[HPM] Invalid pathFilter. Expecting something like: [\"/api\", \"/ajax\"] or [\"/api/**\", \"!**.html\"]";
        ERRORS["ERR_PATH_REWRITER_CONFIG"] = "[HPM] Invalid pathRewrite config. Expecting object with pathRewrite config or a rewrite function";
    })(ERRORS || (exports.ERRORS = ERRORS = {}));
}
,
"1464d5a7":function  (module, exports, farmRequire, farmDynamicRequire) {
    let _fs;
    try {
        _fs = farmRequire("ffc819a8", true);
    } catch (_) {
        _fs = global.nodeRequire('fs', true);
    }
    const universalify = farmRequire("712c2dd4", true);
    const { stringify, stripBom } = farmRequire("22ca6445", true);
    async function _readFile(file, options = {}) {
        if (typeof options === 'string') {
            options = {
                encoding: options
            };
        }
        const fs = options.fs || _fs;
        const shouldThrow = 'throws' in options ? options.throws : true;
        let data = await universalify.fromCallback(fs.readFile)(file, options);
        data = stripBom(data);
        let obj;
        try {
            obj = JSON.parse(data, options ? options.reviver : null);
        } catch (err) {
            if (shouldThrow) {
                err.message = `${file}: ${err.message}`;
                throw err;
            } else {
                return null;
            }
        }
        return obj;
    }
    const readFile = universalify.fromPromise(_readFile);
    function readFileSync(file, options = {}) {
        if (typeof options === 'string') {
            options = {
                encoding: options
            };
        }
        const fs = options.fs || _fs;
        const shouldThrow = 'throws' in options ? options.throws : true;
        try {
            let content = fs.readFileSync(file, options);
            content = stripBom(content);
            return JSON.parse(content, options.reviver);
        } catch (err) {
            if (shouldThrow) {
                err.message = `${file}: ${err.message}`;
                throw err;
            } else {
                return null;
            }
        }
    }
    async function _writeFile(file, obj, options = {}) {
        const fs = options.fs || _fs;
        const str = stringify(obj, options);
        await universalify.fromCallback(fs.writeFile)(file, str, options);
    }
    const writeFile = universalify.fromPromise(_writeFile);
    function writeFileSync(file, obj, options = {}) {
        const fs = options.fs || _fs;
        const str = stringify(obj, options);
        return fs.writeFileSync(file, str, options);
    }
    const jsonfile = {
        readFile,
        readFileSync,
        writeFile,
        writeFileSync
    };
    module.exports = jsonfile;
}
,
"146f3673":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    module.exports = farmRequire("1eccf3e8", true);
}
,
"14cbc7d0":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "default", ()=>stripFinalNewline);
    function stripFinalNewline(input) {
        const LF = typeof input === 'string' ? '\n' : '\n'.charCodeAt();
        const CR = typeof input === 'string' ? '\r' : '\r'.charCodeAt();
        if (input[input.length - 1] === LF) {
            input = input.slice(0, -1);
        }
        if (input[input.length - 1] === CR) {
            input = input.slice(0, -1);
        }
        return input;
    }
}
,
"14fd5962":function  (module, exports, farmRequire, farmDynamicRequire) {
    var fs = global.nodeRequire('fs', true);
    var core;
    if (process.platform === 'win32' || global.TESTING_WINDOWS) {
        core = farmRequire("49576d3a", true);
    } else {
        core = farmRequire("c9805378", true);
    }
    module.exports = isexe;
    isexe.sync = sync;
    function isexe(path, options, cb) {
        if (typeof options === 'function') {
            cb = options;
            options = {};
        }
        if (!cb) {
            if (typeof Promise !== 'function') {
                throw new TypeError('callback not provided');
            }
            return new Promise(function(resolve, reject) {
                isexe(path, options || {}, function(er, is) {
                    if (er) {
                        reject(er);
                    } else {
                        resolve(is);
                    }
                });
            });
        }
        core(path, options || {}, function(er, is) {
            if (er) {
                if (er.code === 'EACCES' || options && options.ignoreErrors) {
                    er = null;
                    is = false;
                }
            }
            cb(er, is);
        });
    }
    function sync(path, options) {
        try {
            return core.sync(path, options || {});
        } catch (er) {
            if (options && options.ignoreErrors || er.code === 'EACCES') {
                return false;
            } else {
                throw er;
            }
        }
    }
}
,
"1514df7a":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const fs = farmRequire("ffc819a8", true);
    const path = global.nodeRequire('path', true);
    const copy = farmRequire("d1ce3aa3", true).copy;
    const remove = farmRequire("4ffdf2a8", true).remove;
    const mkdirp = farmRequire("abdb8a71", true).mkdirp;
    const pathExists = farmRequire("05a93efb", true).pathExists;
    const stat = farmRequire("9c9fbd11", true);
    function move(src, dest, opts, cb) {
        if (typeof opts === 'function') {
            cb = opts;
            opts = {};
        }
        opts = opts || {};
        const overwrite = opts.overwrite || opts.clobber || false;
        stat.checkPaths(src, dest, 'move', opts, (err, stats)=>{
            if (err) return cb(err);
            const { srcStat, isChangingCase = false } = stats;
            stat.checkParentPaths(src, srcStat, dest, 'move', (err)=>{
                if (err) return cb(err);
                if (isParentRoot(dest)) return doRename(src, dest, overwrite, isChangingCase, cb);
                mkdirp(path.dirname(dest), (err)=>{
                    if (err) return cb(err);
                    return doRename(src, dest, overwrite, isChangingCase, cb);
                });
            });
        });
    }
    function isParentRoot(dest) {
        const parent = path.dirname(dest);
        const parsedPath = path.parse(parent);
        return parsedPath.root === parent;
    }
    function doRename(src, dest, overwrite, isChangingCase, cb) {
        if (isChangingCase) return rename(src, dest, overwrite, cb);
        if (overwrite) {
            return remove(dest, (err)=>{
                if (err) return cb(err);
                return rename(src, dest, overwrite, cb);
            });
        }
        pathExists(dest, (err, destExists)=>{
            if (err) return cb(err);
            if (destExists) return cb(new Error('dest already exists.'));
            return rename(src, dest, overwrite, cb);
        });
    }
    function rename(src, dest, overwrite, cb) {
        fs.rename(src, dest, (err)=>{
            if (!err) return cb();
            if (err.code !== 'EXDEV') return cb(err);
            return moveAcrossDevice(src, dest, overwrite, cb);
        });
    }
    function moveAcrossDevice(src, dest, overwrite, cb) {
        const opts = {
            overwrite,
            errorOnExist: true,
            preserveTimestamps: true
        };
        copy(src, dest, opts, (err)=>{
            if (err) return cb(err);
            return remove(src, cb);
        });
    }
    module.exports = move;
}
,
"1594525d":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "Compiler", ()=>Compiler);
    module.o(exports, "bindingPath", ()=>module.f(_f_resolve_binding));
    var _f_binding = module.i(farmRequire("23b38875"));
    var _f_resolve_binding = module.i(farmRequire("830b3dc6"));
    process.env.FARM_LIB_CORE_PATH = module.f(_f_resolve_binding);
    const Compiler = module.f(_f_binding).Compiler;
}
,
"16544049":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "traceDependencies", ()=>traceDependencies);
    var _f_index = farmRequire("bf50199b");
    var _f_error = farmRequire("eedce71a");
    var _f_node_fs = module.w(farmRequire('node:fs'));
    var fs = _f_node_fs;
    function createTraceDepCompiler(entry, logger) {
        const config = getDefaultTraceDepCompilerConfig(entry);
        config.config.progress = false;
        return new _f_index.Compiler(config, logger);
    }
    async function traceDependencies(configFilePath, logger) {
        try {
            if (!(fs.existsSync(configFilePath) && fs.statSync(configFilePath).isFile())) {
                return [];
            }
            const compiler = createTraceDepCompiler(configFilePath, logger);
            const files = await compiler.traceDependencies();
            return files;
        } catch (error) {
            const errorMessage = _f_error.convertErrorMessage(error);
            throw Error(`Error tracing dependencies: ${errorMessage}`);
        }
    }
    function getDefaultTraceDepCompilerConfig(entry) {
        return {
            config: {
                input: {
                    index: entry
                },
                resolve: {
                    autoExternalFailedResolve: true
                },
                external: [
                    '^[^./].*'
                ],
                sourcemap: false,
                presetEnv: false,
                persistentCache: false,
                minify: false,
                lazyCompilation: false
            },
            jsPlugins: [
                {
                    name: 'trace-dependencies-ignore-node-file-plugin',
                    load: {
                        filters: {
                            resolvedPaths: [
                                '\\.node$'
                            ]
                        },
                        executor: ()=>{
                            return {
                                content: '',
                                moduleType: 'js'
                            };
                        }
                    }
                }
            ],
            rustPlugins: []
        };
    }
}
,
"16fd7f8c":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    module.exports = function hasSymbols() {
        if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
            return false;
        }
        if (typeof Symbol.iterator === 'symbol') {
            return true;
        }
        var obj = {};
        var sym = Symbol('test');
        var symObj = Object(sym);
        if (typeof sym === 'string') {
            return false;
        }
        if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
            return false;
        }
        if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
            return false;
        }
        var symVal = 42;
        obj[sym] = symVal;
        for(sym in obj){
            return false;
        }
        if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
            return false;
        }
        if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
            return false;
        }
        var syms = Object.getOwnPropertySymbols(obj);
        if (syms.length !== 1 || syms[0] !== sym) {
            return false;
        }
        if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
            return false;
        }
        if (typeof Object.getOwnPropertyDescriptor === 'function') {
            var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
            if (descriptor.value !== symVal || descriptor.enumerable !== true) {
                return false;
            }
        }
        return true;
    };
}
,
"17cd914f":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    module.exports = (value)=>{
        if (Object.prototype.toString.call(value) !== '[object Object]') {
            return false;
        }
        const prototype = Object.getPrototypeOf(value);
        return prototype === null || prototype === Object.prototype;
    };
}
,
"183ad0d4":function  (module, exports, farmRequire, farmDynamicRequire) {
    module.exports = {
        "100": "Continue",
        "101": "Switching Protocols",
        "102": "Processing",
        "103": "Early Hints",
        "200": "OK",
        "201": "Created",
        "202": "Accepted",
        "203": "Non-Authoritative Information",
        "204": "No Content",
        "205": "Reset Content",
        "206": "Partial Content",
        "207": "Multi-Status",
        "208": "Already Reported",
        "226": "IM Used",
        "300": "Multiple Choices",
        "301": "Moved Permanently",
        "302": "Found",
        "303": "See Other",
        "304": "Not Modified",
        "305": "Use Proxy",
        "306": "(Unused)",
        "307": "Temporary Redirect",
        "308": "Permanent Redirect",
        "400": "Bad Request",
        "401": "Unauthorized",
        "402": "Payment Required",
        "403": "Forbidden",
        "404": "Not Found",
        "405": "Method Not Allowed",
        "406": "Not Acceptable",
        "407": "Proxy Authentication Required",
        "408": "Request Timeout",
        "409": "Conflict",
        "410": "Gone",
        "411": "Length Required",
        "412": "Precondition Failed",
        "413": "Payload Too Large",
        "414": "URI Too Long",
        "415": "Unsupported Media Type",
        "416": "Range Not Satisfiable",
        "417": "Expectation Failed",
        "418": "I'm a teapot",
        "421": "Misdirected Request",
        "422": "Unprocessable Entity",
        "423": "Locked",
        "424": "Failed Dependency",
        "425": "Unordered Collection",
        "426": "Upgrade Required",
        "428": "Precondition Required",
        "429": "Too Many Requests",
        "431": "Request Header Fields Too Large",
        "451": "Unavailable For Legal Reasons",
        "500": "Internal Server Error",
        "501": "Not Implemented",
        "502": "Bad Gateway",
        "503": "Service Unavailable",
        "504": "Gateway Timeout",
        "505": "HTTP Version Not Supported",
        "506": "Variant Also Negotiates",
        "507": "Insufficient Storage",
        "508": "Loop Detected",
        "509": "Bandwidth Limit Exceeded",
        "510": "Not Extended",
        "511": "Network Authentication Required"
    };
}
,
"189f7617":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "cleanUrl", ()=>cleanUrl);
    const postfixRE = /[?#].*$/;
    function cleanUrl(url) {
        return url.replace(postfixRE, '');
    }
}
,
"19589191":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "default", ()=>mimicFunction);
    const copyProperty = (to, from, property, ignoreNonConfigurable)=>{
        if (property === 'length' || property === 'prototype') {
            return;
        }
        if (property === 'arguments' || property === 'caller') {
            return;
        }
        const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
        const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);
        if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {
            return;
        }
        Object.defineProperty(to, property, fromDescriptor);
    };
    const canCopyProperty = function(toDescriptor, fromDescriptor) {
        return toDescriptor === undefined || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
    };
    const changePrototype = (to, from)=>{
        const fromPrototype = Object.getPrototypeOf(from);
        if (fromPrototype === Object.getPrototypeOf(to)) {
            return;
        }
        Object.setPrototypeOf(to, fromPrototype);
    };
    const wrappedToString = (withName, fromBody)=>`/* Wrapped ${withName}*/\n${fromBody}`;
    const toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, 'toString');
    const toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, 'name');
    const changeToString = (to, from, name)=>{
        const withName = name === '' ? '' : `with ${name.trim()}() `;
        const newToString = wrappedToString.bind(null, withName, from.toString());
        Object.defineProperty(newToString, 'name', toStringName);
        Object.defineProperty(to, 'toString', {
            ...toStringDescriptor,
            value: newToString
        });
    };
    function mimicFunction(to, from, { ignoreNonConfigurable = false } = {}) {
        const { name } = to;
        for (const property of Reflect.ownKeys(from)){
            copyProperty(to, from, property, ignoreNonConfigurable);
        }
        changePrototype(to, from);
        changeToString(to, from, name);
        return to;
    }
}
,
"1a581683":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "partialExternal", ()=>partialExternal);
    module.o(exports, "normalizeExternal", ()=>normalizeExternal);
    module.o(exports, "mergeCustomExternal", ()=>mergeCustomExternal);
    var _f_node_module = module.i(farmRequire('node:module'));
    var _f_node_fs = farmRequire('node:fs');
    var _f_node_path = module.i(farmRequire('node:path'));
    var _f_json = farmRequire("5a1b26a7");
    var _f_share = farmRequire("bc6cc539");
    var _f_constants = farmRequire("97f6a66c");
    function partialExternal(externalConfig = []) {
        const stringExternal = [];
        const recordExternal = {};
        for (const external of externalConfig){
            if (typeof external === 'string') {
                stringExternal.push(external);
            } else if (_f_share.isObject(external)) {
                Object.assign(recordExternal, external);
            }
        }
        return [
            stringExternal,
            recordExternal
        ];
    }
    function normalizeExternal(config, resolvedCompilation) {
        const defaultExternals = [];
        const externalNodeBuiltins = config.compilation?.externalNodeBuiltins ?? true;
        if (externalNodeBuiltins) {
            if (Array.isArray(externalNodeBuiltins)) {
                defaultExternals.push(...externalNodeBuiltins);
            } else if (externalNodeBuiltins === true) {
                let packageJson = {};
                const pkgPath = module.f(_f_node_path).join(resolvedCompilation.root || process.cwd(), 'package.json');
                if (_f_node_fs.existsSync(pkgPath)) {
                    try {
                        packageJson = JSON.parse(_f_node_fs.readFileSync(pkgPath, 'utf8'));
                    } catch  {}
                }
                defaultExternals.push(...[
                    ...module.f(_f_node_module).builtinModules
                ].filter((m)=>!resolvedCompilation.resolve?.alias?.[m] && !packageJson?.devDependencies?.[m] && !packageJson?.dependencies?.[m]));
            }
        }
        if (!config?.compilation?.custom) {
            config.compilation.custom = {};
        }
        if (!resolvedCompilation?.custom) {
            resolvedCompilation.custom = {};
        }
        const [stringExternal, recordExternal] = mergeCustomExternal(config.compilation, mergeCustomExternal(resolvedCompilation, partialExternal(config.compilation.external)));
        resolvedCompilation.custom[_f_constants.CUSTOM_KEYS.external_record] = JSON.stringify(recordExternal);
        resolvedCompilation.external = [
            ...stringExternal,
            '^node:',
            ...defaultExternals.map((m)=>`^${m}($|/promises$)`)
        ];
    }
    function mergeCustomExternal(compilation, external) {
        const [stringExternal, recordExternal] = external;
        if (!compilation?.custom) {
            compilation.custom = {};
        }
        const oldRecordExternal = compilation.custom[_f_constants.CUSTOM_KEYS.external_record] ? _f_json.safeJsonParse(compilation.custom[_f_constants.CUSTOM_KEYS.external_record], {}) || {} : {};
        return [
            [
                ...new Set(stringExternal)
            ],
            _f_share.isObject(oldRecordExternal) ? {
                ...oldRecordExternal,
                ...recordExternal
            } : recordExternal
        ];
    }
}
,
"1aaeac37":function  (module, exports, farmRequire, farmDynamicRequire) {
    var constants = global.nodeRequire('constants', true);
    var origCwd = process.cwd;
    var cwd = null;
    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
        if (!cwd) cwd = origCwd.call(process);
        return cwd;
    };
    try {
        process.cwd();
    } catch (er) {}
    if (typeof process.chdir === 'function') {
        var chdir = process.chdir;
        process.chdir = function(d) {
            cwd = null;
            chdir.call(process, d);
        };
        if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
    }
    module.exports = patch;
    function patch(fs) {
        if (constants.hasOwnProperty('O_SYMLINK') && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
            patchLchmod(fs);
        }
        if (!fs.lutimes) {
            patchLutimes(fs);
        }
        fs.chown = chownFix(fs.chown);
        fs.fchown = chownFix(fs.fchown);
        fs.lchown = chownFix(fs.lchown);
        fs.chmod = chmodFix(fs.chmod);
        fs.fchmod = chmodFix(fs.fchmod);
        fs.lchmod = chmodFix(fs.lchmod);
        fs.chownSync = chownFixSync(fs.chownSync);
        fs.fchownSync = chownFixSync(fs.fchownSync);
        fs.lchownSync = chownFixSync(fs.lchownSync);
        fs.chmodSync = chmodFixSync(fs.chmodSync);
        fs.fchmodSync = chmodFixSync(fs.fchmodSync);
        fs.lchmodSync = chmodFixSync(fs.lchmodSync);
        fs.stat = statFix(fs.stat);
        fs.fstat = statFix(fs.fstat);
        fs.lstat = statFix(fs.lstat);
        fs.statSync = statFixSync(fs.statSync);
        fs.fstatSync = statFixSync(fs.fstatSync);
        fs.lstatSync = statFixSync(fs.lstatSync);
        if (fs.chmod && !fs.lchmod) {
            fs.lchmod = function(path, mode, cb) {
                if (cb) process.nextTick(cb);
            };
            fs.lchmodSync = function() {};
        }
        if (fs.chown && !fs.lchown) {
            fs.lchown = function(path, uid, gid, cb) {
                if (cb) process.nextTick(cb);
            };
            fs.lchownSync = function() {};
        }
        if (platform === "win32") {
            fs.rename = typeof fs.rename !== 'function' ? fs.rename : function(fs$rename) {
                function rename(from, to, cb) {
                    var start = Date.now();
                    var backoff = 0;
                    fs$rename(from, to, function CB(er) {
                        if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 60000) {
                            setTimeout(function() {
                                fs.stat(to, function(stater, st) {
                                    if (stater && stater.code === "ENOENT") fs$rename(from, to, CB);
                                    else cb(er);
                                });
                            }, backoff);
                            if (backoff < 100) backoff += 10;
                            return;
                        }
                        if (cb) cb(er);
                    });
                }
                if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename);
                return rename;
            }(fs.rename);
        }
        fs.read = typeof fs.read !== 'function' ? fs.read : function(fs$read) {
            function read(fd, buffer, offset, length, position, callback_) {
                var callback;
                if (callback_ && typeof callback_ === 'function') {
                    var eagCounter = 0;
                    callback = function(er, _, __) {
                        if (er && er.code === 'EAGAIN' && eagCounter < 10) {
                            eagCounter++;
                            return fs$read.call(fs, fd, buffer, offset, length, position, callback);
                        }
                        callback_.apply(this, arguments);
                    };
                }
                return fs$read.call(fs, fd, buffer, offset, length, position, callback);
            }
            if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
            return read;
        }(fs.read);
        fs.readSync = typeof fs.readSync !== 'function' ? fs.readSync : function(fs$readSync) {
            return function(fd, buffer, offset, length, position) {
                var eagCounter = 0;
                while(true){
                    try {
                        return fs$readSync.call(fs, fd, buffer, offset, length, position);
                    } catch (er) {
                        if (er.code === 'EAGAIN' && eagCounter < 10) {
                            eagCounter++;
                            continue;
                        }
                        throw er;
                    }
                }
            };
        }(fs.readSync);
        function patchLchmod(fs) {
            fs.lchmod = function(path, mode, callback) {
                fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
                    if (err) {
                        if (callback) callback(err);
                        return;
                    }
                    fs.fchmod(fd, mode, function(err) {
                        fs.close(fd, function(err2) {
                            if (callback) callback(err || err2);
                        });
                    });
                });
            };
            fs.lchmodSync = function(path, mode) {
                var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);
                var threw = true;
                var ret;
                try {
                    ret = fs.fchmodSync(fd, mode);
                    threw = false;
                } finally{
                    if (threw) {
                        try {
                            fs.closeSync(fd);
                        } catch (er) {}
                    } else {
                        fs.closeSync(fd);
                    }
                }
                return ret;
            };
        }
        function patchLutimes(fs) {
            if (constants.hasOwnProperty("O_SYMLINK") && fs.futimes) {
                fs.lutimes = function(path, at, mt, cb) {
                    fs.open(path, constants.O_SYMLINK, function(er, fd) {
                        if (er) {
                            if (cb) cb(er);
                            return;
                        }
                        fs.futimes(fd, at, mt, function(er) {
                            fs.close(fd, function(er2) {
                                if (cb) cb(er || er2);
                            });
                        });
                    });
                };
                fs.lutimesSync = function(path, at, mt) {
                    var fd = fs.openSync(path, constants.O_SYMLINK);
                    var ret;
                    var threw = true;
                    try {
                        ret = fs.futimesSync(fd, at, mt);
                        threw = false;
                    } finally{
                        if (threw) {
                            try {
                                fs.closeSync(fd);
                            } catch (er) {}
                        } else {
                            fs.closeSync(fd);
                        }
                    }
                    return ret;
                };
            } else if (fs.futimes) {
                fs.lutimes = function(_a, _b, _c, cb) {
                    if (cb) process.nextTick(cb);
                };
                fs.lutimesSync = function() {};
            }
        }
        function chmodFix(orig) {
            if (!orig) return orig;
            return function(target, mode, cb) {
                return orig.call(fs, target, mode, function(er) {
                    if (chownErOk(er)) er = null;
                    if (cb) cb.apply(this, arguments);
                });
            };
        }
        function chmodFixSync(orig) {
            if (!orig) return orig;
            return function(target, mode) {
                try {
                    return orig.call(fs, target, mode);
                } catch (er) {
                    if (!chownErOk(er)) throw er;
                }
            };
        }
        function chownFix(orig) {
            if (!orig) return orig;
            return function(target, uid, gid, cb) {
                return orig.call(fs, target, uid, gid, function(er) {
                    if (chownErOk(er)) er = null;
                    if (cb) cb.apply(this, arguments);
                });
            };
        }
        function chownFixSync(orig) {
            if (!orig) return orig;
            return function(target, uid, gid) {
                try {
                    return orig.call(fs, target, uid, gid);
                } catch (er) {
                    if (!chownErOk(er)) throw er;
                }
            };
        }
        function statFix(orig) {
            if (!orig) return orig;
            return function(target, options, cb) {
                if (typeof options === 'function') {
                    cb = options;
                    options = null;
                }
                function callback(er, stats) {
                    if (stats) {
                        if (stats.uid < 0) stats.uid += 0x100000000;
                        if (stats.gid < 0) stats.gid += 0x100000000;
                    }
                    if (cb) cb.apply(this, arguments);
                }
                return options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
            };
        }
        function statFixSync(orig) {
            if (!orig) return orig;
            return function(target, options) {
                var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
                if (stats) {
                    if (stats.uid < 0) stats.uid += 0x100000000;
                    if (stats.gid < 0) stats.gid += 0x100000000;
                }
                return stats;
            };
        }
        function chownErOk(er) {
            if (!er) return true;
            if (er.code === "ENOSYS") return true;
            var nonroot = !process.getuid || process.getuid() !== 0;
            if (nonroot) {
                if (er.code === "EINVAL" || er.code === "EPERM") return true;
            }
            return false;
        }
    }
}
,
"1b291d05":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    module.exports = (flag, argv = process.argv)=>{
        const prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';
        const position = argv.indexOf(prefix + flag);
        const terminatorPosition = argv.indexOf('--');
        return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
}
,
"1bdb2cdd":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "execa", ()=>execa);
    module.o(exports, "execaSync", ()=>execaSync);
    module.o(exports, "$", ()=>$);
    var _f_node_buffer = farmRequire('node:buffer');
    var _f_node_path = module.i(farmRequire('node:path'));
    var _f_node_child_process = module.i(farmRequire('node:child_process'));
    var _f_node_process = module.i(farmRequire('node:process'));
    var _f_cross_spawn = module.i(farmRequire("8871c848"));
    var _f_strip_final_newline = module.i(farmRequire("14cbc7d0"));
    var _f_npm_run_path = farmRequire("0d0a2382");
    var _f_onetime = module.i(farmRequire("0db3db94"));
    var _f_error = farmRequire("ace5e05a");
    var _f_stdio = farmRequire("ecabb81e");
    var _f_kill = farmRequire("67a8eb72");
    var _f_pipe = farmRequire("a1177766");
    var _f_stream = farmRequire("33d70b5a");
    var _f_promise = farmRequire("d4405cd7");
    var _f_command = farmRequire("e0afbeaa");
    var _f_verbose = farmRequire("350f644e");
    const DEFAULT_MAX_BUFFER = 1000 * 1000 * 100;
    const getEnv = ({ env: envOption, extendEnv, preferLocal, localDir, execPath })=>{
        const env = extendEnv ? {
            ...module.f(_f_node_process).env,
            ...envOption
        } : envOption;
        if (preferLocal) {
            return _f_npm_run_path.npmRunPathEnv({
                env,
                cwd: localDir,
                execPath
            });
        }
        return env;
    };
    const handleArguments = (file, args, options = {})=>{
        const parsed = module.f(_f_cross_spawn)._parse(file, args, options);
        file = parsed.command;
        args = parsed.args;
        options = parsed.options;
        options = {
            maxBuffer: DEFAULT_MAX_BUFFER,
            buffer: true,
            stripFinalNewline: true,
            extendEnv: true,
            preferLocal: false,
            localDir: options.cwd || module.f(_f_node_process).cwd(),
            execPath: module.f(_f_node_process).execPath,
            encoding: 'utf8',
            reject: true,
            cleanup: true,
            all: false,
            windowsHide: true,
            verbose: _f_verbose.verboseDefault,
            ...options
        };
        options.env = getEnv(options);
        options.stdio = _f_stdio.normalizeStdio(options);
        if (module.f(_f_node_process).platform === 'win32' && module.f(_f_node_path).basename(file, '.exe') === 'cmd') {
            args.unshift('/q');
        }
        return {
            file,
            args,
            options,
            parsed
        };
    };
    const handleOutput = (options, value, error)=>{
        if (typeof value !== 'string' && !_f_node_buffer.Buffer.isBuffer(value)) {
            return error === undefined ? undefined : '';
        }
        if (options.stripFinalNewline) {
            return module.f(_f_strip_final_newline)(value);
        }
        return value;
    };
    function execa(file, args, options) {
        const parsed = handleArguments(file, args, options);
        const command = _f_command.joinCommand(file, args);
        const escapedCommand = _f_command.getEscapedCommand(file, args);
        _f_verbose.logCommand(escapedCommand, parsed.options);
        _f_kill.validateTimeout(parsed.options);
        let spawned;
        try {
            spawned = module.f(_f_node_child_process).spawn(parsed.file, parsed.args, parsed.options);
        } catch (error) {
            const dummySpawned = new (module.f(_f_node_child_process)).ChildProcess();
            const errorPromise = Promise.reject(_f_error.makeError({
                error,
                stdout: '',
                stderr: '',
                all: '',
                command,
                escapedCommand,
                parsed,
                timedOut: false,
                isCanceled: false,
                killed: false
            }));
            _f_promise.mergePromise(dummySpawned, errorPromise);
            return dummySpawned;
        }
        const spawnedPromise = _f_promise.getSpawnedPromise(spawned);
        const timedPromise = _f_kill.setupTimeout(spawned, parsed.options, spawnedPromise);
        const processDone = _f_kill.setExitHandler(spawned, parsed.options, timedPromise);
        const context = {
            isCanceled: false
        };
        spawned.kill = _f_kill.spawnedKill.bind(null, spawned.kill.bind(spawned));
        spawned.cancel = _f_kill.spawnedCancel.bind(null, spawned, context);
        const handlePromise = async ()=>{
            const [{ error, exitCode, signal, timedOut }, stdoutResult, stderrResult, allResult] = await _f_stream.getSpawnedResult(spawned, parsed.options, processDone);
            const stdout = handleOutput(parsed.options, stdoutResult);
            const stderr = handleOutput(parsed.options, stderrResult);
            const all = handleOutput(parsed.options, allResult);
            if (error || exitCode !== 0 || signal !== null) {
                const returnedError = _f_error.makeError({
                    error,
                    exitCode,
                    signal,
                    stdout,
                    stderr,
                    all,
                    command,
                    escapedCommand,
                    parsed,
                    timedOut,
                    isCanceled: context.isCanceled || (parsed.options.signal ? parsed.options.signal.aborted : false),
                    killed: spawned.killed
                });
                if (!parsed.options.reject) {
                    return returnedError;
                }
                throw returnedError;
            }
            return {
                command,
                escapedCommand,
                exitCode: 0,
                stdout,
                stderr,
                all,
                failed: false,
                timedOut: false,
                isCanceled: false,
                killed: false
            };
        };
        const handlePromiseOnce = module.f(_f_onetime)(handlePromise);
        _f_stream.handleInput(spawned, parsed.options);
        spawned.all = _f_stream.makeAllStream(spawned, parsed.options);
        _f_pipe.addPipeMethods(spawned);
        _f_promise.mergePromise(spawned, handlePromiseOnce);
        return spawned;
    }
    function execaSync(file, args, options) {
        const parsed = handleArguments(file, args, options);
        const command = _f_command.joinCommand(file, args);
        const escapedCommand = _f_command.getEscapedCommand(file, args);
        _f_verbose.logCommand(escapedCommand, parsed.options);
        const input = _f_stream.handleInputSync(parsed.options);
        let result;
        try {
            result = module.f(_f_node_child_process).spawnSync(parsed.file, parsed.args, {
                ...parsed.options,
                input
            });
        } catch (error) {
            throw _f_error.makeError({
                error,
                stdout: '',
                stderr: '',
                all: '',
                command,
                escapedCommand,
                parsed,
                timedOut: false,
                isCanceled: false,
                killed: false
            });
        }
        const stdout = handleOutput(parsed.options, result.stdout, result.error);
        const stderr = handleOutput(parsed.options, result.stderr, result.error);
        if (result.error || result.status !== 0 || result.signal !== null) {
            const error = _f_error.makeError({
                stdout,
                stderr,
                error: result.error,
                signal: result.signal,
                exitCode: result.status,
                command,
                escapedCommand,
                parsed,
                timedOut: result.error && result.error.code === 'ETIMEDOUT',
                isCanceled: false,
                killed: result.signal !== null
            });
            if (!parsed.options.reject) {
                return error;
            }
            throw error;
        }
        return {
            command,
            escapedCommand,
            exitCode: 0,
            stdout,
            stderr,
            failed: false,
            timedOut: false,
            isCanceled: false,
            killed: false
        };
    }
    const normalizeScriptStdin = ({ input, inputFile, stdio })=>input === undefined && inputFile === undefined && stdio === undefined ? {
            stdin: 'inherit'
        } : {};
    const normalizeScriptOptions = (options = {})=>({
            preferLocal: true,
            ...normalizeScriptStdin(options),
            ...options
        });
    function create$(options) {
        function $(templatesOrOptions, ...expressions) {
            if (!Array.isArray(templatesOrOptions)) {
                return create$({
                    ...options,
                    ...templatesOrOptions
                });
            }
            const [file, ...args] = _f_command.parseTemplates(templatesOrOptions, expressions);
            return execa(file, args, normalizeScriptOptions(options));
        }
        $.sync = (templates, ...expressions)=>{
            if (!Array.isArray(templates)) {
                throw new TypeError('Please use $(options).sync`command` instead of $.sync(options)`command`.');
            }
            const [file, ...args] = _f_command.parseTemplates(templates, expressions);
            return execaSync(file, args, normalizeScriptOptions(options));
        };
        return $;
    }
    var $ = create$();
}
,
"1c12c622":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const sync_1 = farmRequire("342cb9f2", true);
    class SyncProvider {
        constructor(_root, _settings){
            this._root = _root;
            this._settings = _settings;
            this._reader = new sync_1.default(this._root, this._settings);
        }
        read() {
            return this._reader.read();
        }
    }
    exports.default = SyncProvider;
}
,
"1c65495a":function  (module, exports, farmRequire, farmDynamicRequire) {
    function setup(env) {
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = farmRequire("91b8e001", true);
        createDebug.destroy = destroy;
        Object.keys(env).forEach((key)=>{
            createDebug[key] = env[key];
        });
        createDebug.names = [];
        createDebug.skips = [];
        createDebug.formatters = {};
        function selectColor(namespace) {
            let hash = 0;
            for(let i = 0; i < namespace.length; i++){
                hash = (hash << 5) - hash + namespace.charCodeAt(i);
                hash |= 0;
            }
            return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
        }
        createDebug.selectColor = selectColor;
        function createDebug(namespace) {
            let prevTime;
            let enableOverride = null;
            let namespacesCache;
            let enabledCache;
            function debug(...args) {
                if (!debug.enabled) {
                    return;
                }
                const self = debug;
                const curr = Number(new Date());
                const ms = curr - (prevTime || curr);
                self.diff = ms;
                self.prev = prevTime;
                self.curr = curr;
                prevTime = curr;
                args[0] = createDebug.coerce(args[0]);
                if (typeof args[0] !== 'string') {
                    args.unshift('%O');
                }
                let index = 0;
                args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{
                    if (match === '%%') {
                        return '%';
                    }
                    index++;
                    const formatter = createDebug.formatters[format];
                    if (typeof formatter === 'function') {
                        const val = args[index];
                        match = formatter.call(self, val);
                        args.splice(index, 1);
                        index--;
                    }
                    return match;
                });
                createDebug.formatArgs.call(self, args);
                const logFn = self.log || createDebug.log;
                logFn.apply(self, args);
            }
            debug.namespace = namespace;
            debug.useColors = createDebug.useColors();
            debug.color = createDebug.selectColor(namespace);
            debug.extend = extend;
            debug.destroy = createDebug.destroy;
            Object.defineProperty(debug, 'enabled', {
                enumerable: true,
                configurable: false,
                get: ()=>{
                    if (enableOverride !== null) {
                        return enableOverride;
                    }
                    if (namespacesCache !== createDebug.namespaces) {
                        namespacesCache = createDebug.namespaces;
                        enabledCache = createDebug.enabled(namespace);
                    }
                    return enabledCache;
                },
                set: (v)=>{
                    enableOverride = v;
                }
            });
            if (typeof createDebug.init === 'function') {
                createDebug.init(debug);
            }
            return debug;
        }
        function extend(namespace, delimiter) {
            const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
            newDebug.log = this.log;
            return newDebug;
        }
        function enable(namespaces) {
            createDebug.save(namespaces);
            createDebug.namespaces = namespaces;
            createDebug.names = [];
            createDebug.skips = [];
            let i;
            const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
            const len = split.length;
            for(i = 0; i < len; i++){
                if (!split[i]) {
                    continue;
                }
                namespaces = split[i].replace(/\*/g, '.*?');
                if (namespaces[0] === '-') {
                    createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
                } else {
                    createDebug.names.push(new RegExp('^' + namespaces + '$'));
                }
            }
        }
        function disable() {
            const namespaces = [
                ...createDebug.names.map(toNamespace),
                ...createDebug.skips.map(toNamespace).map((namespace)=>'-' + namespace)
            ].join(',');
            createDebug.enable('');
            return namespaces;
        }
        function enabled(name) {
            if (name[name.length - 1] === '*') {
                return true;
            }
            let i;
            let len;
            for(i = 0, len = createDebug.skips.length; i < len; i++){
                if (createDebug.skips[i].test(name)) {
                    return false;
                }
            }
            for(i = 0, len = createDebug.names.length; i < len; i++){
                if (createDebug.names[i].test(name)) {
                    return true;
                }
            }
            return false;
        }
        function toNamespace(regexp) {
            return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
        }
        function coerce(val) {
            if (val instanceof Error) {
                return val.stack || val.message;
            }
            return val;
        }
        function destroy() {
            console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
        }
        createDebug.enable(createDebug.load());
        return createDebug;
    }
    module.exports = setup;
}
,
"1c7522fd":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const fs = farmRequire("ffc819a8", true);
    function symlinkType(srcpath, type, callback) {
        callback = typeof type === 'function' ? type : callback;
        type = typeof type === 'function' ? false : type;
        if (type) return callback(null, type);
        fs.lstat(srcpath, (err, stats)=>{
            if (err) return callback(null, 'file');
            type = stats && stats.isDirectory() ? 'dir' : 'file';
            callback(null, type);
        });
    }
    function symlinkTypeSync(srcpath, type) {
        let stats;
        if (type) return type;
        try {
            stats = fs.lstatSync(srcpath);
        } catch  {
            return 'file';
        }
        return stats && stats.isDirectory() ? 'dir' : 'file';
    }
    module.exports = {
        symlinkType,
        symlinkTypeSync
    };
}
,
"1c8f4aba":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "apps", ()=>apps);
    var _f_node_process = module.i(farmRequire('node:process'));
    var _f_node_buffer = farmRequire('node:buffer');
    var _f_node_path = module.i(farmRequire('node:path'));
    var _f_node_url = farmRequire('node:url');
    var _f_node_child_process = module.i(farmRequire('node:child_process'));
    var _f_promises = module.i(farmRequire('node:fs/promises'));
    var _f_node_fs = farmRequire('node:fs');
    var _f_is_wsl = module.i(farmRequire("b9d7fcb5"));
    var _f_define_lazy_prop = module.i(farmRequire("95307fb5"));
    var _f_default_browser = module.i(farmRequire("c43e8a2b"));
    var _f_is_inside_container = module.i(farmRequire("d42f4747"));
    const __dirname = module.f(_f_node_path).dirname(_f_node_url.fileURLToPath(module.meta.url));
    const localXdgOpenPath = module.f(_f_node_path).join(__dirname, 'xdg-open');
    const { platform, arch } = module.f(_f_node_process);
    const getWslDrivesMountPoint = (()=>{
        const defaultMountPoint = '/mnt/';
        let mountPoint;
        return async function() {
            if (mountPoint) {
                return mountPoint;
            }
            const configFilePath = '/etc/wsl.conf';
            let isConfigFileExists = false;
            try {
                await module.f(_f_promises).access(configFilePath, _f_node_fs.constants.F_OK);
                isConfigFileExists = true;
            } catch  {}
            if (!isConfigFileExists) {
                return defaultMountPoint;
            }
            const configContent = await module.f(_f_promises).readFile(configFilePath, {
                encoding: 'utf8'
            });
            const configMountPoint = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(configContent);
            if (!configMountPoint) {
                return defaultMountPoint;
            }
            mountPoint = configMountPoint.groups.mountPoint.trim();
            mountPoint = mountPoint.endsWith('/') ? mountPoint : `${mountPoint}/`;
            return mountPoint;
        };
    })();
    const pTryEach = async (array, mapper)=>{
        let latestError;
        for (const item of array){
            try {
                return await mapper(item);
            } catch (error) {
                latestError = error;
            }
        }
        throw latestError;
    };
    const baseOpen = async (options)=>{
        options = {
            wait: false,
            background: false,
            newInstance: false,
            allowNonzeroExitCode: false,
            ...options
        };
        if (Array.isArray(options.app)) {
            return pTryEach(options.app, (singleApp)=>baseOpen({
                    ...options,
                    app: singleApp
                }));
        }
        let { name: app, arguments: appArguments = [] } = options.app ?? {};
        appArguments = [
            ...appArguments
        ];
        if (Array.isArray(app)) {
            return pTryEach(app, (appName)=>baseOpen({
                    ...options,
                    app: {
                        name: appName,
                        arguments: appArguments
                    }
                }));
        }
        if (app === 'browser' || app === 'browserPrivate') {
            const ids = {
                'com.google.chrome': 'chrome',
                'google-chrome.desktop': 'chrome',
                'org.mozilla.firefox': 'firefox',
                'firefox.desktop': 'firefox',
                'com.microsoft.msedge': 'edge',
                'com.microsoft.edge': 'edge',
                'microsoft-edge.desktop': 'edge'
            };
            const flags = {
                chrome: '--incognito',
                firefox: '--private-window',
                edge: '--inPrivate'
            };
            const browser = await module.f(_f_default_browser)();
            if (browser.id in ids) {
                const browserName = ids[browser.id];
                if (app === 'browserPrivate') {
                    appArguments.push(flags[browserName]);
                }
                return baseOpen({
                    ...options,
                    app: {
                        name: apps[browserName],
                        arguments: appArguments
                    }
                });
            }
            throw new Error(`${browser.name} is not supported as a default browser`);
        }
        let command;
        const cliArguments = [];
        const childProcessOptions = {};
        if (platform === 'darwin') {
            command = 'open';
            if (options.wait) {
                cliArguments.push('--wait-apps');
            }
            if (options.background) {
                cliArguments.push('--background');
            }
            if (options.newInstance) {
                cliArguments.push('--new');
            }
            if (app) {
                cliArguments.push('-a', app);
            }
        } else if (platform === 'win32' || module.f(_f_is_wsl) && !module.f(_f_is_inside_container)() && !app) {
            const mountPoint = await getWslDrivesMountPoint();
            command = module.f(_f_is_wsl) ? `${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe` : `${module.f(_f_node_process).env.SYSTEMROOT}\\System32\\WindowsPowerShell\\v1.0\\powershell`;
            cliArguments.push('-NoProfile', '-NonInteractive', '-ExecutionPolicy', 'Bypass', '-EncodedCommand');
            if (!module.f(_f_is_wsl)) {
                childProcessOptions.windowsVerbatimArguments = true;
            }
            const encodedArguments = [
                'Start'
            ];
            if (options.wait) {
                encodedArguments.push('-Wait');
            }
            if (app) {
                encodedArguments.push(`"\`"${app}\`""`);
                if (options.target) {
                    appArguments.push(options.target);
                }
            } else if (options.target) {
                encodedArguments.push(`"${options.target}"`);
            }
            if (appArguments.length > 0) {
                appArguments = appArguments.map((arg)=>`"\`"${arg}\`""`);
                encodedArguments.push('-ArgumentList', appArguments.join(','));
            }
            options.target = _f_node_buffer.Buffer.from(encodedArguments.join(' '), 'utf16le').toString('base64');
        } else {
            if (app) {
                command = app;
            } else {
                const isBundled = !__dirname || __dirname === '/';
                let exeLocalXdgOpen = false;
                try {
                    await module.f(_f_promises).access(localXdgOpenPath, _f_node_fs.constants.X_OK);
                    exeLocalXdgOpen = true;
                } catch  {}
                const useSystemXdgOpen = module.f(_f_node_process).versions.electron ?? (platform === 'android' || isBundled || !exeLocalXdgOpen);
                command = useSystemXdgOpen ? 'xdg-open' : localXdgOpenPath;
            }
            if (appArguments.length > 0) {
                cliArguments.push(...appArguments);
            }
            if (!options.wait) {
                childProcessOptions.stdio = 'ignore';
                childProcessOptions.detached = true;
            }
        }
        if (options.target) {
            cliArguments.push(options.target);
        }
        if (platform === 'darwin' && appArguments.length > 0) {
            cliArguments.push('--args', ...appArguments);
        }
        const subprocess = module.f(_f_node_child_process).spawn(command, cliArguments, childProcessOptions);
        if (options.wait) {
            return new Promise((resolve, reject)=>{
                subprocess.once('error', reject);
                subprocess.once('close', (exitCode)=>{
                    if (!options.allowNonzeroExitCode && exitCode > 0) {
                        reject(new Error(`Exited with code ${exitCode}`));
                        return;
                    }
                    resolve(subprocess);
                });
            });
        }
        subprocess.unref();
        return subprocess;
    };
    const open = (target, options)=>{
        if (typeof target !== 'string') {
            throw new TypeError('Expected a `target`');
        }
        return baseOpen({
            ...options,
            target
        });
    };
    function detectArchBinary(binary) {
        if (typeof binary === 'string' || Array.isArray(binary)) {
            return binary;
        }
        const { [arch]: archBinary } = binary;
        if (!archBinary) {
            throw new Error(`${arch} is not supported`);
        }
        return archBinary;
    }
    function detectPlatformBinary({ [platform]: platformBinary }, { wsl }) {
        if (wsl && module.f(_f_is_wsl)) {
            return detectArchBinary(wsl);
        }
        if (!platformBinary) {
            throw new Error(`${platform} is not supported`);
        }
        return detectArchBinary(platformBinary);
    }
    var apps = {};
    module.f(_f_define_lazy_prop)(apps, 'chrome', ()=>detectPlatformBinary({
            darwin: 'google chrome',
            win32: 'chrome',
            linux: [
                'google-chrome',
                'google-chrome-stable',
                'chromium'
            ]
        }, {
            wsl: {
                ia32: '/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe',
                x64: [
                    '/mnt/c/Program Files/Google/Chrome/Application/chrome.exe',
                    '/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe'
                ]
            }
        }));
    module.f(_f_define_lazy_prop)(apps, 'firefox', ()=>detectPlatformBinary({
            darwin: 'firefox',
            win32: 'C:\\Program Files\\Mozilla Firefox\\firefox.exe',
            linux: 'firefox'
        }, {
            wsl: '/mnt/c/Program Files/Mozilla Firefox/firefox.exe'
        }));
    module.f(_f_define_lazy_prop)(apps, 'edge', ()=>detectPlatformBinary({
            darwin: 'microsoft edge',
            win32: 'msedge',
            linux: [
                'microsoft-edge',
                'microsoft-edge-dev'
            ]
        }, {
            wsl: '/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe'
        }));
    module.f(_f_define_lazy_prop)(apps, 'browser', ()=>'browser');
    module.f(_f_define_lazy_prop)(apps, 'browserPrivate', ()=>'browserPrivate');
    exports.default = open;
}
,
"1caed8ab":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const async_1 = farmRequire("f3250925", true);
    const provider_1 = farmRequire("ba3d9d5e", true);
    class ProviderAsync extends provider_1.default {
        constructor(){
            super(...arguments);
            this._reader = new async_1.default(this._settings);
        }
        async read(task) {
            const root = this._getRootDirectory(task);
            const options = this._getReaderOptions(task);
            const entries = await this.api(root, task, options);
            return entries.map((entry)=>options.transform(entry));
        }
        api(root, task, options) {
            if (task.dynamic) {
                return this._reader.dynamic(root, options);
            }
            return this._reader.static(task.patterns, options);
        }
    }
    exports.default = ProviderAsync;
}
,
"1d931b02":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const isStream = farmRequire("7572a256", true);
    const getStream = farmRequire("4ac23bc0", true);
    const mergeStream = farmRequire("4cf295d9", true);
    const handleInput = (spawned, input)=>{
        if (input === undefined || spawned.stdin === undefined) {
            return;
        }
        if (isStream(input)) {
            input.pipe(spawned.stdin);
        } else {
            spawned.stdin.end(input);
        }
    };
    const makeAllStream = (spawned, { all })=>{
        if (!all || !spawned.stdout && !spawned.stderr) {
            return;
        }
        const mixed = mergeStream();
        if (spawned.stdout) {
            mixed.add(spawned.stdout);
        }
        if (spawned.stderr) {
            mixed.add(spawned.stderr);
        }
        return mixed;
    };
    const getBufferedData = async (stream, streamPromise)=>{
        if (!stream) {
            return;
        }
        stream.destroy();
        try {
            return await streamPromise;
        } catch (error) {
            return error.bufferedData;
        }
    };
    const getStreamPromise = (stream, { encoding, buffer, maxBuffer })=>{
        if (!stream || !buffer) {
            return;
        }
        if (encoding) {
            return getStream(stream, {
                encoding,
                maxBuffer
            });
        }
        return getStream.buffer(stream, {
            maxBuffer
        });
    };
    const getSpawnedResult = async ({ stdout, stderr, all }, { encoding, buffer, maxBuffer }, processDone)=>{
        const stdoutPromise = getStreamPromise(stdout, {
            encoding,
            buffer,
            maxBuffer
        });
        const stderrPromise = getStreamPromise(stderr, {
            encoding,
            buffer,
            maxBuffer
        });
        const allPromise = getStreamPromise(all, {
            encoding,
            buffer,
            maxBuffer: maxBuffer * 2
        });
        try {
            return await Promise.all([
                processDone,
                stdoutPromise,
                stderrPromise,
                allPromise
            ]);
        } catch (error) {
            return Promise.all([
                {
                    error,
                    signal: error.signal,
                    timedOut: error.timedOut
                },
                getBufferedData(stdout, stdoutPromise),
                getBufferedData(stderr, stderrPromise),
                getBufferedData(all, allPromise)
            ]);
        }
    };
    const validateInputSync = ({ input })=>{
        if (isStream(input)) {
            throw new TypeError('The `input` option cannot be a stream in sync mode');
        }
    };
    module.exports = {
        handleInput,
        makeAllStream,
        getSpawnedResult,
        validateInputSync
    };
}
,
"1e432c39":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const stringify = farmRequire("f4086ed0", true);
    const compile = farmRequire("fcaf28bf", true);
    const expand = farmRequire("b96c39dc", true);
    const parse = farmRequire("bb24cb57", true);
    const braces = (input, options = {})=>{
        let output = [];
        if (Array.isArray(input)) {
            for (let pattern of input){
                let result = braces.create(pattern, options);
                if (Array.isArray(result)) {
                    output.push(...result);
                } else {
                    output.push(result);
                }
            }
        } else {
            output = [].concat(braces.create(input, options));
        }
        if (options && options.expand === true && options.nodupes === true) {
            output = [
                ...new Set(output)
            ];
        }
        return output;
    };
    braces.parse = (input, options = {})=>parse(input, options);
    braces.stringify = (input, options = {})=>{
        if (typeof input === 'string') {
            return stringify(braces.parse(input, options), options);
        }
        return stringify(input, options);
    };
    braces.compile = (input, options = {})=>{
        if (typeof input === 'string') {
            input = braces.parse(input, options);
        }
        return compile(input, options);
    };
    braces.expand = (input, options = {})=>{
        if (typeof input === 'string') {
            input = braces.parse(input, options);
        }
        let result = expand(input, options);
        if (options.noempty === true) {
            result = result.filter(Boolean);
        }
        if (options.nodupes === true) {
            result = [
                ...new Set(result)
            ];
        }
        return result;
    };
    braces.create = (input, options = {})=>{
        if (input === '' || input.length < 3) {
            return [
                input
            ];
        }
        return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
    };
    module.exports = braces;
}
,
"1e5e7e95":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "defaultLoadPlugin", ()=>defaultLoadPlugin);
    var _f_node_fs = farmRequire('node:fs');
    var _f_node_path = farmRequire('node:path');
    var _f_utils = farmRequire("e60815f7");
    var _f_vite_plugin_adapter = farmRequire("9f146555");
    function defaultLoadPlugin(options) {
        const { filtersUnion, logger, userConfig } = options;
        const resolvedPaths = Array.from(filtersUnion).map(_f_utils.normalizeFilterPath);
        return {
            name: 'farm:load',
            priority: -100,
            load: {
                filters: {
                    resolvedPaths
                },
                executor: async (params)=>{
                    const { resolvedPath } = params;
                    if (_f_vite_plugin_adapter.VitePluginAdapter.isFarmInternalVirtualModule(resolvedPath) || !_f_node_fs.existsSync(resolvedPath)) {
                        if (!_f_node_path.isAbsolute(resolvedPath)) {
                            logger.info(`No plugins load virtual ${resolvedPath} in load hook. Farm load it as "export default await import('/@id/' + '${resolvedPath}');" by default for Vite Compatibility`);
                            return {
                                content: `export default await import('/@id/' + '${resolvedPath}');`,
                                moduleType: 'js'
                            };
                        }
                        return null;
                    }
                    const content = _f_node_fs.readFileSync(resolvedPath, 'utf-8');
                    return {
                        content,
                        moduleType: _f_utils.VITE_PLUGIN_DEFAULT_MODULE_TYPE
                    };
                }
            },
            transform: {
                filters: {
                    resolvedPaths,
                    moduleTypes: []
                },
                executor: async (params)=>{
                    const { content, moduleId, moduleType, resolvedPath } = params;
                    if (_f_vite_plugin_adapter.VitePluginAdapter.isFarmInternalVirtualModule(resolvedPath)) {
                        return null;
                    }
                    const cssModules = userConfig.compilation?.css?.modules?.paths ?? [
                        '\\.module\\.(css|less|sass|scss)$'
                    ];
                    const isCssModules = cssModules.some((reg)=>new RegExp(reg).test(moduleId));
                    if (_f_utils.getCssModuleType(moduleId) && !isCssModules) {
                        return {
                            content,
                            moduleType: 'css'
                        };
                    }
                    return {
                        content,
                        moduleType
                    };
                }
            }
        };
    }
}
,
"1e6e5b87":function  (module, exports, farmRequire, farmDynamicRequire) {
    var httpProxy = module.exports, extend = global.nodeRequire('util', true)._extend, parse_url = global.nodeRequire('url', true).parse, EE3 = farmRequire("9f6bd6d5", true), http = global.nodeRequire('http', true), https = global.nodeRequire('https', true), web = farmRequire("49dab30c", true), ws = farmRequire("44b1dcae", true);
    httpProxy.Server = ProxyServer;
    function createRightProxy(type) {
        return function(options) {
            return function(req, res) {
                var passes = type === 'ws' ? this.wsPasses : this.webPasses, args = [].slice.call(arguments), cntr = args.length - 1, head, cbl;
                if (typeof args[cntr] === 'function') {
                    cbl = args[cntr];
                    cntr--;
                }
                var requestOptions = options;
                if (!(args[cntr] instanceof Buffer) && args[cntr] !== res) {
                    requestOptions = extend({}, options);
                    extend(requestOptions, args[cntr]);
                    cntr--;
                }
                if (args[cntr] instanceof Buffer) {
                    head = args[cntr];
                }
                [
                    'target',
                    'forward'
                ].forEach(function(e) {
                    if (typeof requestOptions[e] === 'string') requestOptions[e] = parse_url(requestOptions[e]);
                });
                if (!requestOptions.target && !requestOptions.forward) {
                    return this.emit('error', new Error('Must provide a proper URL as target'));
                }
                for(var i = 0; i < passes.length; i++){
                    if (passes[i](req, res, requestOptions, head, this, cbl)) {
                        break;
                    }
                }
            };
        };
    }
    httpProxy.createRightProxy = createRightProxy;
    function ProxyServer(options) {
        EE3.call(this);
        options = options || {};
        options.prependPath = options.prependPath === false ? false : true;
        this.web = this.proxyRequest = createRightProxy('web')(options);
        this.ws = this.proxyWebsocketRequest = createRightProxy('ws')(options);
        this.options = options;
        this.webPasses = Object.keys(web).map(function(pass) {
            return web[pass];
        });
        this.wsPasses = Object.keys(ws).map(function(pass) {
            return ws[pass];
        });
        this.on('error', this.onError, this);
    }
    global.nodeRequire('util', true).inherits(ProxyServer, EE3);
    ProxyServer.prototype.onError = function(err) {
        if (this.listeners('error').length === 1) {
            throw err;
        }
    };
    ProxyServer.prototype.listen = function(port, hostname) {
        var self = this, closure = function(req, res) {
            self.web(req, res);
        };
        this._server = this.options.ssl ? https.createServer(this.options.ssl, closure) : http.createServer(closure);
        if (this.options.ws) {
            this._server.on('upgrade', function(req, socket, head) {
                self.ws(req, socket, head);
            });
        }
        this._server.listen(port, hostname);
        return this;
    };
    ProxyServer.prototype.close = function(callback) {
        var self = this;
        if (this._server) {
            this._server.close(done);
        }
        function done() {
            self._server = null;
            if (callback) {
                callback.apply(null, arguments);
            }
        }
        ;
    };
    ProxyServer.prototype.before = function(type, passName, callback) {
        if (type !== 'ws' && type !== 'web') {
            throw new Error('type must be `web` or `ws`');
        }
        var passes = type === 'ws' ? this.wsPasses : this.webPasses, i = false;
        passes.forEach(function(v, idx) {
            if (v.name === passName) i = idx;
        });
        if (i === false) throw new Error('No such pass');
        passes.splice(i, 0, callback);
    };
    ProxyServer.prototype.after = function(type, passName, callback) {
        if (type !== 'ws' && type !== 'web') {
            throw new Error('type must be `web` or `ws`');
        }
        var passes = type === 'ws' ? this.wsPasses : this.webPasses, i = false;
        passes.forEach(function(v, idx) {
            if (v.name === passName) i = idx;
        });
        if (i === false) throw new Error('No such pass');
        passes.splice(i++, 0, callback);
    };
}
,
"1eccf3e8":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const path = global.nodeRequire('path', true);
    const scan = farmRequire("c919b93f", true);
    const parse = farmRequire("00c72d38", true);
    const utils = farmRequire("48dceba4", true);
    const constants = farmRequire("685edf14", true);
    const isObject = (val)=>val && typeof val === 'object' && !Array.isArray(val);
    const picomatch = (glob, options, returnState = false)=>{
        if (Array.isArray(glob)) {
            const fns = glob.map((input)=>picomatch(input, options, returnState));
            const arrayMatcher = (str)=>{
                for (const isMatch of fns){
                    const state = isMatch(str);
                    if (state) return state;
                }
                return false;
            };
            return arrayMatcher;
        }
        const isState = isObject(glob) && glob.tokens && glob.input;
        if (glob === '' || typeof glob !== 'string' && !isState) {
            throw new TypeError('Expected pattern to be a non-empty string');
        }
        const opts = options || {};
        const posix = utils.isWindows(options);
        const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
        const state = regex.state;
        delete regex.state;
        let isIgnored = ()=>false;
        if (opts.ignore) {
            const ignoreOpts = {
                ...options,
                ignore: null,
                onMatch: null,
                onResult: null
            };
            isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
        }
        const matcher = (input, returnObject = false)=>{
            const { isMatch, match, output } = picomatch.test(input, regex, options, {
                glob,
                posix
            });
            const result = {
                glob,
                state,
                regex,
                posix,
                input,
                output,
                match,
                isMatch
            };
            if (typeof opts.onResult === 'function') {
                opts.onResult(result);
            }
            if (isMatch === false) {
                result.isMatch = false;
                return returnObject ? result : false;
            }
            if (isIgnored(input)) {
                if (typeof opts.onIgnore === 'function') {
                    opts.onIgnore(result);
                }
                result.isMatch = false;
                return returnObject ? result : false;
            }
            if (typeof opts.onMatch === 'function') {
                opts.onMatch(result);
            }
            return returnObject ? result : true;
        };
        if (returnState) {
            matcher.state = state;
        }
        return matcher;
    };
    picomatch.test = (input, regex, options, { glob, posix } = {})=>{
        if (typeof input !== 'string') {
            throw new TypeError('Expected input to be a string');
        }
        if (input === '') {
            return {
                isMatch: false,
                output: ''
            };
        }
        const opts = options || {};
        const format = opts.format || (posix ? utils.toPosixSlashes : null);
        let match = input === glob;
        let output = match && format ? format(input) : input;
        if (match === false) {
            output = format ? format(input) : input;
            match = output === glob;
        }
        if (match === false || opts.capture === true) {
            if (opts.matchBase === true || opts.basename === true) {
                match = picomatch.matchBase(input, regex, options, posix);
            } else {
                match = regex.exec(output);
            }
        }
        return {
            isMatch: Boolean(match),
            match,
            output
        };
    };
    picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options))=>{
        const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
        return regex.test(path.basename(input));
    };
    picomatch.isMatch = (str, patterns, options)=>picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options)=>{
        if (Array.isArray(pattern)) return pattern.map((p)=>picomatch.parse(p, options));
        return parse(pattern, {
            ...options,
            fastpaths: false
        });
    };
    picomatch.scan = (input, options)=>scan(input, options);
    picomatch.compileRe = (state, options, returnOutput = false, returnState = false)=>{
        if (returnOutput === true) {
            return state.output;
        }
        const opts = options || {};
        const prepend = opts.contains ? '' : '^';
        const append = opts.contains ? '' : '$';
        let source = `${prepend}(?:${state.output})${append}`;
        if (state && state.negated === true) {
            source = `^(?!${source}).*$`;
        }
        const regex = picomatch.toRegex(source, options);
        if (returnState === true) {
            regex.state = state;
        }
        return regex;
    };
    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false)=>{
        if (!input || typeof input !== 'string') {
            throw new TypeError('Expected a non-empty string');
        }
        let parsed = {
            negated: false,
            fastpaths: true
        };
        if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {
            parsed.output = parse.fastpaths(input, options);
        }
        if (!parsed.output) {
            parsed = parse(input, options);
        }
        return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options)=>{
        try {
            const opts = options || {};
            return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));
        } catch (err) {
            if (options && options.debug === true) throw err;
            return /$^/;
        }
    };
    picomatch.constants = constants;
    module.exports = picomatch;
}
,
"1f8eda05":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    var _f_fs = farmRequire('fs');
    var _f_module = farmRequire('module');
    var _f_path = farmRequire('path');
    var _f_url = farmRequire('url');
    const { platform, arch } = process;
    const currentDir = _f_path.dirname(_f_url.fileURLToPath(module.meta.url));
    let binPath = null;
    const require = _f_module.createRequire(module.meta.url);
    function isMusl() {
        if (!process.report || typeof process.report.getReport !== 'function') {
            try {
                return _f_fs.readFileSync('/usr/bin/ldd', 'utf8').includes('musl');
            } catch (e) {
                return true;
            }
        } else {
            const { glibcVersionRuntime } = process.report.getReport().header;
            return !glibcVersionRuntime;
        }
    }
    switch(platform){
        case 'win32':
            switch(arch){
                case 'x64':
                    if (_f_fs.existsSync(_f_path.join(currentDir, '../npm/win32-x64-msvc/index.farm'))) {
                        binPath = _f_path.join(currentDir, '../npm/win32-x64-msvc/index.farm');
                    } else {
                        binPath = require.resolve('farm-plugin-replace-dirname-win32-x64-msvc');
                    }
                    break;
                case 'ia32':
                    if (_f_fs.existsSync(_f_path.join(currentDir, '../npm/win32-ia32-msvc/index.farm'))) {
                        binPath = _f_path.join(currentDir, '../npm/win32-ia32-msvc/index.farm');
                    } else {
                        binPath = require.resolve('farm-plugin-replace-dirname-win32-ia32-msvc');
                    }
                    break;
                case 'arm64':
                    if (_f_fs.existsSync(_f_path.join(currentDir, '../npm/win32-arm64-msvc/index.farm'))) {
                        binPath = _f_path.join(currentDir, '../npm/win32-arm64-msvc/index.farm');
                    } else {
                        binPath = require.resolve('farm-plugin-replace-dirname-win32-arm64-msvc');
                    }
                    break;
                default:
                    throw new Error(`Unsupported architecture on Windows: ${arch}`);
            }
            break;
        case 'darwin':
            switch(arch){
                case 'x64':
                    if (_f_fs.existsSync(_f_path.join(currentDir, '../npm/darwin-x64/index.farm'))) {
                        binPath = _f_path.join(currentDir, '../npm/darwin-x64/index.farm');
                    } else {
                        binPath = require.resolve('farm-plugin-replace-dirname-darwin-x64');
                    }
                    break;
                case 'arm64':
                    if (_f_fs.existsSync(_f_path.join(currentDir, '../npm/darwin-arm64/index.farm'))) {
                        binPath = _f_path.join(currentDir, '../npm/darwin-arm64/index.farm');
                    } else {
                        binPath = require.resolve('farm-plugin-replace-dirname-darwin-arm64');
                    }
                    break;
                default:
                    throw new Error(`Unsupported architecture on macOS: ${arch}`);
            }
            break;
        case 'linux':
            switch(arch){
                case 'x64':
                    if (isMusl()) {
                        if (_f_fs.existsSync(_f_path.join(currentDir, '../npm/linux-x64-musl/index.farm'))) {
                            binPath = _f_path.join(currentDir, '../npm/linux-x64-musl/index.farm');
                        } else {
                            binPath = require.resolve('farm-plugin-replace-dirname-linux-x64-musl');
                        }
                    } else {
                        if (_f_fs.existsSync(_f_path.join(currentDir, '../npm/linux-x64-gnu/index.farm'))) {
                            binPath = _f_path.join(currentDir, '../npm/linux-x64-gnu/index.farm');
                        } else {
                            binPath = require.resolve('farm-plugin-replace-dirname-linux-x64-gnu');
                        }
                    }
                    break;
                case 'arm64':
                    if (isMusl()) {
                        if (_f_fs.existsSync(_f_path.join(currentDir, '../npm/linux-arm64-musl/index.farm'))) {
                            binPath = _f_path.join(currentDir, '../npm/linux-arm64-musl/index.farm');
                        } else {
                            binPath = require.resolve('farm-plugin-replace-dirname-linux-arm64-musl');
                        }
                    } else {
                        if (_f_fs.existsSync(_f_path.join(currentDir, '../npm/linux-arm64-gnu/index.farm'))) {
                            binPath = _f_path.join(currentDir, '../npm/linux-arm64-gnu/index.farm');
                        } else {
                            binPath = require.resolve('farm-plugin-replace-dirname-linux-arm64-gnu');
                        }
                    }
                    break;
                default:
                    throw new Error(`Unsupported architecture on Linux: ${arch}`);
            }
            break;
        default:
            throw new Error(`Unsupported OS: ${platform}, architecture: ${arch}`);
    }
    exports.default = binPath;
}
,
"20fd6809":/*!
 * compressible
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Jeremiah Senkpiel
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    var db = farmRequire("d0446bff", true);
    var COMPRESSIBLE_TYPE_REGEXP = /^text\/|\+(?:json|text|xml)$/i;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    module.exports = compressible;
    function compressible(type) {
        if (!type || typeof type !== 'string') {
            return false;
        }
        var match = EXTRACT_TYPE_REGEXP.exec(type);
        var mime = match && match[1].toLowerCase();
        var data = db[mime];
        if (data && data.compressible !== undefined) {
            return data.compressible;
        }
        return COMPRESSIBLE_TYPE_REGEXP.test(mime) || undefined;
    }
}
,
"214cc0ba":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const fs = farmRequire("ffc819a8", true);
    const path = global.nodeRequire('path', true);
    const mkdirs = farmRequire("abdb8a71", true).mkdirs;
    const pathExists = farmRequire("05a93efb", true).pathExists;
    const utimesMillis = farmRequire("69e53775", true).utimesMillis;
    const stat = farmRequire("9c9fbd11", true);
    function copy(src, dest, opts, cb) {
        if (typeof opts === 'function' && !cb) {
            cb = opts;
            opts = {};
        } else if (typeof opts === 'function') {
            opts = {
                filter: opts
            };
        }
        cb = cb || function() {};
        opts = opts || {};
        opts.clobber = 'clobber' in opts ? !!opts.clobber : true;
        opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber;
        if (opts.preserveTimestamps && process.arch === 'ia32') {
            process.emitWarning('Using the preserveTimestamps option in 32-bit node is not recommended;\n\n' + '\tsee https://github.com/jprichardson/node-fs-extra/issues/269', 'Warning', 'fs-extra-WARN0001');
        }
        stat.checkPaths(src, dest, 'copy', opts, (err, stats)=>{
            if (err) return cb(err);
            const { srcStat, destStat } = stats;
            stat.checkParentPaths(src, srcStat, dest, 'copy', (err)=>{
                if (err) return cb(err);
                runFilter(src, dest, opts, (err, include)=>{
                    if (err) return cb(err);
                    if (!include) return cb();
                    checkParentDir(destStat, src, dest, opts, cb);
                });
            });
        });
    }
    function checkParentDir(destStat, src, dest, opts, cb) {
        const destParent = path.dirname(dest);
        pathExists(destParent, (err, dirExists)=>{
            if (err) return cb(err);
            if (dirExists) return getStats(destStat, src, dest, opts, cb);
            mkdirs(destParent, (err)=>{
                if (err) return cb(err);
                return getStats(destStat, src, dest, opts, cb);
            });
        });
    }
    function runFilter(src, dest, opts, cb) {
        if (!opts.filter) return cb(null, true);
        Promise.resolve(opts.filter(src, dest)).then((include)=>cb(null, include), (error)=>cb(error));
    }
    function getStats(destStat, src, dest, opts, cb) {
        const stat = opts.dereference ? fs.stat : fs.lstat;
        stat(src, (err, srcStat)=>{
            if (err) return cb(err);
            if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb);
            else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb);
            else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb);
            else if (srcStat.isSocket()) return cb(new Error(`Cannot copy a socket file: ${src}`));
            else if (srcStat.isFIFO()) return cb(new Error(`Cannot copy a FIFO pipe: ${src}`));
            return cb(new Error(`Unknown file: ${src}`));
        });
    }
    function onFile(srcStat, destStat, src, dest, opts, cb) {
        if (!destStat) return copyFile(srcStat, src, dest, opts, cb);
        return mayCopyFile(srcStat, src, dest, opts, cb);
    }
    function mayCopyFile(srcStat, src, dest, opts, cb) {
        if (opts.overwrite) {
            fs.unlink(dest, (err)=>{
                if (err) return cb(err);
                return copyFile(srcStat, src, dest, opts, cb);
            });
        } else if (opts.errorOnExist) {
            return cb(new Error(`'${dest}' already exists`));
        } else return cb();
    }
    function copyFile(srcStat, src, dest, opts, cb) {
        fs.copyFile(src, dest, (err)=>{
            if (err) return cb(err);
            if (opts.preserveTimestamps) return handleTimestampsAndMode(srcStat.mode, src, dest, cb);
            return setDestMode(dest, srcStat.mode, cb);
        });
    }
    function handleTimestampsAndMode(srcMode, src, dest, cb) {
        if (fileIsNotWritable(srcMode)) {
            return makeFileWritable(dest, srcMode, (err)=>{
                if (err) return cb(err);
                return setDestTimestampsAndMode(srcMode, src, dest, cb);
            });
        }
        return setDestTimestampsAndMode(srcMode, src, dest, cb);
    }
    function fileIsNotWritable(srcMode) {
        return (srcMode & 0o200) === 0;
    }
    function makeFileWritable(dest, srcMode, cb) {
        return setDestMode(dest, srcMode | 0o200, cb);
    }
    function setDestTimestampsAndMode(srcMode, src, dest, cb) {
        setDestTimestamps(src, dest, (err)=>{
            if (err) return cb(err);
            return setDestMode(dest, srcMode, cb);
        });
    }
    function setDestMode(dest, srcMode, cb) {
        return fs.chmod(dest, srcMode, cb);
    }
    function setDestTimestamps(src, dest, cb) {
        fs.stat(src, (err, updatedSrcStat)=>{
            if (err) return cb(err);
            return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb);
        });
    }
    function onDir(srcStat, destStat, src, dest, opts, cb) {
        if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts, cb);
        return copyDir(src, dest, opts, cb);
    }
    function mkDirAndCopy(srcMode, src, dest, opts, cb) {
        fs.mkdir(dest, (err)=>{
            if (err) return cb(err);
            copyDir(src, dest, opts, (err)=>{
                if (err) return cb(err);
                return setDestMode(dest, srcMode, cb);
            });
        });
    }
    function copyDir(src, dest, opts, cb) {
        fs.readdir(src, (err, items)=>{
            if (err) return cb(err);
            return copyDirItems(items, src, dest, opts, cb);
        });
    }
    function copyDirItems(items, src, dest, opts, cb) {
        const item = items.pop();
        if (!item) return cb();
        return copyDirItem(items, item, src, dest, opts, cb);
    }
    function copyDirItem(items, item, src, dest, opts, cb) {
        const srcItem = path.join(src, item);
        const destItem = path.join(dest, item);
        runFilter(srcItem, destItem, opts, (err, include)=>{
            if (err) return cb(err);
            if (!include) return copyDirItems(items, src, dest, opts, cb);
            stat.checkPaths(srcItem, destItem, 'copy', opts, (err, stats)=>{
                if (err) return cb(err);
                const { destStat } = stats;
                getStats(destStat, srcItem, destItem, opts, (err)=>{
                    if (err) return cb(err);
                    return copyDirItems(items, src, dest, opts, cb);
                });
            });
        });
    }
    function onLink(destStat, src, dest, opts, cb) {
        fs.readlink(src, (err, resolvedSrc)=>{
            if (err) return cb(err);
            if (opts.dereference) {
                resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
            }
            if (!destStat) {
                return fs.symlink(resolvedSrc, dest, cb);
            } else {
                fs.readlink(dest, (err, resolvedDest)=>{
                    if (err) {
                        if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest, cb);
                        return cb(err);
                    }
                    if (opts.dereference) {
                        resolvedDest = path.resolve(process.cwd(), resolvedDest);
                    }
                    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
                        return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
                    }
                    if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
                        return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
                    }
                    return copyLink(resolvedSrc, dest, cb);
                });
            }
        });
    }
    function copyLink(resolvedSrc, dest, cb) {
        fs.unlink(dest, (err)=>{
            if (err) return cb(err);
            return fs.symlink(resolvedSrc, dest, cb);
        });
    }
    module.exports = copy;
}
,
"22ca6445":function  (module, exports, farmRequire, farmDynamicRequire) {
    function stringify(obj, { EOL = '\n', finalEOL = true, replacer = null, spaces } = {}) {
        const EOF = finalEOL ? EOL : '';
        const str = JSON.stringify(obj, replacer, spaces);
        return str.replace(/\n/g, EOL) + EOF;
    }
    function stripBom(content) {
        if (Buffer.isBuffer(content)) content = content.toString('utf8');
        return content.replace(/^\uFEFF/, '');
    }
    module.exports = {
        stringify,
        stripBom
    };
}
,
"2349f859":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.legacyCreateProxyMiddleware = void 0;
    const __1 = farmRequire("d8312835", true);
    const debug_1 = farmRequire("2f90b0a5", true);
    const options_adapter_1 = farmRequire("7ba829d6", true);
    const debug = debug_1.Debug.extend('legacy-create-proxy-middleware');
    function legacyCreateProxyMiddleware(legacyContext, legacyOptions) {
        debug('init');
        const options = (0, options_adapter_1.legacyOptionsAdapter)(legacyContext, legacyOptions);
        const proxyMiddleware = (0, __1.createProxyMiddleware)(options);
        debug('add marker for patching req.url (old behavior)');
        proxyMiddleware.__LEGACY_HTTP_PROXY_MIDDLEWARE__ = true;
        return proxyMiddleware;
    }
    exports.legacyCreateProxyMiddleware = legacyCreateProxyMiddleware;
}
,
"23b38875":function  (module, exports, farmRequire, farmDynamicRequire) {
    const { existsSync, readFileSync } = global.nodeRequire('fs', true);
    const { join } = global.nodeRequire('path', true);
    const { platform, arch } = process;
    let nativeBinding = null;
    let localFileExisted = false;
    let loadError = null;
    function isMusl() {
        if (!process.report || typeof process.report.getReport !== 'function') {
            try {
                const lddPath = global.nodeRequire('child_process').execSync('which ldd').toString().trim();
                return readFileSync(lddPath, 'utf8').includes('musl');
            } catch (e) {
                return true;
            }
        } else {
            const { glibcVersionRuntime } = process.report.getReport().header;
            return !glibcVersionRuntime;
        }
    }
    switch(platform){
        case 'android':
            switch(arch){
                case 'arm64':
                    localFileExisted = existsSync(join(__dirname, 'farm.android-arm64.node'));
                    try {
                        if (localFileExisted) {
                            nativeBinding = global.nodeRequire('./farm.android-arm64.node', true);
                        } else {
                            nativeBinding = global.nodeRequire('@farmfe/core-android-arm64', true);
                        }
                    } catch (e) {
                        loadError = e;
                    }
                    break;
                case 'arm':
                    localFileExisted = existsSync(join(__dirname, 'farm.android-arm-eabi.node'));
                    try {
                        if (localFileExisted) {
                            nativeBinding = global.nodeRequire('./farm.android-arm-eabi.node', true);
                        } else {
                            nativeBinding = global.nodeRequire('@farmfe/core-android-arm-eabi', true);
                        }
                    } catch (e) {
                        loadError = e;
                    }
                    break;
                default:
                    throw new Error(`Unsupported architecture on Android ${arch}`);
            }
            break;
        case 'win32':
            switch(arch){
                case 'x64':
                    localFileExisted = existsSync(join(__dirname, 'farm.win32-x64-msvc.node'));
                    try {
                        if (localFileExisted) {
                            nativeBinding = global.nodeRequire('./farm.win32-x64-msvc.node', true);
                        } else {
                            nativeBinding = global.nodeRequire('@farmfe/core-win32-x64-msvc', true);
                        }
                    } catch (e) {
                        loadError = e;
                    }
                    break;
                case 'ia32':
                    localFileExisted = existsSync(join(__dirname, 'farm.win32-ia32-msvc.node'));
                    try {
                        if (localFileExisted) {
                            nativeBinding = global.nodeRequire('./farm.win32-ia32-msvc.node', true);
                        } else {
                            nativeBinding = global.nodeRequire('@farmfe/core-win32-ia32-msvc', true);
                        }
                    } catch (e) {
                        loadError = e;
                    }
                    break;
                case 'arm64':
                    localFileExisted = existsSync(join(__dirname, 'farm.win32-arm64-msvc.node'));
                    try {
                        if (localFileExisted) {
                            nativeBinding = global.nodeRequire('./farm.win32-arm64-msvc.node', true);
                        } else {
                            nativeBinding = global.nodeRequire('@farmfe/core-win32-arm64-msvc', true);
                        }
                    } catch (e) {
                        loadError = e;
                    }
                    break;
                default:
                    throw new Error(`Unsupported architecture on Windows: ${arch}`);
            }
            break;
        case 'darwin':
            localFileExisted = existsSync(join(__dirname, 'farm.darwin-universal.node'));
            try {
                if (localFileExisted) {
                    nativeBinding = global.nodeRequire('./farm.darwin-universal.node', true);
                } else {
                    nativeBinding = global.nodeRequire('@farmfe/core-darwin-universal', true);
                }
                break;
            } catch  {}
            switch(arch){
                case 'x64':
                    localFileExisted = existsSync(join(__dirname, 'farm.darwin-x64.node'));
                    try {
                        if (localFileExisted) {
                            nativeBinding = global.nodeRequire('./farm.darwin-x64.node', true);
                        } else {
                            nativeBinding = global.nodeRequire('@farmfe/core-darwin-x64', true);
                        }
                    } catch (e) {
                        loadError = e;
                    }
                    break;
                case 'arm64':
                    localFileExisted = existsSync(join(__dirname, 'farm.darwin-arm64.node'));
                    try {
                        if (localFileExisted) {
                            nativeBinding = global.nodeRequire('./farm.darwin-arm64.node', true);
                        } else {
                            nativeBinding = global.nodeRequire('@farmfe/core-darwin-arm64', true);
                        }
                    } catch (e) {
                        loadError = e;
                    }
                    break;
                default:
                    throw new Error(`Unsupported architecture on macOS: ${arch}`);
            }
            break;
        case 'freebsd':
            if (arch !== 'x64') {
                throw new Error(`Unsupported architecture on FreeBSD: ${arch}`);
            }
            localFileExisted = existsSync(join(__dirname, 'farm.freebsd-x64.node'));
            try {
                if (localFileExisted) {
                    nativeBinding = global.nodeRequire('./farm.freebsd-x64.node', true);
                } else {
                    nativeBinding = global.nodeRequire('@farmfe/core-freebsd-x64', true);
                }
            } catch (e) {
                loadError = e;
            }
            break;
        case 'linux':
            switch(arch){
                case 'x64':
                    if (isMusl()) {
                        localFileExisted = existsSync(join(__dirname, 'farm.linux-x64-musl.node'));
                        try {
                            if (localFileExisted) {
                                nativeBinding = global.nodeRequire('./farm.linux-x64-musl.node', true);
                            } else {
                                nativeBinding = global.nodeRequire('@farmfe/core-linux-x64-musl', true);
                            }
                        } catch (e) {
                            loadError = e;
                        }
                    } else {
                        localFileExisted = existsSync(join(__dirname, 'farm.linux-x64-gnu.node'));
                        try {
                            if (localFileExisted) {
                                nativeBinding = global.nodeRequire('./farm.linux-x64-gnu.node', true);
                            } else {
                                nativeBinding = global.nodeRequire('@farmfe/core-linux-x64-gnu', true);
                            }
                        } catch (e) {
                            loadError = e;
                        }
                    }
                    break;
                case 'arm64':
                    if (isMusl()) {
                        localFileExisted = existsSync(join(__dirname, 'farm.linux-arm64-musl.node'));
                        try {
                            if (localFileExisted) {
                                nativeBinding = global.nodeRequire('./farm.linux-arm64-musl.node', true);
                            } else {
                                nativeBinding = global.nodeRequire('@farmfe/core-linux-arm64-musl', true);
                            }
                        } catch (e) {
                            loadError = e;
                        }
                    } else {
                        localFileExisted = existsSync(join(__dirname, 'farm.linux-arm64-gnu.node'));
                        try {
                            if (localFileExisted) {
                                nativeBinding = global.nodeRequire('./farm.linux-arm64-gnu.node', true);
                            } else {
                                nativeBinding = global.nodeRequire('@farmfe/core-linux-arm64-gnu', true);
                            }
                        } catch (e) {
                            loadError = e;
                        }
                    }
                    break;
                case 'arm':
                    if (isMusl()) {
                        localFileExisted = existsSync(join(__dirname, 'farm.linux-arm-musleabihf.node'));
                        try {
                            if (localFileExisted) {
                                nativeBinding = global.nodeRequire('./farm.linux-arm-musleabihf.node', true);
                            } else {
                                nativeBinding = global.nodeRequire('@farmfe/core-linux-arm-musleabihf', true);
                            }
                        } catch (e) {
                            loadError = e;
                        }
                    } else {
                        localFileExisted = existsSync(join(__dirname, 'farm.linux-arm-gnueabihf.node'));
                        try {
                            if (localFileExisted) {
                                nativeBinding = global.nodeRequire('./farm.linux-arm-gnueabihf.node', true);
                            } else {
                                nativeBinding = global.nodeRequire('@farmfe/core-linux-arm-gnueabihf', true);
                            }
                        } catch (e) {
                            loadError = e;
                        }
                    }
                    break;
                case 'riscv64':
                    if (isMusl()) {
                        localFileExisted = existsSync(join(__dirname, 'farm.linux-riscv64-musl.node'));
                        try {
                            if (localFileExisted) {
                                nativeBinding = global.nodeRequire('./farm.linux-riscv64-musl.node', true);
                            } else {
                                nativeBinding = global.nodeRequire('@farmfe/core-linux-riscv64-musl', true);
                            }
                        } catch (e) {
                            loadError = e;
                        }
                    } else {
                        localFileExisted = existsSync(join(__dirname, 'farm.linux-riscv64-gnu.node'));
                        try {
                            if (localFileExisted) {
                                nativeBinding = global.nodeRequire('./farm.linux-riscv64-gnu.node', true);
                            } else {
                                nativeBinding = global.nodeRequire('@farmfe/core-linux-riscv64-gnu', true);
                            }
                        } catch (e) {
                            loadError = e;
                        }
                    }
                    break;
                case 's390x':
                    localFileExisted = existsSync(join(__dirname, 'farm.linux-s390x-gnu.node'));
                    try {
                        if (localFileExisted) {
                            nativeBinding = global.nodeRequire('./farm.linux-s390x-gnu.node', true);
                        } else {
                            nativeBinding = global.nodeRequire('@farmfe/core-linux-s390x-gnu', true);
                        }
                    } catch (e) {
                        loadError = e;
                    }
                    break;
                default:
                    throw new Error(`Unsupported architecture on Linux: ${arch}`);
            }
            break;
        default:
            throw new Error(`Unsupported OS: ${platform}, architecture: ${arch}`);
    }
    if (!nativeBinding) {
        if (loadError) {
            throw loadError;
        }
        throw new Error(`Failed to load native binding`);
    }
    const { JsPluginTransformHtmlHookOrder, Compiler } = nativeBinding;
    module.exports.JsPluginTransformHtmlHookOrder = JsPluginTransformHtmlHookOrder;
    module.exports.Compiler = Compiler;
}
,
"240e7692":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.readdir = exports.readdirWithFileTypes = exports.read = void 0;
    const fsStat = farmRequire("be5cf725", true);
    const rpl = farmRequire("8c243424", true);
    const constants_1 = farmRequire("5dd9d74a", true);
    const utils = farmRequire("a9271465", true);
    const common = farmRequire("8ac9b201", true);
    function read(directory, settings, callback) {
        if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
            readdirWithFileTypes(directory, settings, callback);
            return;
        }
        readdir(directory, settings, callback);
    }
    exports.read = read;
    function readdirWithFileTypes(directory, settings, callback) {
        settings.fs.readdir(directory, {
            withFileTypes: true
        }, (readdirError, dirents)=>{
            if (readdirError !== null) {
                callFailureCallback(callback, readdirError);
                return;
            }
            const entries = dirents.map((dirent)=>({
                    dirent,
                    name: dirent.name,
                    path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
                }));
            if (!settings.followSymbolicLinks) {
                callSuccessCallback(callback, entries);
                return;
            }
            const tasks = entries.map((entry)=>makeRplTaskEntry(entry, settings));
            rpl(tasks, (rplError, rplEntries)=>{
                if (rplError !== null) {
                    callFailureCallback(callback, rplError);
                    return;
                }
                callSuccessCallback(callback, rplEntries);
            });
        });
    }
    exports.readdirWithFileTypes = readdirWithFileTypes;
    function makeRplTaskEntry(entry, settings) {
        return (done)=>{
            if (!entry.dirent.isSymbolicLink()) {
                done(null, entry);
                return;
            }
            settings.fs.stat(entry.path, (statError, stats)=>{
                if (statError !== null) {
                    if (settings.throwErrorOnBrokenSymbolicLink) {
                        done(statError);
                        return;
                    }
                    done(null, entry);
                    return;
                }
                entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
                done(null, entry);
            });
        };
    }
    function readdir(directory, settings, callback) {
        settings.fs.readdir(directory, (readdirError, names)=>{
            if (readdirError !== null) {
                callFailureCallback(callback, readdirError);
                return;
            }
            const tasks = names.map((name)=>{
                const path = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
                return (done)=>{
                    fsStat.stat(path, settings.fsStatSettings, (error, stats)=>{
                        if (error !== null) {
                            done(error);
                            return;
                        }
                        const entry = {
                            name,
                            path,
                            dirent: utils.fs.createDirentFromStats(name, stats)
                        };
                        if (settings.stats) {
                            entry.stats = stats;
                        }
                        done(null, entry);
                    });
                };
            });
            rpl(tasks, (rplError, entries)=>{
                if (rplError !== null) {
                    callFailureCallback(callback, rplError);
                    return;
                }
                callSuccessCallback(callback, entries);
            });
        });
    }
    exports.readdir = readdir;
    function callFailureCallback(callback, error) {
        callback(error);
    }
    function callSuccessCallback(callback, result) {
        callback(null, result);
    }
}
,
"241f157a":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const EventEmitter = global.nodeRequire('events', true);
    const http = global.nodeRequire('http', true);
    const { Duplex } = global.nodeRequire('stream', true);
    const { createHash } = global.nodeRequire('crypto', true);
    const extension = farmRequire("e7a96878", true);
    const PerMessageDeflate = farmRequire("6e9f2004", true);
    const subprotocol = farmRequire("bdb95f7e", true);
    const WebSocket = farmRequire("e4009425", true);
    const { GUID, kWebSocket } = farmRequire("75844d1d", true);
    const keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    const RUNNING = 0;
    const CLOSING = 1;
    const CLOSED = 2;
    class WebSocketServer extends EventEmitter {
        constructor(options, callback){
            super();
            options = {
                maxPayload: 100 * 1024 * 1024,
                skipUTF8Validation: false,
                perMessageDeflate: false,
                handleProtocols: null,
                clientTracking: true,
                verifyClient: null,
                noServer: false,
                backlog: null,
                server: null,
                host: null,
                path: null,
                port: null,
                WebSocket,
                ...options
            };
            if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
                throw new TypeError('One and only one of the "port", "server", or "noServer" options ' + 'must be specified');
            }
            if (options.port != null) {
                this._server = http.createServer((req, res)=>{
                    const body = http.STATUS_CODES[426];
                    res.writeHead(426, {
                        'Content-Length': body.length,
                        'Content-Type': 'text/plain'
                    });
                    res.end(body);
                });
                this._server.listen(options.port, options.host, options.backlog, callback);
            } else if (options.server) {
                this._server = options.server;
            }
            if (this._server) {
                const emitConnection = this.emit.bind(this, 'connection');
                this._removeListeners = addListeners(this._server, {
                    listening: this.emit.bind(this, 'listening'),
                    error: this.emit.bind(this, 'error'),
                    upgrade: (req, socket, head)=>{
                        this.handleUpgrade(req, socket, head, emitConnection);
                    }
                });
            }
            if (options.perMessageDeflate === true) options.perMessageDeflate = {};
            if (options.clientTracking) {
                this.clients = new Set();
                this._shouldEmitClose = false;
            }
            this.options = options;
            this._state = RUNNING;
        }
        address() {
            if (this.options.noServer) {
                throw new Error('The server is operating in "noServer" mode');
            }
            if (!this._server) return null;
            return this._server.address();
        }
        close(cb) {
            if (this._state === CLOSED) {
                if (cb) {
                    this.once('close', ()=>{
                        cb(new Error('The server is not running'));
                    });
                }
                process.nextTick(emitClose, this);
                return;
            }
            if (cb) this.once('close', cb);
            if (this._state === CLOSING) return;
            this._state = CLOSING;
            if (this.options.noServer || this.options.server) {
                if (this._server) {
                    this._removeListeners();
                    this._removeListeners = this._server = null;
                }
                if (this.clients) {
                    if (!this.clients.size) {
                        process.nextTick(emitClose, this);
                    } else {
                        this._shouldEmitClose = true;
                    }
                } else {
                    process.nextTick(emitClose, this);
                }
            } else {
                const server = this._server;
                this._removeListeners();
                this._removeListeners = this._server = null;
                server.close(()=>{
                    emitClose(this);
                });
            }
        }
        shouldHandle(req) {
            if (this.options.path) {
                const index = req.url.indexOf('?');
                const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
                if (pathname !== this.options.path) return false;
            }
            return true;
        }
        handleUpgrade(req, socket, head, cb) {
            socket.on('error', socketOnError);
            const key = req.headers['sec-websocket-key'];
            const version = +req.headers['sec-websocket-version'];
            if (req.method !== 'GET') {
                const message = 'Invalid HTTP method';
                abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
                return;
            }
            if (req.headers.upgrade.toLowerCase() !== 'websocket') {
                const message = 'Invalid Upgrade header';
                abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
                return;
            }
            if (!key || !keyRegex.test(key)) {
                const message = 'Missing or invalid Sec-WebSocket-Key header';
                abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
                return;
            }
            if (version !== 8 && version !== 13) {
                const message = 'Missing or invalid Sec-WebSocket-Version header';
                abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
                return;
            }
            if (!this.shouldHandle(req)) {
                abortHandshake(socket, 400);
                return;
            }
            const secWebSocketProtocol = req.headers['sec-websocket-protocol'];
            let protocols = new Set();
            if (secWebSocketProtocol !== undefined) {
                try {
                    protocols = subprotocol.parse(secWebSocketProtocol);
                } catch (err) {
                    const message = 'Invalid Sec-WebSocket-Protocol header';
                    abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
                    return;
                }
            }
            const secWebSocketExtensions = req.headers['sec-websocket-extensions'];
            const extensions = {};
            if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {
                const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
                try {
                    const offers = extension.parse(secWebSocketExtensions);
                    if (offers[PerMessageDeflate.extensionName]) {
                        perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
                        extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
                    }
                } catch (err) {
                    const message = 'Invalid or unacceptable Sec-WebSocket-Extensions header';
                    abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
                    return;
                }
            }
            if (this.options.verifyClient) {
                const info = {
                    origin: req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
                    secure: !!(req.socket.authorized || req.socket.encrypted),
                    req
                };
                if (this.options.verifyClient.length === 2) {
                    this.options.verifyClient(info, (verified, code, message, headers)=>{
                        if (!verified) {
                            return abortHandshake(socket, code || 401, message, headers);
                        }
                        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
                    });
                    return;
                }
                if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
            }
            this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
        }
        completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
            if (!socket.readable || !socket.writable) return socket.destroy();
            if (socket[kWebSocket]) {
                throw new Error('server.handleUpgrade() was called more than once with the same ' + 'socket, possibly due to a misconfiguration');
            }
            if (this._state > RUNNING) return abortHandshake(socket, 503);
            const digest = createHash('sha1').update(key + GUID).digest('base64');
            const headers = [
                'HTTP/1.1 101 Switching Protocols',
                'Upgrade: websocket',
                'Connection: Upgrade',
                `Sec-WebSocket-Accept: ${digest}`
            ];
            const ws = new this.options.WebSocket(null);
            if (protocols.size) {
                const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
                if (protocol) {
                    headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
                    ws._protocol = protocol;
                }
            }
            if (extensions[PerMessageDeflate.extensionName]) {
                const params = extensions[PerMessageDeflate.extensionName].params;
                const value = extension.format({
                    [PerMessageDeflate.extensionName]: [
                        params
                    ]
                });
                headers.push(`Sec-WebSocket-Extensions: ${value}`);
                ws._extensions = extensions;
            }
            this.emit('headers', headers, req);
            socket.write(headers.concat('\r\n').join('\r\n'));
            socket.removeListener('error', socketOnError);
            ws.setSocket(socket, head, {
                maxPayload: this.options.maxPayload,
                skipUTF8Validation: this.options.skipUTF8Validation
            });
            if (this.clients) {
                this.clients.add(ws);
                ws.on('close', ()=>{
                    this.clients.delete(ws);
                    if (this._shouldEmitClose && !this.clients.size) {
                        process.nextTick(emitClose, this);
                    }
                });
            }
            cb(ws, req);
        }
    }
    module.exports = WebSocketServer;
    function addListeners(server, map) {
        for (const event of Object.keys(map))server.on(event, map[event]);
        return function removeListeners() {
            for (const event of Object.keys(map)){
                server.removeListener(event, map[event]);
            }
        };
    }
    function emitClose(server) {
        server._state = CLOSED;
        server.emit('close');
    }
    function socketOnError() {
        this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
        message = message || http.STATUS_CODES[code];
        headers = {
            Connection: 'close',
            'Content-Type': 'text/html',
            'Content-Length': Buffer.byteLength(message),
            ...headers
        };
        socket.once('finish', socket.destroy);
        socket.end(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` + Object.keys(headers).map((h)=>`${h}: ${headers[h]}`).join('\r\n') + '\r\n\r\n' + message);
    }
    function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
        if (server.listenerCount('wsClientError')) {
            const err = new Error(message);
            Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
            server.emit('wsClientError', err, socket, req);
        } else {
            abortHandshake(socket, code, message);
        }
    }
}
,
"24c29448":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.removeDuplicateSlashes = exports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;
    const path = global.nodeRequire("path", true);
    const globParent = farmRequire("c3ca2b6a", true);
    const micromatch = farmRequire("0de2fb33", true);
    const GLOBSTAR = '**';
    const ESCAPE_SYMBOL = '\\';
    const COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
    const REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[[^[]*]/;
    const REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/;
    const GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\([^(]*\)/;
    const BRACE_EXPANSION_SEPARATORS_RE = /,|\.\./;
    const DOUBLE_SLASH_RE = /(?!^)\/{2,}/g;
    function isStaticPattern(pattern, options = {}) {
        return !isDynamicPattern(pattern, options);
    }
    exports.isStaticPattern = isStaticPattern;
    function isDynamicPattern(pattern, options = {}) {
        if (pattern === '') {
            return false;
        }
        if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {
            return true;
        }
        if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
            return true;
        }
        if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
            return true;
        }
        if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {
            return true;
        }
        return false;
    }
    exports.isDynamicPattern = isDynamicPattern;
    function hasBraceExpansion(pattern) {
        const openingBraceIndex = pattern.indexOf('{');
        if (openingBraceIndex === -1) {
            return false;
        }
        const closingBraceIndex = pattern.indexOf('}', openingBraceIndex + 1);
        if (closingBraceIndex === -1) {
            return false;
        }
        const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);
        return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);
    }
    function convertToPositivePattern(pattern) {
        return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
    }
    exports.convertToPositivePattern = convertToPositivePattern;
    function convertToNegativePattern(pattern) {
        return '!' + pattern;
    }
    exports.convertToNegativePattern = convertToNegativePattern;
    function isNegativePattern(pattern) {
        return pattern.startsWith('!') && pattern[1] !== '(';
    }
    exports.isNegativePattern = isNegativePattern;
    function isPositivePattern(pattern) {
        return !isNegativePattern(pattern);
    }
    exports.isPositivePattern = isPositivePattern;
    function getNegativePatterns(patterns) {
        return patterns.filter(isNegativePattern);
    }
    exports.getNegativePatterns = getNegativePatterns;
    function getPositivePatterns(patterns) {
        return patterns.filter(isPositivePattern);
    }
    exports.getPositivePatterns = getPositivePatterns;
    function getPatternsInsideCurrentDirectory(patterns) {
        return patterns.filter((pattern)=>!isPatternRelatedToParentDirectory(pattern));
    }
    exports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
    function getPatternsOutsideCurrentDirectory(patterns) {
        return patterns.filter(isPatternRelatedToParentDirectory);
    }
    exports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
    function isPatternRelatedToParentDirectory(pattern) {
        return pattern.startsWith('..') || pattern.startsWith('./..');
    }
    exports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
    function getBaseDirectory(pattern) {
        return globParent(pattern, {
            flipBackslashes: false
        });
    }
    exports.getBaseDirectory = getBaseDirectory;
    function hasGlobStar(pattern) {
        return pattern.includes(GLOBSTAR);
    }
    exports.hasGlobStar = hasGlobStar;
    function endsWithSlashGlobStar(pattern) {
        return pattern.endsWith('/' + GLOBSTAR);
    }
    exports.endsWithSlashGlobStar = endsWithSlashGlobStar;
    function isAffectDepthOfReadingPattern(pattern) {
        const basename = path.basename(pattern);
        return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
    }
    exports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
    function expandPatternsWithBraceExpansion(patterns) {
        return patterns.reduce((collection, pattern)=>{
            return collection.concat(expandBraceExpansion(pattern));
        }, []);
    }
    exports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
    function expandBraceExpansion(pattern) {
        const patterns = micromatch.braces(pattern, {
            expand: true,
            nodupes: true,
            keepEscaping: true
        });
        patterns.sort((a, b)=>a.length - b.length);
        return patterns.filter((pattern)=>pattern !== '');
    }
    exports.expandBraceExpansion = expandBraceExpansion;
    function getPatternParts(pattern, options) {
        let { parts } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), {
            parts: true
        }));
        if (parts.length === 0) {
            parts = [
                pattern
            ];
        }
        if (parts[0].startsWith('/')) {
            parts[0] = parts[0].slice(1);
            parts.unshift('');
        }
        return parts;
    }
    exports.getPatternParts = getPatternParts;
    function makeRe(pattern, options) {
        return micromatch.makeRe(pattern, options);
    }
    exports.makeRe = makeRe;
    function convertPatternsToRe(patterns, options) {
        return patterns.map((pattern)=>makeRe(pattern, options));
    }
    exports.convertPatternsToRe = convertPatternsToRe;
    function matchAny(entry, patternsRe) {
        return patternsRe.some((patternRe)=>patternRe.test(entry));
    }
    exports.matchAny = matchAny;
    function removeDuplicateSlashes(pattern) {
        return pattern.replace(DOUBLE_SLASH_RE, '/');
    }
    exports.removeDuplicateSlashes = removeDuplicateSlashes;
}
,
"27f55093":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const fs = global.nodeRequire('fs', true);
    const bigInt = farmRequire("9dd588b5", true);
    const debug = false;
    exports.maxObjectSize = 100 * 1000 * 1000;
    exports.maxObjectCount = 32768;
    const EPOCH = 978307200000;
    const UID = exports.UID = function(id) {
        this.UID = id;
    };
    const parseFile = exports.parseFile = function(fileNameOrBuffer, callback) {
        return new Promise(function(resolve, reject) {
            function tryParseBuffer(buffer) {
                let err = null;
                let result;
                try {
                    result = parseBuffer(buffer);
                    resolve(result);
                } catch (ex) {
                    err = ex;
                    reject(err);
                } finally{
                    if (callback) callback(err, result);
                }
            }
            if (Buffer.isBuffer(fileNameOrBuffer)) {
                return tryParseBuffer(fileNameOrBuffer);
            }
            fs.readFile(fileNameOrBuffer, function(err, data) {
                if (err) {
                    reject(err);
                    return callback(err);
                }
                tryParseBuffer(data);
            });
        });
    };
    const parseBuffer = exports.parseBuffer = function(buffer) {
        const header = buffer.slice(0, 'bplist'.length).toString('utf8');
        if (header !== 'bplist') {
            throw new Error("Invalid binary plist. Expected 'bplist' at offset 0.");
        }
        const trailer = buffer.slice(buffer.length - 32, buffer.length);
        const offsetSize = trailer.readUInt8(6);
        if (debug) {
            console.log("offsetSize: " + offsetSize);
        }
        const objectRefSize = trailer.readUInt8(7);
        if (debug) {
            console.log("objectRefSize: " + objectRefSize);
        }
        const numObjects = readUInt64BE(trailer, 8);
        if (debug) {
            console.log("numObjects: " + numObjects);
        }
        const topObject = readUInt64BE(trailer, 16);
        if (debug) {
            console.log("topObject: " + topObject);
        }
        const offsetTableOffset = readUInt64BE(trailer, 24);
        if (debug) {
            console.log("offsetTableOffset: " + offsetTableOffset);
        }
        if (numObjects > exports.maxObjectCount) {
            throw new Error("maxObjectCount exceeded");
        }
        const offsetTable = [];
        for(let i = 0; i < numObjects; i++){
            const offsetBytes = buffer.slice(offsetTableOffset + i * offsetSize, offsetTableOffset + (i + 1) * offsetSize);
            offsetTable[i] = readUInt(offsetBytes, 0);
            if (debug) {
                console.log("Offset for Object #" + i + " is " + offsetTable[i] + " [" + offsetTable[i].toString(16) + "]");
            }
        }
        function parseObject(tableOffset) {
            const offset = offsetTable[tableOffset];
            const type = buffer[offset];
            const objType = (type & 0xF0) >> 4;
            const objInfo = type & 0x0F;
            switch(objType){
                case 0x0:
                    return parseSimple();
                case 0x1:
                    return parseInteger();
                case 0x8:
                    return parseUID();
                case 0x2:
                    return parseReal();
                case 0x3:
                    return parseDate();
                case 0x4:
                    return parseData();
                case 0x5:
                    return parsePlistString();
                case 0x6:
                    return parsePlistString(true);
                case 0xA:
                    return parseArray();
                case 0xD:
                    return parseDictionary();
                default:
                    throw new Error("Unhandled type 0x" + objType.toString(16));
            }
            function parseSimple() {
                switch(objInfo){
                    case 0x0:
                        return null;
                    case 0x8:
                        return false;
                    case 0x9:
                        return true;
                    case 0xF:
                        return null;
                    default:
                        throw new Error("Unhandled simple type 0x" + objType.toString(16));
                }
            }
            function bufferToHexString(buffer) {
                let str = '';
                let i;
                for(i = 0; i < buffer.length; i++){
                    if (buffer[i] != 0x00) {
                        break;
                    }
                }
                for(; i < buffer.length; i++){
                    const part = '00' + buffer[i].toString(16);
                    str += part.substr(part.length - 2);
                }
                return str;
            }
            function parseInteger() {
                const length = Math.pow(2, objInfo);
                if (objInfo == 0x4) {
                    const data = buffer.slice(offset + 1, offset + 1 + length);
                    const str = bufferToHexString(data);
                    return bigInt(str, 16);
                }
                if (objInfo == 0x3) {
                    return buffer.readInt32BE(offset + 1);
                }
                if (length < exports.maxObjectSize) {
                    return readUInt(buffer.slice(offset + 1, offset + 1 + length));
                }
                throw new Error("To little heap space available! Wanted to read " + length + " bytes, but only " + exports.maxObjectSize + " are available.");
            }
            function parseUID() {
                const length = objInfo + 1;
                if (length < exports.maxObjectSize) {
                    return new UID(readUInt(buffer.slice(offset + 1, offset + 1 + length)));
                }
                throw new Error("To little heap space available! Wanted to read " + length + " bytes, but only " + exports.maxObjectSize + " are available.");
            }
            function parseReal() {
                const length = Math.pow(2, objInfo);
                if (length < exports.maxObjectSize) {
                    const realBuffer = buffer.slice(offset + 1, offset + 1 + length);
                    if (length === 4) {
                        return realBuffer.readFloatBE(0);
                    }
                    if (length === 8) {
                        return realBuffer.readDoubleBE(0);
                    }
                } else {
                    throw new Error("To little heap space available! Wanted to read " + length + " bytes, but only " + exports.maxObjectSize + " are available.");
                }
            }
            function parseDate() {
                if (objInfo != 0x3) {
                    console.error("Unknown date type :" + objInfo + ". Parsing anyway...");
                }
                const dateBuffer = buffer.slice(offset + 1, offset + 9);
                return new Date(EPOCH + 1000 * dateBuffer.readDoubleBE(0));
            }
            function parseData() {
                let dataoffset = 1;
                let length = objInfo;
                if (objInfo == 0xF) {
                    const int_type = buffer[offset + 1];
                    const intType = (int_type & 0xF0) / 0x10;
                    if (intType != 0x1) {
                        console.error("0x4: UNEXPECTED LENGTH-INT TYPE! " + intType);
                    }
                    const intInfo = int_type & 0x0F;
                    const intLength = Math.pow(2, intInfo);
                    dataoffset = 2 + intLength;
                    if (intLength < 3) {
                        length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));
                    } else {
                        length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));
                    }
                }
                if (length < exports.maxObjectSize) {
                    return buffer.slice(offset + dataoffset, offset + dataoffset + length);
                }
                throw new Error("To little heap space available! Wanted to read " + length + " bytes, but only " + exports.maxObjectSize + " are available.");
            }
            function parsePlistString(isUtf16) {
                isUtf16 = isUtf16 || 0;
                let enc = "utf8";
                let length = objInfo;
                let stroffset = 1;
                if (objInfo == 0xF) {
                    const int_type = buffer[offset + 1];
                    const intType = (int_type & 0xF0) / 0x10;
                    if (intType != 0x1) {
                        console.err("UNEXPECTED LENGTH-INT TYPE! " + intType);
                    }
                    const intInfo = int_type & 0x0F;
                    const intLength = Math.pow(2, intInfo);
                    stroffset = 2 + intLength;
                    if (intLength < 3) {
                        length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));
                    } else {
                        length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));
                    }
                }
                length *= isUtf16 + 1;
                if (length < exports.maxObjectSize) {
                    let plistString = Buffer.from(buffer.slice(offset + stroffset, offset + stroffset + length));
                    if (isUtf16) {
                        plistString = swapBytes(plistString);
                        enc = "ucs2";
                    }
                    return plistString.toString(enc);
                }
                throw new Error("To little heap space available! Wanted to read " + length + " bytes, but only " + exports.maxObjectSize + " are available.");
            }
            function parseArray() {
                let length = objInfo;
                let arrayoffset = 1;
                if (objInfo == 0xF) {
                    const int_type = buffer[offset + 1];
                    const intType = (int_type & 0xF0) / 0x10;
                    if (intType != 0x1) {
                        console.error("0xa: UNEXPECTED LENGTH-INT TYPE! " + intType);
                    }
                    const intInfo = int_type & 0x0F;
                    const intLength = Math.pow(2, intInfo);
                    arrayoffset = 2 + intLength;
                    if (intLength < 3) {
                        length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));
                    } else {
                        length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));
                    }
                }
                if (length * objectRefSize > exports.maxObjectSize) {
                    throw new Error("To little heap space available!");
                }
                const array = [];
                for(let i = 0; i < length; i++){
                    const objRef = readUInt(buffer.slice(offset + arrayoffset + i * objectRefSize, offset + arrayoffset + (i + 1) * objectRefSize));
                    array[i] = parseObject(objRef);
                }
                return array;
            }
            function parseDictionary() {
                let length = objInfo;
                let dictoffset = 1;
                if (objInfo == 0xF) {
                    const int_type = buffer[offset + 1];
                    const intType = (int_type & 0xF0) / 0x10;
                    if (intType != 0x1) {
                        console.error("0xD: UNEXPECTED LENGTH-INT TYPE! " + intType);
                    }
                    const intInfo = int_type & 0x0F;
                    const intLength = Math.pow(2, intInfo);
                    dictoffset = 2 + intLength;
                    if (intLength < 3) {
                        length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));
                    } else {
                        length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));
                    }
                }
                if (length * 2 * objectRefSize > exports.maxObjectSize) {
                    throw new Error("To little heap space available!");
                }
                if (debug) {
                    console.log("Parsing dictionary #" + tableOffset);
                }
                const dict = {};
                for(let i = 0; i < length; i++){
                    const keyRef = readUInt(buffer.slice(offset + dictoffset + i * objectRefSize, offset + dictoffset + (i + 1) * objectRefSize));
                    const valRef = readUInt(buffer.slice(offset + dictoffset + length * objectRefSize + i * objectRefSize, offset + dictoffset + length * objectRefSize + (i + 1) * objectRefSize));
                    const key = parseObject(keyRef);
                    const val = parseObject(valRef);
                    if (debug) {
                        console.log("  DICT #" + tableOffset + ": Mapped " + key + " to " + val);
                    }
                    dict[key] = val;
                }
                return dict;
            }
        }
        return [
            parseObject(topObject)
        ];
    };
    function readUInt(buffer, start) {
        start = start || 0;
        let l = 0;
        for(let i = start; i < buffer.length; i++){
            l <<= 8;
            l |= buffer[i] & 0xFF;
        }
        return l;
    }
    function readUInt64BE(buffer, start) {
        const data = buffer.slice(start, start + 8);
        return data.readUInt32BE(4, 8);
    }
    function swapBytes(buffer) {
        const len = buffer.length;
        for(let i = 0; i < len; i += 2){
            const a = buffer[i];
            buffer[i] = buffer[i + 1];
            buffer[i + 1] = a;
        }
        return buffer;
    }
}
,
"28903419":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.matchPathFilter = void 0;
    const isGlob = farmRequire("d0830e44", true);
    const micromatch = farmRequire("0de2fb33", true);
    const url = global.nodeRequire("url", true);
    const errors_1 = farmRequire("12559428", true);
    function matchPathFilter(pathFilter = '/', uri, req) {
        if (isStringPath(pathFilter)) {
            return matchSingleStringPath(pathFilter, uri);
        }
        if (isGlobPath(pathFilter)) {
            return matchSingleGlobPath(pathFilter, uri);
        }
        if (Array.isArray(pathFilter)) {
            if (pathFilter.every(isStringPath)) {
                return matchMultiPath(pathFilter, uri);
            }
            if (pathFilter.every(isGlobPath)) {
                return matchMultiGlobPath(pathFilter, uri);
            }
            throw new Error(errors_1.ERRORS.ERR_CONTEXT_MATCHER_INVALID_ARRAY);
        }
        if (typeof pathFilter === 'function') {
            const pathname = getUrlPathName(uri);
            return pathFilter(pathname, req);
        }
        throw new Error(errors_1.ERRORS.ERR_CONTEXT_MATCHER_GENERIC);
    }
    exports.matchPathFilter = matchPathFilter;
    function matchSingleStringPath(pathFilter, uri) {
        const pathname = getUrlPathName(uri);
        return pathname?.indexOf(pathFilter) === 0;
    }
    function matchSingleGlobPath(pattern, uri) {
        const pathname = getUrlPathName(uri);
        const matches = micromatch([
            pathname
        ], pattern);
        return matches && matches.length > 0;
    }
    function matchMultiGlobPath(patternList, uri) {
        return matchSingleGlobPath(patternList, uri);
    }
    function matchMultiPath(pathFilterList, uri) {
        let isMultiPath = false;
        for (const context of pathFilterList){
            if (matchSingleStringPath(context, uri)) {
                isMultiPath = true;
                break;
            }
        }
        return isMultiPath;
    }
    function getUrlPathName(uri) {
        return uri && url.parse(uri).pathname;
    }
    function isStringPath(pathFilter) {
        return typeof pathFilter === 'string' && !isGlob(pathFilter);
    }
    function isGlobPath(pathFilter) {
        return isGlob(pathFilter);
    }
}
,
"28e36a2d":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "VITE_DEFAULT_ASSETS", ()=>VITE_DEFAULT_ASSETS);
    module.o(exports, "VITE_ADAPTER_VIRTUAL_MODULE", ()=>VITE_ADAPTER_VIRTUAL_MODULE);
    module.o(exports, "VITE_EXTERNAL_KEYS", ()=>VITE_EXTERNAL_KEYS);
    module.o(exports, "RESERVED_OBJECT_PROPERTIES", ()=>RESERVED_OBJECT_PROPERTIES);
    module.o(exports, "EXTERNAL_KEYS", ()=>EXTERNAL_KEYS);
    var VITE_DEFAULT_ASSETS = [
        'apng',
        'png',
        'jpe?g',
        'jfif',
        'pjpeg',
        'pjp',
        'gif',
        'svg',
        'ico',
        'webp',
        'avif',
        'mp4',
        'webm',
        'ogg',
        'mp3',
        'wav',
        'flac',
        'aac',
        'opus',
        'mov',
        'm4a',
        'vtt',
        'woff2?',
        'eot',
        'ttf',
        'otf',
        'webmanifest',
        'pdf',
        'txt'
    ];
    var VITE_ADAPTER_VIRTUAL_MODULE = 'vite-adapter-virtual:';
    var VITE_EXTERNAL_KEYS = [
        'esbuild'
    ];
    var RESERVED_OBJECT_PROPERTIES = [
        'then',
        'length',
        'constructor',
        'prototype'
    ];
    var EXTERNAL_KEYS = [
        ...VITE_EXTERNAL_KEYS,
        ...RESERVED_OBJECT_PROPERTIES
    ];
}
,
"290c4885":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const { createFile, createFileSync } = farmRequire("fb675039", true);
    const { createLink, createLinkSync } = farmRequire("77e5a0f9", true);
    const { createSymlink, createSymlinkSync } = farmRequire("ec8939b7", true);
    module.exports = {
        createFile,
        createFileSync,
        ensureFile: createFile,
        ensureFileSync: createFileSync,
        createLink,
        createLinkSync,
        ensureLink: createLink,
        ensureLinkSync: createLinkSync,
        createSymlink,
        createSymlinkSync,
        ensureSymlink: createSymlink,
        ensureSymlinkSync: createSymlinkSync
    };
}
,
"29769a7a":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    exports.isInteger = (num)=>{
        if (typeof num === 'number') {
            return Number.isInteger(num);
        }
        if (typeof num === 'string' && num.trim() !== '') {
            return Number.isInteger(Number(num));
        }
        return false;
    };
    exports.find = (node, type)=>node.nodes.find((node)=>node.type === type);
    exports.exceedsLimit = (min, max, step = 1, limit)=>{
        if (limit === false) return false;
        if (!exports.isInteger(min) || !exports.isInteger(max)) return false;
        return (Number(max) - Number(min)) / Number(step) >= limit;
    };
    exports.escapeNode = (block, n = 0, type)=>{
        let node = block.nodes[n];
        if (!node) return;
        if (type && node.type === type || node.type === 'open' || node.type === 'close') {
            if (node.escaped !== true) {
                node.value = '\\' + node.value;
                node.escaped = true;
            }
        }
    };
    exports.encloseBrace = (node)=>{
        if (node.type !== 'brace') return false;
        if (node.commas >> 0 + node.ranges >> 0 === 0) {
            node.invalid = true;
            return true;
        }
        return false;
    };
    exports.isInvalidBrace = (block)=>{
        if (block.type !== 'brace') return false;
        if (block.invalid === true || block.dollar) return true;
        if (block.commas >> 0 + block.ranges >> 0 === 0) {
            block.invalid = true;
            return true;
        }
        if (block.open !== true || block.close !== true) {
            block.invalid = true;
            return true;
        }
        return false;
    };
    exports.isOpenOrClose = (node)=>{
        if (node.type === 'open' || node.type === 'close') {
            return true;
        }
        return node.open === true || node.close === true;
    };
    exports.reduce = (nodes)=>nodes.reduce((acc, node)=>{
            if (node.type === 'text') acc.push(node.value);
            if (node.type === 'range') node.type = 'text';
            return acc;
        }, []);
    exports.flatten = (...args)=>{
        const result = [];
        const flat = (arr)=>{
            for(let i = 0; i < arr.length; i++){
                let ele = arr[i];
                Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
            }
            return result;
        };
        flat(args);
        return result;
    };
}
,
"29f9909f":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    module.exports = Object.setPrototypeOf || (({
        __proto__: []
    }) instanceof Array ? setProtoOf : mixinProperties);
    function setProtoOf(obj, proto) {
        obj.__proto__ = proto;
        return obj;
    }
    function mixinProperties(obj, proto) {
        for(var prop in proto){
            if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
                obj[prop] = proto[prop];
            }
        }
        return obj;
    }
}
,
"2a212bb3":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.debugProxyErrorsPlugin = void 0;
    const debug_1 = farmRequire("2f90b0a5", true);
    const debug = debug_1.Debug.extend('debug-proxy-errors-plugin');
    const debugProxyErrorsPlugin = (proxyServer)=>{
        proxyServer.on('error', (error, req, res, target)=>{
            debug(`http-proxy error event: \n%O`, error);
        });
        proxyServer.on('proxyReq', (proxyReq, req, socket)=>{
            socket.on('error', (error)=>{
                debug('Socket error in proxyReq event: \n%O', error);
            });
        });
        proxyServer.on('proxyRes', (proxyRes, req, res)=>{
            res.on('close', ()=>{
                if (!res.writableEnded) {
                    debug('Destroying proxyRes in proxyRes close event');
                    proxyRes.destroy();
                }
            });
        });
        proxyServer.on('proxyReqWs', (proxyReq, req, socket)=>{
            socket.on('error', (error)=>{
                debug('Socket error in proxyReqWs event: \n%O', error);
            });
        });
        proxyServer.on('open', (proxySocket)=>{
            proxySocket.on('error', (error)=>{
                debug('Socket error in open event: \n%O', error);
            });
        });
        proxyServer.on('close', (req, socket, head)=>{
            socket.on('error', (error)=>{
                debug('Socket error in close event: \n%O', error);
            });
        });
        proxyServer.on('econnreset', (error, req, res, target)=>{
            debug(`http-proxy econnreset event: \n%O`, error);
        });
    };
    exports.debugProxyErrorsPlugin = debugProxyErrorsPlugin;
}
,
"2ab36b81":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    module.exports = (input)=>{
        const LF = typeof input === 'string' ? '\n' : '\n'.charCodeAt();
        const CR = typeof input === 'string' ? '\r' : '\r'.charCodeAt();
        if (input[input.length - 1] === LF) {
            input = input.slice(0, input.length - 1);
        }
        if (input[input.length - 1] === CR) {
            input = input.slice(0, input.length - 1);
        }
        return input;
    };
}
,
"2ae89d77":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.SIGNALS = void 0;
    const SIGNALS = [
        {
            name: "SIGHUP",
            number: 1,
            action: "terminate",
            description: "Terminal closed",
            standard: "posix"
        },
        {
            name: "SIGINT",
            number: 2,
            action: "terminate",
            description: "User interruption with CTRL-C",
            standard: "ansi"
        },
        {
            name: "SIGQUIT",
            number: 3,
            action: "core",
            description: "User interruption with CTRL-\\",
            standard: "posix"
        },
        {
            name: "SIGILL",
            number: 4,
            action: "core",
            description: "Invalid machine instruction",
            standard: "ansi"
        },
        {
            name: "SIGTRAP",
            number: 5,
            action: "core",
            description: "Debugger breakpoint",
            standard: "posix"
        },
        {
            name: "SIGABRT",
            number: 6,
            action: "core",
            description: "Aborted",
            standard: "ansi"
        },
        {
            name: "SIGIOT",
            number: 6,
            action: "core",
            description: "Aborted",
            standard: "bsd"
        },
        {
            name: "SIGBUS",
            number: 7,
            action: "core",
            description: "Bus error due to misaligned, non-existing address or paging error",
            standard: "bsd"
        },
        {
            name: "SIGEMT",
            number: 7,
            action: "terminate",
            description: "Command should be emulated but is not implemented",
            standard: "other"
        },
        {
            name: "SIGFPE",
            number: 8,
            action: "core",
            description: "Floating point arithmetic error",
            standard: "ansi"
        },
        {
            name: "SIGKILL",
            number: 9,
            action: "terminate",
            description: "Forced termination",
            standard: "posix",
            forced: true
        },
        {
            name: "SIGUSR1",
            number: 10,
            action: "terminate",
            description: "Application-specific signal",
            standard: "posix"
        },
        {
            name: "SIGSEGV",
            number: 11,
            action: "core",
            description: "Segmentation fault",
            standard: "ansi"
        },
        {
            name: "SIGUSR2",
            number: 12,
            action: "terminate",
            description: "Application-specific signal",
            standard: "posix"
        },
        {
            name: "SIGPIPE",
            number: 13,
            action: "terminate",
            description: "Broken pipe or socket",
            standard: "posix"
        },
        {
            name: "SIGALRM",
            number: 14,
            action: "terminate",
            description: "Timeout or timer",
            standard: "posix"
        },
        {
            name: "SIGTERM",
            number: 15,
            action: "terminate",
            description: "Termination",
            standard: "ansi"
        },
        {
            name: "SIGSTKFLT",
            number: 16,
            action: "terminate",
            description: "Stack is empty or overflowed",
            standard: "other"
        },
        {
            name: "SIGCHLD",
            number: 17,
            action: "ignore",
            description: "Child process terminated, paused or unpaused",
            standard: "posix"
        },
        {
            name: "SIGCLD",
            number: 17,
            action: "ignore",
            description: "Child process terminated, paused or unpaused",
            standard: "other"
        },
        {
            name: "SIGCONT",
            number: 18,
            action: "unpause",
            description: "Unpaused",
            standard: "posix",
            forced: true
        },
        {
            name: "SIGSTOP",
            number: 19,
            action: "pause",
            description: "Paused",
            standard: "posix",
            forced: true
        },
        {
            name: "SIGTSTP",
            number: 20,
            action: "pause",
            description: "Paused using CTRL-Z or \"suspend\"",
            standard: "posix"
        },
        {
            name: "SIGTTIN",
            number: 21,
            action: "pause",
            description: "Background process cannot read terminal input",
            standard: "posix"
        },
        {
            name: "SIGBREAK",
            number: 21,
            action: "terminate",
            description: "User interruption with CTRL-BREAK",
            standard: "other"
        },
        {
            name: "SIGTTOU",
            number: 22,
            action: "pause",
            description: "Background process cannot write to terminal output",
            standard: "posix"
        },
        {
            name: "SIGURG",
            number: 23,
            action: "ignore",
            description: "Socket received out-of-band data",
            standard: "bsd"
        },
        {
            name: "SIGXCPU",
            number: 24,
            action: "core",
            description: "Process timed out",
            standard: "bsd"
        },
        {
            name: "SIGXFSZ",
            number: 25,
            action: "core",
            description: "File too big",
            standard: "bsd"
        },
        {
            name: "SIGVTALRM",
            number: 26,
            action: "terminate",
            description: "Timeout or timer",
            standard: "bsd"
        },
        {
            name: "SIGPROF",
            number: 27,
            action: "terminate",
            description: "Timeout or timer",
            standard: "bsd"
        },
        {
            name: "SIGWINCH",
            number: 28,
            action: "ignore",
            description: "Terminal window size changed",
            standard: "bsd"
        },
        {
            name: "SIGIO",
            number: 29,
            action: "terminate",
            description: "I/O is available",
            standard: "other"
        },
        {
            name: "SIGPOLL",
            number: 29,
            action: "terminate",
            description: "Watched event",
            standard: "other"
        },
        {
            name: "SIGINFO",
            number: 29,
            action: "ignore",
            description: "Request for process information",
            standard: "other"
        },
        {
            name: "SIGPWR",
            number: 30,
            action: "terminate",
            description: "Device running out of power",
            standard: "systemv"
        },
        {
            name: "SIGSYS",
            number: 31,
            action: "core",
            description: "Invalid system call",
            standard: "other"
        },
        {
            name: "SIGUNUSED",
            number: 31,
            action: "terminate",
            description: "Invalid system call",
            standard: "other"
        }
    ];
    exports.SIGNALS = SIGNALS;
}
,
"2b4138b2":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    var isMergeableObject = function isMergeableObject(value) {
        return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
        return !!value && typeof value === 'object';
    }
    function isSpecial(value) {
        var stringValue = Object.prototype.toString.call(value);
        return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;
    function isReactElement(value) {
        return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
        return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
        return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source, options) {
        return target.concat(source).map(function(element) {
            return cloneUnlessOtherwiseSpecified(element, options);
        });
    }
    function getMergeFunction(key, options) {
        if (!options.customMerge) {
            return deepmerge;
        }
        var customMerge = options.customMerge(key);
        return typeof customMerge === 'function' ? customMerge : deepmerge;
    }
    function getEnumerableOwnPropertySymbols(target) {
        return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
            return Object.propertyIsEnumerable.call(target, symbol);
        }) : [];
    }
    function getKeys(target) {
        return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object, property) {
        try {
            return property in object;
        } catch (_) {
            return false;
        }
    }
    function propertyIsUnsafe(target, key) {
        return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
    }
    function mergeObject(target, source, options) {
        var destination = {};
        if (options.isMergeableObject(target)) {
            getKeys(target).forEach(function(key) {
                destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
            });
        }
        getKeys(source).forEach(function(key) {
            if (propertyIsUnsafe(target, key)) {
                return;
            }
            if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
                destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
            } else {
                destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
            }
        });
        return destination;
    }
    function deepmerge(target, source, options) {
        options = options || {};
        options.arrayMerge = options.arrayMerge || defaultArrayMerge;
        options.isMergeableObject = options.isMergeableObject || isMergeableObject;
        options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
        var sourceIsArray = Array.isArray(source);
        var targetIsArray = Array.isArray(target);
        var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
        if (!sourceAndTargetTypesMatch) {
            return cloneUnlessOtherwiseSpecified(source, options);
        } else if (sourceIsArray) {
            return options.arrayMerge(target, source, options);
        } else {
            return mergeObject(target, source, options);
        }
    }
    deepmerge.all = function deepmergeAll(array, options) {
        if (!Array.isArray(array)) {
            throw new Error('first argument should be an array');
        }
        return array.reduce(function(prev, next) {
            return deepmerge(prev, next, options);
        }, {});
    };
    var deepmerge_1 = deepmerge;
    module.exports = deepmerge_1;
}
,
"2b9488fe":function  (module, exports, farmRequire, farmDynamicRequire) {
    function setup(env) {
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = farmRequire("73e7c96d", true);
        createDebug.destroy = destroy;
        Object.keys(env).forEach((key)=>{
            createDebug[key] = env[key];
        });
        createDebug.names = [];
        createDebug.skips = [];
        createDebug.formatters = {};
        function selectColor(namespace) {
            let hash = 0;
            for(let i = 0; i < namespace.length; i++){
                hash = (hash << 5) - hash + namespace.charCodeAt(i);
                hash |= 0;
            }
            return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
        }
        createDebug.selectColor = selectColor;
        function createDebug(namespace) {
            let prevTime;
            let enableOverride = null;
            let namespacesCache;
            let enabledCache;
            function debug(...args) {
                if (!debug.enabled) {
                    return;
                }
                const self = debug;
                const curr = Number(new Date());
                const ms = curr - (prevTime || curr);
                self.diff = ms;
                self.prev = prevTime;
                self.curr = curr;
                prevTime = curr;
                args[0] = createDebug.coerce(args[0]);
                if (typeof args[0] !== 'string') {
                    args.unshift('%O');
                }
                let index = 0;
                args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{
                    if (match === '%%') {
                        return '%';
                    }
                    index++;
                    const formatter = createDebug.formatters[format];
                    if (typeof formatter === 'function') {
                        const val = args[index];
                        match = formatter.call(self, val);
                        args.splice(index, 1);
                        index--;
                    }
                    return match;
                });
                createDebug.formatArgs.call(self, args);
                const logFn = self.log || createDebug.log;
                logFn.apply(self, args);
            }
            debug.namespace = namespace;
            debug.useColors = createDebug.useColors();
            debug.color = createDebug.selectColor(namespace);
            debug.extend = extend;
            debug.destroy = createDebug.destroy;
            Object.defineProperty(debug, 'enabled', {
                enumerable: true,
                configurable: false,
                get: ()=>{
                    if (enableOverride !== null) {
                        return enableOverride;
                    }
                    if (namespacesCache !== createDebug.namespaces) {
                        namespacesCache = createDebug.namespaces;
                        enabledCache = createDebug.enabled(namespace);
                    }
                    return enabledCache;
                },
                set: (v)=>{
                    enableOverride = v;
                }
            });
            if (typeof createDebug.init === 'function') {
                createDebug.init(debug);
            }
            return debug;
        }
        function extend(namespace, delimiter) {
            const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
            newDebug.log = this.log;
            return newDebug;
        }
        function enable(namespaces) {
            createDebug.save(namespaces);
            createDebug.namespaces = namespaces;
            createDebug.names = [];
            createDebug.skips = [];
            let i;
            const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
            const len = split.length;
            for(i = 0; i < len; i++){
                if (!split[i]) {
                    continue;
                }
                namespaces = split[i].replace(/\*/g, '.*?');
                if (namespaces[0] === '-') {
                    createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
                } else {
                    createDebug.names.push(new RegExp('^' + namespaces + '$'));
                }
            }
        }
        function disable() {
            const namespaces = [
                ...createDebug.names.map(toNamespace),
                ...createDebug.skips.map(toNamespace).map((namespace)=>'-' + namespace)
            ].join(',');
            createDebug.enable('');
            return namespaces;
        }
        function enabled(name) {
            if (name[name.length - 1] === '*') {
                return true;
            }
            let i;
            let len;
            for(i = 0, len = createDebug.skips.length; i < len; i++){
                if (createDebug.skips[i].test(name)) {
                    return false;
                }
            }
            for(i = 0, len = createDebug.names.length; i < len; i++){
                if (createDebug.names[i].test(name)) {
                    return true;
                }
            }
            return false;
        }
        function toNamespace(regexp) {
            return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
        }
        function coerce(val) {
            if (val instanceof Error) {
                return val.stack || val.message;
            }
            return val;
        }
        function destroy() {
            console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
        }
        createDebug.enable(createDebug.load());
        return createDebug;
    }
    module.exports = setup;
}
,
"2be17525":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const { EMPTY_BUFFER } = farmRequire("75844d1d", true);
    const FastBuffer = Buffer[Symbol.species];
    function concat(list, totalLength) {
        if (list.length === 0) return EMPTY_BUFFER;
        if (list.length === 1) return list[0];
        const target = Buffer.allocUnsafe(totalLength);
        let offset = 0;
        for(let i = 0; i < list.length; i++){
            const buf = list[i];
            target.set(buf, offset);
            offset += buf.length;
        }
        if (offset < totalLength) {
            return new FastBuffer(target.buffer, target.byteOffset, offset);
        }
        return target;
    }
    function _mask(source, mask, output, offset, length) {
        for(let i = 0; i < length; i++){
            output[offset + i] = source[i] ^ mask[i & 3];
        }
    }
    function _unmask(buffer, mask) {
        for(let i = 0; i < buffer.length; i++){
            buffer[i] ^= mask[i & 3];
        }
    }
    function toArrayBuffer(buf) {
        if (buf.length === buf.buffer.byteLength) {
            return buf.buffer;
        }
        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
    }
    function toBuffer(data) {
        toBuffer.readOnly = true;
        if (Buffer.isBuffer(data)) return data;
        let buf;
        if (data instanceof ArrayBuffer) {
            buf = new FastBuffer(data);
        } else if (ArrayBuffer.isView(data)) {
            buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
        } else {
            buf = Buffer.from(data);
            toBuffer.readOnly = false;
        }
        return buf;
    }
    module.exports = {
        concat,
        mask: _mask,
        toArrayBuffer,
        toBuffer,
        unmask: _unmask
    };
    if (!process.env.WS_NO_BUFFER_UTIL) {
        try {
            const bufferUtil = farmRequire("6d2efa8f", true);
            module.exports.mask = function(source, mask, output, offset, length) {
                if (length < 48) _mask(source, mask, output, offset, length);
                else bufferUtil.mask(source, mask, output, offset, length);
            };
            module.exports.unmask = function(buffer, mask) {
                if (buffer.length < 32) _unmask(buffer, mask);
                else bufferUtil.unmask(buffer, mask);
            };
        } catch (e) {}
    }
}
,
"2d715367":function  (module, exports, farmRequire, farmDynamicRequire) {
    module.exports = {
        "application/1d-interleaved-parityfec": {
            "source": "iana"
        },
        "application/3gpdash-qoe-report+xml": {
            "source": "iana",
            "charset": "UTF-8",
            "compressible": true
        },
        "application/3gpp-ims+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/3gpphal+json": {
            "source": "iana",
            "compressible": true
        },
        "application/3gpphalforms+json": {
            "source": "iana",
            "compressible": true
        },
        "application/a2l": {
            "source": "iana"
        },
        "application/ace+cbor": {
            "source": "iana"
        },
        "application/activemessage": {
            "source": "iana"
        },
        "application/activity+json": {
            "source": "iana",
            "compressible": true
        },
        "application/alto-costmap+json": {
            "source": "iana",
            "compressible": true
        },
        "application/alto-costmapfilter+json": {
            "source": "iana",
            "compressible": true
        },
        "application/alto-directory+json": {
            "source": "iana",
            "compressible": true
        },
        "application/alto-endpointcost+json": {
            "source": "iana",
            "compressible": true
        },
        "application/alto-endpointcostparams+json": {
            "source": "iana",
            "compressible": true
        },
        "application/alto-endpointprop+json": {
            "source": "iana",
            "compressible": true
        },
        "application/alto-endpointpropparams+json": {
            "source": "iana",
            "compressible": true
        },
        "application/alto-error+json": {
            "source": "iana",
            "compressible": true
        },
        "application/alto-networkmap+json": {
            "source": "iana",
            "compressible": true
        },
        "application/alto-networkmapfilter+json": {
            "source": "iana",
            "compressible": true
        },
        "application/alto-updatestreamcontrol+json": {
            "source": "iana",
            "compressible": true
        },
        "application/alto-updatestreamparams+json": {
            "source": "iana",
            "compressible": true
        },
        "application/aml": {
            "source": "iana"
        },
        "application/andrew-inset": {
            "source": "iana",
            "extensions": [
                "ez"
            ]
        },
        "application/applefile": {
            "source": "iana"
        },
        "application/applixware": {
            "source": "apache",
            "extensions": [
                "aw"
            ]
        },
        "application/at+jwt": {
            "source": "iana"
        },
        "application/atf": {
            "source": "iana"
        },
        "application/atfx": {
            "source": "iana"
        },
        "application/atom+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "atom"
            ]
        },
        "application/atomcat+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "atomcat"
            ]
        },
        "application/atomdeleted+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "atomdeleted"
            ]
        },
        "application/atomicmail": {
            "source": "iana"
        },
        "application/atomsvc+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "atomsvc"
            ]
        },
        "application/atsc-dwd+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "dwd"
            ]
        },
        "application/atsc-dynamic-event-message": {
            "source": "iana"
        },
        "application/atsc-held+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "held"
            ]
        },
        "application/atsc-rdt+json": {
            "source": "iana",
            "compressible": true
        },
        "application/atsc-rsat+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "rsat"
            ]
        },
        "application/atxml": {
            "source": "iana"
        },
        "application/auth-policy+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/bacnet-xdd+zip": {
            "source": "iana",
            "compressible": false
        },
        "application/batch-smtp": {
            "source": "iana"
        },
        "application/bdoc": {
            "compressible": false,
            "extensions": [
                "bdoc"
            ]
        },
        "application/beep+xml": {
            "source": "iana",
            "charset": "UTF-8",
            "compressible": true
        },
        "application/calendar+json": {
            "source": "iana",
            "compressible": true
        },
        "application/calendar+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "xcs"
            ]
        },
        "application/call-completion": {
            "source": "iana"
        },
        "application/cals-1840": {
            "source": "iana"
        },
        "application/captive+json": {
            "source": "iana",
            "compressible": true
        },
        "application/cbor": {
            "source": "iana"
        },
        "application/cbor-seq": {
            "source": "iana"
        },
        "application/cccex": {
            "source": "iana"
        },
        "application/ccmp+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/ccxml+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "ccxml"
            ]
        },
        "application/cdfx+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "cdfx"
            ]
        },
        "application/cdmi-capability": {
            "source": "iana",
            "extensions": [
                "cdmia"
            ]
        },
        "application/cdmi-container": {
            "source": "iana",
            "extensions": [
                "cdmic"
            ]
        },
        "application/cdmi-domain": {
            "source": "iana",
            "extensions": [
                "cdmid"
            ]
        },
        "application/cdmi-object": {
            "source": "iana",
            "extensions": [
                "cdmio"
            ]
        },
        "application/cdmi-queue": {
            "source": "iana",
            "extensions": [
                "cdmiq"
            ]
        },
        "application/cdni": {
            "source": "iana"
        },
        "application/cea": {
            "source": "iana"
        },
        "application/cea-2018+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/cellml+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/cfw": {
            "source": "iana"
        },
        "application/city+json": {
            "source": "iana",
            "compressible": true
        },
        "application/clr": {
            "source": "iana"
        },
        "application/clue+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/clue_info+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/cms": {
            "source": "iana"
        },
        "application/cnrp+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/coap-group+json": {
            "source": "iana",
            "compressible": true
        },
        "application/coap-payload": {
            "source": "iana"
        },
        "application/commonground": {
            "source": "iana"
        },
        "application/conference-info+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/cose": {
            "source": "iana"
        },
        "application/cose-key": {
            "source": "iana"
        },
        "application/cose-key-set": {
            "source": "iana"
        },
        "application/cpl+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "cpl"
            ]
        },
        "application/csrattrs": {
            "source": "iana"
        },
        "application/csta+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/cstadata+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/csvm+json": {
            "source": "iana",
            "compressible": true
        },
        "application/cu-seeme": {
            "source": "apache",
            "extensions": [
                "cu"
            ]
        },
        "application/cwt": {
            "source": "iana"
        },
        "application/cybercash": {
            "source": "iana"
        },
        "application/dart": {
            "compressible": true
        },
        "application/dash+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "mpd"
            ]
        },
        "application/dash-patch+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "mpp"
            ]
        },
        "application/dashdelta": {
            "source": "iana"
        },
        "application/davmount+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "davmount"
            ]
        },
        "application/dca-rft": {
            "source": "iana"
        },
        "application/dcd": {
            "source": "iana"
        },
        "application/dec-dx": {
            "source": "iana"
        },
        "application/dialog-info+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/dicom": {
            "source": "iana"
        },
        "application/dicom+json": {
            "source": "iana",
            "compressible": true
        },
        "application/dicom+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/dii": {
            "source": "iana"
        },
        "application/dit": {
            "source": "iana"
        },
        "application/dns": {
            "source": "iana"
        },
        "application/dns+json": {
            "source": "iana",
            "compressible": true
        },
        "application/dns-message": {
            "source": "iana"
        },
        "application/docbook+xml": {
            "source": "apache",
            "compressible": true,
            "extensions": [
                "dbk"
            ]
        },
        "application/dots+cbor": {
            "source": "iana"
        },
        "application/dskpp+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/dssc+der": {
            "source": "iana",
            "extensions": [
                "dssc"
            ]
        },
        "application/dssc+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "xdssc"
            ]
        },
        "application/dvcs": {
            "source": "iana"
        },
        "application/ecmascript": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "es",
                "ecma"
            ]
        },
        "application/edi-consent": {
            "source": "iana"
        },
        "application/edi-x12": {
            "source": "iana",
            "compressible": false
        },
        "application/edifact": {
            "source": "iana",
            "compressible": false
        },
        "application/efi": {
            "source": "iana"
        },
        "application/elm+json": {
            "source": "iana",
            "charset": "UTF-8",
            "compressible": true
        },
        "application/elm+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/emergencycalldata.cap+xml": {
            "source": "iana",
            "charset": "UTF-8",
            "compressible": true
        },
        "application/emergencycalldata.comment+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/emergencycalldata.control+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/emergencycalldata.deviceinfo+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/emergencycalldata.ecall.msd": {
            "source": "iana"
        },
        "application/emergencycalldata.providerinfo+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/emergencycalldata.serviceinfo+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/emergencycalldata.subscriberinfo+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/emergencycalldata.veds+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/emma+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "emma"
            ]
        },
        "application/emotionml+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "emotionml"
            ]
        },
        "application/encaprtp": {
            "source": "iana"
        },
        "application/epp+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/epub+zip": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "epub"
            ]
        },
        "application/eshop": {
            "source": "iana"
        },
        "application/exi": {
            "source": "iana",
            "extensions": [
                "exi"
            ]
        },
        "application/expect-ct-report+json": {
            "source": "iana",
            "compressible": true
        },
        "application/express": {
            "source": "iana",
            "extensions": [
                "exp"
            ]
        },
        "application/fastinfoset": {
            "source": "iana"
        },
        "application/fastsoap": {
            "source": "iana"
        },
        "application/fdt+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "fdt"
            ]
        },
        "application/fhir+json": {
            "source": "iana",
            "charset": "UTF-8",
            "compressible": true
        },
        "application/fhir+xml": {
            "source": "iana",
            "charset": "UTF-8",
            "compressible": true
        },
        "application/fido.trusted-apps+json": {
            "compressible": true
        },
        "application/fits": {
            "source": "iana"
        },
        "application/flexfec": {
            "source": "iana"
        },
        "application/font-sfnt": {
            "source": "iana"
        },
        "application/font-tdpfr": {
            "source": "iana",
            "extensions": [
                "pfr"
            ]
        },
        "application/font-woff": {
            "source": "iana",
            "compressible": false
        },
        "application/framework-attributes+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/geo+json": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "geojson"
            ]
        },
        "application/geo+json-seq": {
            "source": "iana"
        },
        "application/geopackage+sqlite3": {
            "source": "iana"
        },
        "application/geoxacml+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/gltf-buffer": {
            "source": "iana"
        },
        "application/gml+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "gml"
            ]
        },
        "application/gpx+xml": {
            "source": "apache",
            "compressible": true,
            "extensions": [
                "gpx"
            ]
        },
        "application/gxf": {
            "source": "apache",
            "extensions": [
                "gxf"
            ]
        },
        "application/gzip": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "gz"
            ]
        },
        "application/h224": {
            "source": "iana"
        },
        "application/held+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/hjson": {
            "extensions": [
                "hjson"
            ]
        },
        "application/http": {
            "source": "iana"
        },
        "application/hyperstudio": {
            "source": "iana",
            "extensions": [
                "stk"
            ]
        },
        "application/ibe-key-request+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/ibe-pkg-reply+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/ibe-pp-data": {
            "source": "iana"
        },
        "application/iges": {
            "source": "iana"
        },
        "application/im-iscomposing+xml": {
            "source": "iana",
            "charset": "UTF-8",
            "compressible": true
        },
        "application/index": {
            "source": "iana"
        },
        "application/index.cmd": {
            "source": "iana"
        },
        "application/index.obj": {
            "source": "iana"
        },
        "application/index.response": {
            "source": "iana"
        },
        "application/index.vnd": {
            "source": "iana"
        },
        "application/inkml+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "ink",
                "inkml"
            ]
        },
        "application/iotp": {
            "source": "iana"
        },
        "application/ipfix": {
            "source": "iana",
            "extensions": [
                "ipfix"
            ]
        },
        "application/ipp": {
            "source": "iana"
        },
        "application/isup": {
            "source": "iana"
        },
        "application/its+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "its"
            ]
        },
        "application/java-archive": {
            "source": "apache",
            "compressible": false,
            "extensions": [
                "jar",
                "war",
                "ear"
            ]
        },
        "application/java-serialized-object": {
            "source": "apache",
            "compressible": false,
            "extensions": [
                "ser"
            ]
        },
        "application/java-vm": {
            "source": "apache",
            "compressible": false,
            "extensions": [
                "class"
            ]
        },
        "application/javascript": {
            "source": "iana",
            "charset": "UTF-8",
            "compressible": true,
            "extensions": [
                "js",
                "mjs"
            ]
        },
        "application/jf2feed+json": {
            "source": "iana",
            "compressible": true
        },
        "application/jose": {
            "source": "iana"
        },
        "application/jose+json": {
            "source": "iana",
            "compressible": true
        },
        "application/jrd+json": {
            "source": "iana",
            "compressible": true
        },
        "application/jscalendar+json": {
            "source": "iana",
            "compressible": true
        },
        "application/json": {
            "source": "iana",
            "charset": "UTF-8",
            "compressible": true,
            "extensions": [
                "json",
                "map"
            ]
        },
        "application/json-patch+json": {
            "source": "iana",
            "compressible": true
        },
        "application/json-seq": {
            "source": "iana"
        },
        "application/json5": {
            "extensions": [
                "json5"
            ]
        },
        "application/jsonml+json": {
            "source": "apache",
            "compressible": true,
            "extensions": [
                "jsonml"
            ]
        },
        "application/jwk+json": {
            "source": "iana",
            "compressible": true
        },
        "application/jwk-set+json": {
            "source": "iana",
            "compressible": true
        },
        "application/jwt": {
            "source": "iana"
        },
        "application/kpml-request+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/kpml-response+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/ld+json": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "jsonld"
            ]
        },
        "application/lgr+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "lgr"
            ]
        },
        "application/link-format": {
            "source": "iana"
        },
        "application/load-control+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/lost+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "lostxml"
            ]
        },
        "application/lostsync+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/lpf+zip": {
            "source": "iana",
            "compressible": false
        },
        "application/lxf": {
            "source": "iana"
        },
        "application/mac-binhex40": {
            "source": "iana",
            "extensions": [
                "hqx"
            ]
        },
        "application/mac-compactpro": {
            "source": "apache",
            "extensions": [
                "cpt"
            ]
        },
        "application/macwriteii": {
            "source": "iana"
        },
        "application/mads+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "mads"
            ]
        },
        "application/manifest+json": {
            "source": "iana",
            "charset": "UTF-8",
            "compressible": true,
            "extensions": [
                "webmanifest"
            ]
        },
        "application/marc": {
            "source": "iana",
            "extensions": [
                "mrc"
            ]
        },
        "application/marcxml+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "mrcx"
            ]
        },
        "application/mathematica": {
            "source": "iana",
            "extensions": [
                "ma",
                "nb",
                "mb"
            ]
        },
        "application/mathml+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "mathml"
            ]
        },
        "application/mathml-content+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/mathml-presentation+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/mbms-associated-procedure-description+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/mbms-deregister+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/mbms-envelope+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/mbms-msk+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/mbms-msk-response+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/mbms-protection-description+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/mbms-reception-report+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/mbms-register+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/mbms-register-response+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/mbms-schedule+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/mbms-user-service-description+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/mbox": {
            "source": "iana",
            "extensions": [
                "mbox"
            ]
        },
        "application/media-policy-dataset+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "mpf"
            ]
        },
        "application/media_control+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/mediaservercontrol+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "mscml"
            ]
        },
        "application/merge-patch+json": {
            "source": "iana",
            "compressible": true
        },
        "application/metalink+xml": {
            "source": "apache",
            "compressible": true,
            "extensions": [
                "metalink"
            ]
        },
        "application/metalink4+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "meta4"
            ]
        },
        "application/mets+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "mets"
            ]
        },
        "application/mf4": {
            "source": "iana"
        },
        "application/mikey": {
            "source": "iana"
        },
        "application/mipc": {
            "source": "iana"
        },
        "application/missing-blocks+cbor-seq": {
            "source": "iana"
        },
        "application/mmt-aei+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "maei"
            ]
        },
        "application/mmt-usd+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "musd"
            ]
        },
        "application/mods+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "mods"
            ]
        },
        "application/moss-keys": {
            "source": "iana"
        },
        "application/moss-signature": {
            "source": "iana"
        },
        "application/mosskey-data": {
            "source": "iana"
        },
        "application/mosskey-request": {
            "source": "iana"
        },
        "application/mp21": {
            "source": "iana",
            "extensions": [
                "m21",
                "mp21"
            ]
        },
        "application/mp4": {
            "source": "iana",
            "extensions": [
                "mp4s",
                "m4p"
            ]
        },
        "application/mpeg4-generic": {
            "source": "iana"
        },
        "application/mpeg4-iod": {
            "source": "iana"
        },
        "application/mpeg4-iod-xmt": {
            "source": "iana"
        },
        "application/mrb-consumer+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/mrb-publish+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/msc-ivr+xml": {
            "source": "iana",
            "charset": "UTF-8",
            "compressible": true
        },
        "application/msc-mixer+xml": {
            "source": "iana",
            "charset": "UTF-8",
            "compressible": true
        },
        "application/msword": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "doc",
                "dot"
            ]
        },
        "application/mud+json": {
            "source": "iana",
            "compressible": true
        },
        "application/multipart-core": {
            "source": "iana"
        },
        "application/mxf": {
            "source": "iana",
            "extensions": [
                "mxf"
            ]
        },
        "application/n-quads": {
            "source": "iana",
            "extensions": [
                "nq"
            ]
        },
        "application/n-triples": {
            "source": "iana",
            "extensions": [
                "nt"
            ]
        },
        "application/nasdata": {
            "source": "iana"
        },
        "application/news-checkgroups": {
            "source": "iana",
            "charset": "US-ASCII"
        },
        "application/news-groupinfo": {
            "source": "iana",
            "charset": "US-ASCII"
        },
        "application/news-transmission": {
            "source": "iana"
        },
        "application/nlsml+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/node": {
            "source": "iana",
            "extensions": [
                "cjs"
            ]
        },
        "application/nss": {
            "source": "iana"
        },
        "application/oauth-authz-req+jwt": {
            "source": "iana"
        },
        "application/oblivious-dns-message": {
            "source": "iana"
        },
        "application/ocsp-request": {
            "source": "iana"
        },
        "application/ocsp-response": {
            "source": "iana"
        },
        "application/octet-stream": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "bin",
                "dms",
                "lrf",
                "mar",
                "so",
                "dist",
                "distz",
                "pkg",
                "bpk",
                "dump",
                "elc",
                "deploy",
                "exe",
                "dll",
                "deb",
                "dmg",
                "iso",
                "img",
                "msi",
                "msp",
                "msm",
                "buffer"
            ]
        },
        "application/oda": {
            "source": "iana",
            "extensions": [
                "oda"
            ]
        },
        "application/odm+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/odx": {
            "source": "iana"
        },
        "application/oebps-package+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "opf"
            ]
        },
        "application/ogg": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "ogx"
            ]
        },
        "application/omdoc+xml": {
            "source": "apache",
            "compressible": true,
            "extensions": [
                "omdoc"
            ]
        },
        "application/onenote": {
            "source": "apache",
            "extensions": [
                "onetoc",
                "onetoc2",
                "onetmp",
                "onepkg"
            ]
        },
        "application/opc-nodeset+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/oscore": {
            "source": "iana"
        },
        "application/oxps": {
            "source": "iana",
            "extensions": [
                "oxps"
            ]
        },
        "application/p21": {
            "source": "iana"
        },
        "application/p21+zip": {
            "source": "iana",
            "compressible": false
        },
        "application/p2p-overlay+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "relo"
            ]
        },
        "application/parityfec": {
            "source": "iana"
        },
        "application/passport": {
            "source": "iana"
        },
        "application/patch-ops-error+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "xer"
            ]
        },
        "application/pdf": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "pdf"
            ]
        },
        "application/pdx": {
            "source": "iana"
        },
        "application/pem-certificate-chain": {
            "source": "iana"
        },
        "application/pgp-encrypted": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "pgp"
            ]
        },
        "application/pgp-keys": {
            "source": "iana",
            "extensions": [
                "asc"
            ]
        },
        "application/pgp-signature": {
            "source": "iana",
            "extensions": [
                "asc",
                "sig"
            ]
        },
        "application/pics-rules": {
            "source": "apache",
            "extensions": [
                "prf"
            ]
        },
        "application/pidf+xml": {
            "source": "iana",
            "charset": "UTF-8",
            "compressible": true
        },
        "application/pidf-diff+xml": {
            "source": "iana",
            "charset": "UTF-8",
            "compressible": true
        },
        "application/pkcs10": {
            "source": "iana",
            "extensions": [
                "p10"
            ]
        },
        "application/pkcs12": {
            "source": "iana"
        },
        "application/pkcs7-mime": {
            "source": "iana",
            "extensions": [
                "p7m",
                "p7c"
            ]
        },
        "application/pkcs7-signature": {
            "source": "iana",
            "extensions": [
                "p7s"
            ]
        },
        "application/pkcs8": {
            "source": "iana",
            "extensions": [
                "p8"
            ]
        },
        "application/pkcs8-encrypted": {
            "source": "iana"
        },
        "application/pkix-attr-cert": {
            "source": "iana",
            "extensions": [
                "ac"
            ]
        },
        "application/pkix-cert": {
            "source": "iana",
            "extensions": [
                "cer"
            ]
        },
        "application/pkix-crl": {
            "source": "iana",
            "extensions": [
                "crl"
            ]
        },
        "application/pkix-pkipath": {
            "source": "iana",
            "extensions": [
                "pkipath"
            ]
        },
        "application/pkixcmp": {
            "source": "iana",
            "extensions": [
                "pki"
            ]
        },
        "application/pls+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "pls"
            ]
        },
        "application/poc-settings+xml": {
            "source": "iana",
            "charset": "UTF-8",
            "compressible": true
        },
        "application/postscript": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "ai",
                "eps",
                "ps"
            ]
        },
        "application/ppsp-tracker+json": {
            "source": "iana",
            "compressible": true
        },
        "application/problem+json": {
            "source": "iana",
            "compressible": true
        },
        "application/problem+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/provenance+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "provx"
            ]
        },
        "application/prs.alvestrand.titrax-sheet": {
            "source": "iana"
        },
        "application/prs.cww": {
            "source": "iana",
            "extensions": [
                "cww"
            ]
        },
        "application/prs.cyn": {
            "source": "iana",
            "charset": "7-BIT"
        },
        "application/prs.hpub+zip": {
            "source": "iana",
            "compressible": false
        },
        "application/prs.nprend": {
            "source": "iana"
        },
        "application/prs.plucker": {
            "source": "iana"
        },
        "application/prs.rdf-xml-crypt": {
            "source": "iana"
        },
        "application/prs.xsf+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/pskc+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "pskcxml"
            ]
        },
        "application/pvd+json": {
            "source": "iana",
            "compressible": true
        },
        "application/qsig": {
            "source": "iana"
        },
        "application/raml+yaml": {
            "compressible": true,
            "extensions": [
                "raml"
            ]
        },
        "application/raptorfec": {
            "source": "iana"
        },
        "application/rdap+json": {
            "source": "iana",
            "compressible": true
        },
        "application/rdf+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "rdf",
                "owl"
            ]
        },
        "application/reginfo+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "rif"
            ]
        },
        "application/relax-ng-compact-syntax": {
            "source": "iana",
            "extensions": [
                "rnc"
            ]
        },
        "application/remote-printing": {
            "source": "iana"
        },
        "application/reputon+json": {
            "source": "iana",
            "compressible": true
        },
        "application/resource-lists+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "rl"
            ]
        },
        "application/resource-lists-diff+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "rld"
            ]
        },
        "application/rfc+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/riscos": {
            "source": "iana"
        },
        "application/rlmi+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/rls-services+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "rs"
            ]
        },
        "application/route-apd+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "rapd"
            ]
        },
        "application/route-s-tsid+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "sls"
            ]
        },
        "application/route-usd+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "rusd"
            ]
        },
        "application/rpki-ghostbusters": {
            "source": "iana",
            "extensions": [
                "gbr"
            ]
        },
        "application/rpki-manifest": {
            "source": "iana",
            "extensions": [
                "mft"
            ]
        },
        "application/rpki-publication": {
            "source": "iana"
        },
        "application/rpki-roa": {
            "source": "iana",
            "extensions": [
                "roa"
            ]
        },
        "application/rpki-updown": {
            "source": "iana"
        },
        "application/rsd+xml": {
            "source": "apache",
            "compressible": true,
            "extensions": [
                "rsd"
            ]
        },
        "application/rss+xml": {
            "source": "apache",
            "compressible": true,
            "extensions": [
                "rss"
            ]
        },
        "application/rtf": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "rtf"
            ]
        },
        "application/rtploopback": {
            "source": "iana"
        },
        "application/rtx": {
            "source": "iana"
        },
        "application/samlassertion+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/samlmetadata+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/sarif+json": {
            "source": "iana",
            "compressible": true
        },
        "application/sarif-external-properties+json": {
            "source": "iana",
            "compressible": true
        },
        "application/sbe": {
            "source": "iana"
        },
        "application/sbml+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "sbml"
            ]
        },
        "application/scaip+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/scim+json": {
            "source": "iana",
            "compressible": true
        },
        "application/scvp-cv-request": {
            "source": "iana",
            "extensions": [
                "scq"
            ]
        },
        "application/scvp-cv-response": {
            "source": "iana",
            "extensions": [
                "scs"
            ]
        },
        "application/scvp-vp-request": {
            "source": "iana",
            "extensions": [
                "spq"
            ]
        },
        "application/scvp-vp-response": {
            "source": "iana",
            "extensions": [
                "spp"
            ]
        },
        "application/sdp": {
            "source": "iana",
            "extensions": [
                "sdp"
            ]
        },
        "application/secevent+jwt": {
            "source": "iana"
        },
        "application/senml+cbor": {
            "source": "iana"
        },
        "application/senml+json": {
            "source": "iana",
            "compressible": true
        },
        "application/senml+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "senmlx"
            ]
        },
        "application/senml-etch+cbor": {
            "source": "iana"
        },
        "application/senml-etch+json": {
            "source": "iana",
            "compressible": true
        },
        "application/senml-exi": {
            "source": "iana"
        },
        "application/sensml+cbor": {
            "source": "iana"
        },
        "application/sensml+json": {
            "source": "iana",
            "compressible": true
        },
        "application/sensml+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "sensmlx"
            ]
        },
        "application/sensml-exi": {
            "source": "iana"
        },
        "application/sep+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/sep-exi": {
            "source": "iana"
        },
        "application/session-info": {
            "source": "iana"
        },
        "application/set-payment": {
            "source": "iana"
        },
        "application/set-payment-initiation": {
            "source": "iana",
            "extensions": [
                "setpay"
            ]
        },
        "application/set-registration": {
            "source": "iana"
        },
        "application/set-registration-initiation": {
            "source": "iana",
            "extensions": [
                "setreg"
            ]
        },
        "application/sgml": {
            "source": "iana"
        },
        "application/sgml-open-catalog": {
            "source": "iana"
        },
        "application/shf+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "shf"
            ]
        },
        "application/sieve": {
            "source": "iana",
            "extensions": [
                "siv",
                "sieve"
            ]
        },
        "application/simple-filter+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/simple-message-summary": {
            "source": "iana"
        },
        "application/simplesymbolcontainer": {
            "source": "iana"
        },
        "application/sipc": {
            "source": "iana"
        },
        "application/slate": {
            "source": "iana"
        },
        "application/smil": {
            "source": "iana"
        },
        "application/smil+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "smi",
                "smil"
            ]
        },
        "application/smpte336m": {
            "source": "iana"
        },
        "application/soap+fastinfoset": {
            "source": "iana"
        },
        "application/soap+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/sparql-query": {
            "source": "iana",
            "extensions": [
                "rq"
            ]
        },
        "application/sparql-results+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "srx"
            ]
        },
        "application/spdx+json": {
            "source": "iana",
            "compressible": true
        },
        "application/spirits-event+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/sql": {
            "source": "iana"
        },
        "application/srgs": {
            "source": "iana",
            "extensions": [
                "gram"
            ]
        },
        "application/srgs+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "grxml"
            ]
        },
        "application/sru+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "sru"
            ]
        },
        "application/ssdl+xml": {
            "source": "apache",
            "compressible": true,
            "extensions": [
                "ssdl"
            ]
        },
        "application/ssml+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "ssml"
            ]
        },
        "application/stix+json": {
            "source": "iana",
            "compressible": true
        },
        "application/swid+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "swidtag"
            ]
        },
        "application/tamp-apex-update": {
            "source": "iana"
        },
        "application/tamp-apex-update-confirm": {
            "source": "iana"
        },
        "application/tamp-community-update": {
            "source": "iana"
        },
        "application/tamp-community-update-confirm": {
            "source": "iana"
        },
        "application/tamp-error": {
            "source": "iana"
        },
        "application/tamp-sequence-adjust": {
            "source": "iana"
        },
        "application/tamp-sequence-adjust-confirm": {
            "source": "iana"
        },
        "application/tamp-status-query": {
            "source": "iana"
        },
        "application/tamp-status-response": {
            "source": "iana"
        },
        "application/tamp-update": {
            "source": "iana"
        },
        "application/tamp-update-confirm": {
            "source": "iana"
        },
        "application/tar": {
            "compressible": true
        },
        "application/taxii+json": {
            "source": "iana",
            "compressible": true
        },
        "application/td+json": {
            "source": "iana",
            "compressible": true
        },
        "application/tei+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "tei",
                "teicorpus"
            ]
        },
        "application/tetra_isi": {
            "source": "iana"
        },
        "application/thraud+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "tfi"
            ]
        },
        "application/timestamp-query": {
            "source": "iana"
        },
        "application/timestamp-reply": {
            "source": "iana"
        },
        "application/timestamped-data": {
            "source": "iana",
            "extensions": [
                "tsd"
            ]
        },
        "application/tlsrpt+gzip": {
            "source": "iana"
        },
        "application/tlsrpt+json": {
            "source": "iana",
            "compressible": true
        },
        "application/tnauthlist": {
            "source": "iana"
        },
        "application/token-introspection+jwt": {
            "source": "iana"
        },
        "application/toml": {
            "compressible": true,
            "extensions": [
                "toml"
            ]
        },
        "application/trickle-ice-sdpfrag": {
            "source": "iana"
        },
        "application/trig": {
            "source": "iana",
            "extensions": [
                "trig"
            ]
        },
        "application/ttml+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "ttml"
            ]
        },
        "application/tve-trigger": {
            "source": "iana"
        },
        "application/tzif": {
            "source": "iana"
        },
        "application/tzif-leap": {
            "source": "iana"
        },
        "application/ubjson": {
            "compressible": false,
            "extensions": [
                "ubj"
            ]
        },
        "application/ulpfec": {
            "source": "iana"
        },
        "application/urc-grpsheet+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/urc-ressheet+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "rsheet"
            ]
        },
        "application/urc-targetdesc+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "td"
            ]
        },
        "application/urc-uisocketdesc+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vcard+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vcard+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vemmi": {
            "source": "iana"
        },
        "application/vividence.scriptfile": {
            "source": "apache"
        },
        "application/vnd.1000minds.decision-model+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "1km"
            ]
        },
        "application/vnd.3gpp-prose+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.3gpp-prose-pc3ch+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.3gpp-v2x-local-service-information": {
            "source": "iana"
        },
        "application/vnd.3gpp.5gnas": {
            "source": "iana"
        },
        "application/vnd.3gpp.access-transfer-events+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.3gpp.bsf+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.3gpp.gmop+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.3gpp.gtpc": {
            "source": "iana"
        },
        "application/vnd.3gpp.interworking-data": {
            "source": "iana"
        },
        "application/vnd.3gpp.lpp": {
            "source": "iana"
        },
        "application/vnd.3gpp.mc-signalling-ear": {
            "source": "iana"
        },
        "application/vnd.3gpp.mcdata-affiliation-command+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.3gpp.mcdata-info+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.3gpp.mcdata-payload": {
            "source": "iana"
        },
        "application/vnd.3gpp.mcdata-service-config+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.3gpp.mcdata-signalling": {
            "source": "iana"
        },
        "application/vnd.3gpp.mcdata-ue-config+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.3gpp.mcdata-user-profile+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.3gpp.mcptt-affiliation-command+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.3gpp.mcptt-floor-request+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.3gpp.mcptt-info+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.3gpp.mcptt-location-info+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.3gpp.mcptt-service-config+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.3gpp.mcptt-signed+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.3gpp.mcptt-ue-config+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.3gpp.mcptt-ue-init-config+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.3gpp.mcptt-user-profile+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.3gpp.mcvideo-info+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.3gpp.mcvideo-location-info+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.3gpp.mcvideo-service-config+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.3gpp.mcvideo-transmission-request+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.3gpp.mcvideo-ue-config+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.3gpp.mcvideo-user-profile+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.3gpp.mid-call+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.3gpp.ngap": {
            "source": "iana"
        },
        "application/vnd.3gpp.pfcp": {
            "source": "iana"
        },
        "application/vnd.3gpp.pic-bw-large": {
            "source": "iana",
            "extensions": [
                "plb"
            ]
        },
        "application/vnd.3gpp.pic-bw-small": {
            "source": "iana",
            "extensions": [
                "psb"
            ]
        },
        "application/vnd.3gpp.pic-bw-var": {
            "source": "iana",
            "extensions": [
                "pvb"
            ]
        },
        "application/vnd.3gpp.s1ap": {
            "source": "iana"
        },
        "application/vnd.3gpp.sms": {
            "source": "iana"
        },
        "application/vnd.3gpp.sms+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.3gpp.srvcc-ext+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.3gpp.srvcc-info+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.3gpp.state-and-event-info+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.3gpp.ussd+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.3gpp2.bcmcsinfo+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.3gpp2.sms": {
            "source": "iana"
        },
        "application/vnd.3gpp2.tcap": {
            "source": "iana",
            "extensions": [
                "tcap"
            ]
        },
        "application/vnd.3lightssoftware.imagescal": {
            "source": "iana"
        },
        "application/vnd.3m.post-it-notes": {
            "source": "iana",
            "extensions": [
                "pwn"
            ]
        },
        "application/vnd.accpac.simply.aso": {
            "source": "iana",
            "extensions": [
                "aso"
            ]
        },
        "application/vnd.accpac.simply.imp": {
            "source": "iana",
            "extensions": [
                "imp"
            ]
        },
        "application/vnd.acucobol": {
            "source": "iana",
            "extensions": [
                "acu"
            ]
        },
        "application/vnd.acucorp": {
            "source": "iana",
            "extensions": [
                "atc",
                "acutc"
            ]
        },
        "application/vnd.adobe.air-application-installer-package+zip": {
            "source": "apache",
            "compressible": false,
            "extensions": [
                "air"
            ]
        },
        "application/vnd.adobe.flash.movie": {
            "source": "iana"
        },
        "application/vnd.adobe.formscentral.fcdt": {
            "source": "iana",
            "extensions": [
                "fcdt"
            ]
        },
        "application/vnd.adobe.fxp": {
            "source": "iana",
            "extensions": [
                "fxp",
                "fxpl"
            ]
        },
        "application/vnd.adobe.partial-upload": {
            "source": "iana"
        },
        "application/vnd.adobe.xdp+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "xdp"
            ]
        },
        "application/vnd.adobe.xfdf": {
            "source": "iana",
            "extensions": [
                "xfdf"
            ]
        },
        "application/vnd.aether.imp": {
            "source": "iana"
        },
        "application/vnd.afpc.afplinedata": {
            "source": "iana"
        },
        "application/vnd.afpc.afplinedata-pagedef": {
            "source": "iana"
        },
        "application/vnd.afpc.cmoca-cmresource": {
            "source": "iana"
        },
        "application/vnd.afpc.foca-charset": {
            "source": "iana"
        },
        "application/vnd.afpc.foca-codedfont": {
            "source": "iana"
        },
        "application/vnd.afpc.foca-codepage": {
            "source": "iana"
        },
        "application/vnd.afpc.modca": {
            "source": "iana"
        },
        "application/vnd.afpc.modca-cmtable": {
            "source": "iana"
        },
        "application/vnd.afpc.modca-formdef": {
            "source": "iana"
        },
        "application/vnd.afpc.modca-mediummap": {
            "source": "iana"
        },
        "application/vnd.afpc.modca-objectcontainer": {
            "source": "iana"
        },
        "application/vnd.afpc.modca-overlay": {
            "source": "iana"
        },
        "application/vnd.afpc.modca-pagesegment": {
            "source": "iana"
        },
        "application/vnd.age": {
            "source": "iana",
            "extensions": [
                "age"
            ]
        },
        "application/vnd.ah-barcode": {
            "source": "iana"
        },
        "application/vnd.ahead.space": {
            "source": "iana",
            "extensions": [
                "ahead"
            ]
        },
        "application/vnd.airzip.filesecure.azf": {
            "source": "iana",
            "extensions": [
                "azf"
            ]
        },
        "application/vnd.airzip.filesecure.azs": {
            "source": "iana",
            "extensions": [
                "azs"
            ]
        },
        "application/vnd.amadeus+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.amazon.ebook": {
            "source": "apache",
            "extensions": [
                "azw"
            ]
        },
        "application/vnd.amazon.mobi8-ebook": {
            "source": "iana"
        },
        "application/vnd.americandynamics.acc": {
            "source": "iana",
            "extensions": [
                "acc"
            ]
        },
        "application/vnd.amiga.ami": {
            "source": "iana",
            "extensions": [
                "ami"
            ]
        },
        "application/vnd.amundsen.maze+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.android.ota": {
            "source": "iana"
        },
        "application/vnd.android.package-archive": {
            "source": "apache",
            "compressible": false,
            "extensions": [
                "apk"
            ]
        },
        "application/vnd.anki": {
            "source": "iana"
        },
        "application/vnd.anser-web-certificate-issue-initiation": {
            "source": "iana",
            "extensions": [
                "cii"
            ]
        },
        "application/vnd.anser-web-funds-transfer-initiation": {
            "source": "apache",
            "extensions": [
                "fti"
            ]
        },
        "application/vnd.antix.game-component": {
            "source": "iana",
            "extensions": [
                "atx"
            ]
        },
        "application/vnd.apache.arrow.file": {
            "source": "iana"
        },
        "application/vnd.apache.arrow.stream": {
            "source": "iana"
        },
        "application/vnd.apache.thrift.binary": {
            "source": "iana"
        },
        "application/vnd.apache.thrift.compact": {
            "source": "iana"
        },
        "application/vnd.apache.thrift.json": {
            "source": "iana"
        },
        "application/vnd.api+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.aplextor.warrp+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.apothekende.reservation+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.apple.installer+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "mpkg"
            ]
        },
        "application/vnd.apple.keynote": {
            "source": "iana",
            "extensions": [
                "key"
            ]
        },
        "application/vnd.apple.mpegurl": {
            "source": "iana",
            "extensions": [
                "m3u8"
            ]
        },
        "application/vnd.apple.numbers": {
            "source": "iana",
            "extensions": [
                "numbers"
            ]
        },
        "application/vnd.apple.pages": {
            "source": "iana",
            "extensions": [
                "pages"
            ]
        },
        "application/vnd.apple.pkpass": {
            "compressible": false,
            "extensions": [
                "pkpass"
            ]
        },
        "application/vnd.arastra.swi": {
            "source": "iana"
        },
        "application/vnd.aristanetworks.swi": {
            "source": "iana",
            "extensions": [
                "swi"
            ]
        },
        "application/vnd.artisan+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.artsquare": {
            "source": "iana"
        },
        "application/vnd.astraea-software.iota": {
            "source": "iana",
            "extensions": [
                "iota"
            ]
        },
        "application/vnd.audiograph": {
            "source": "iana",
            "extensions": [
                "aep"
            ]
        },
        "application/vnd.autopackage": {
            "source": "iana"
        },
        "application/vnd.avalon+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.avistar+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.balsamiq.bmml+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "bmml"
            ]
        },
        "application/vnd.balsamiq.bmpr": {
            "source": "iana"
        },
        "application/vnd.banana-accounting": {
            "source": "iana"
        },
        "application/vnd.bbf.usp.error": {
            "source": "iana"
        },
        "application/vnd.bbf.usp.msg": {
            "source": "iana"
        },
        "application/vnd.bbf.usp.msg+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.bekitzur-stech+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.bint.med-content": {
            "source": "iana"
        },
        "application/vnd.biopax.rdf+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.blink-idb-value-wrapper": {
            "source": "iana"
        },
        "application/vnd.blueice.multipass": {
            "source": "iana",
            "extensions": [
                "mpm"
            ]
        },
        "application/vnd.bluetooth.ep.oob": {
            "source": "iana"
        },
        "application/vnd.bluetooth.le.oob": {
            "source": "iana"
        },
        "application/vnd.bmi": {
            "source": "iana",
            "extensions": [
                "bmi"
            ]
        },
        "application/vnd.bpf": {
            "source": "iana"
        },
        "application/vnd.bpf3": {
            "source": "iana"
        },
        "application/vnd.businessobjects": {
            "source": "iana",
            "extensions": [
                "rep"
            ]
        },
        "application/vnd.byu.uapi+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.cab-jscript": {
            "source": "iana"
        },
        "application/vnd.canon-cpdl": {
            "source": "iana"
        },
        "application/vnd.canon-lips": {
            "source": "iana"
        },
        "application/vnd.capasystems-pg+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.cendio.thinlinc.clientconf": {
            "source": "iana"
        },
        "application/vnd.century-systems.tcp_stream": {
            "source": "iana"
        },
        "application/vnd.chemdraw+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "cdxml"
            ]
        },
        "application/vnd.chess-pgn": {
            "source": "iana"
        },
        "application/vnd.chipnuts.karaoke-mmd": {
            "source": "iana",
            "extensions": [
                "mmd"
            ]
        },
        "application/vnd.ciedi": {
            "source": "iana"
        },
        "application/vnd.cinderella": {
            "source": "iana",
            "extensions": [
                "cdy"
            ]
        },
        "application/vnd.cirpack.isdn-ext": {
            "source": "iana"
        },
        "application/vnd.citationstyles.style+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "csl"
            ]
        },
        "application/vnd.claymore": {
            "source": "iana",
            "extensions": [
                "cla"
            ]
        },
        "application/vnd.cloanto.rp9": {
            "source": "iana",
            "extensions": [
                "rp9"
            ]
        },
        "application/vnd.clonk.c4group": {
            "source": "iana",
            "extensions": [
                "c4g",
                "c4d",
                "c4f",
                "c4p",
                "c4u"
            ]
        },
        "application/vnd.cluetrust.cartomobile-config": {
            "source": "iana",
            "extensions": [
                "c11amc"
            ]
        },
        "application/vnd.cluetrust.cartomobile-config-pkg": {
            "source": "iana",
            "extensions": [
                "c11amz"
            ]
        },
        "application/vnd.coffeescript": {
            "source": "iana"
        },
        "application/vnd.collabio.xodocuments.document": {
            "source": "iana"
        },
        "application/vnd.collabio.xodocuments.document-template": {
            "source": "iana"
        },
        "application/vnd.collabio.xodocuments.presentation": {
            "source": "iana"
        },
        "application/vnd.collabio.xodocuments.presentation-template": {
            "source": "iana"
        },
        "application/vnd.collabio.xodocuments.spreadsheet": {
            "source": "iana"
        },
        "application/vnd.collabio.xodocuments.spreadsheet-template": {
            "source": "iana"
        },
        "application/vnd.collection+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.collection.doc+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.collection.next+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.comicbook+zip": {
            "source": "iana",
            "compressible": false
        },
        "application/vnd.comicbook-rar": {
            "source": "iana"
        },
        "application/vnd.commerce-battelle": {
            "source": "iana"
        },
        "application/vnd.commonspace": {
            "source": "iana",
            "extensions": [
                "csp"
            ]
        },
        "application/vnd.contact.cmsg": {
            "source": "iana",
            "extensions": [
                "cdbcmsg"
            ]
        },
        "application/vnd.coreos.ignition+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.cosmocaller": {
            "source": "iana",
            "extensions": [
                "cmc"
            ]
        },
        "application/vnd.crick.clicker": {
            "source": "iana",
            "extensions": [
                "clkx"
            ]
        },
        "application/vnd.crick.clicker.keyboard": {
            "source": "iana",
            "extensions": [
                "clkk"
            ]
        },
        "application/vnd.crick.clicker.palette": {
            "source": "iana",
            "extensions": [
                "clkp"
            ]
        },
        "application/vnd.crick.clicker.template": {
            "source": "iana",
            "extensions": [
                "clkt"
            ]
        },
        "application/vnd.crick.clicker.wordbank": {
            "source": "iana",
            "extensions": [
                "clkw"
            ]
        },
        "application/vnd.criticaltools.wbs+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "wbs"
            ]
        },
        "application/vnd.cryptii.pipe+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.crypto-shade-file": {
            "source": "iana"
        },
        "application/vnd.cryptomator.encrypted": {
            "source": "iana"
        },
        "application/vnd.cryptomator.vault": {
            "source": "iana"
        },
        "application/vnd.ctc-posml": {
            "source": "iana",
            "extensions": [
                "pml"
            ]
        },
        "application/vnd.ctct.ws+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.cups-pdf": {
            "source": "iana"
        },
        "application/vnd.cups-postscript": {
            "source": "iana"
        },
        "application/vnd.cups-ppd": {
            "source": "iana",
            "extensions": [
                "ppd"
            ]
        },
        "application/vnd.cups-raster": {
            "source": "iana"
        },
        "application/vnd.cups-raw": {
            "source": "iana"
        },
        "application/vnd.curl": {
            "source": "iana"
        },
        "application/vnd.curl.car": {
            "source": "apache",
            "extensions": [
                "car"
            ]
        },
        "application/vnd.curl.pcurl": {
            "source": "apache",
            "extensions": [
                "pcurl"
            ]
        },
        "application/vnd.cyan.dean.root+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.cybank": {
            "source": "iana"
        },
        "application/vnd.cyclonedx+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.cyclonedx+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.d2l.coursepackage1p0+zip": {
            "source": "iana",
            "compressible": false
        },
        "application/vnd.d3m-dataset": {
            "source": "iana"
        },
        "application/vnd.d3m-problem": {
            "source": "iana"
        },
        "application/vnd.dart": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "dart"
            ]
        },
        "application/vnd.data-vision.rdz": {
            "source": "iana",
            "extensions": [
                "rdz"
            ]
        },
        "application/vnd.datapackage+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.dataresource+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.dbf": {
            "source": "iana",
            "extensions": [
                "dbf"
            ]
        },
        "application/vnd.debian.binary-package": {
            "source": "iana"
        },
        "application/vnd.dece.data": {
            "source": "iana",
            "extensions": [
                "uvf",
                "uvvf",
                "uvd",
                "uvvd"
            ]
        },
        "application/vnd.dece.ttml+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "uvt",
                "uvvt"
            ]
        },
        "application/vnd.dece.unspecified": {
            "source": "iana",
            "extensions": [
                "uvx",
                "uvvx"
            ]
        },
        "application/vnd.dece.zip": {
            "source": "iana",
            "extensions": [
                "uvz",
                "uvvz"
            ]
        },
        "application/vnd.denovo.fcselayout-link": {
            "source": "iana",
            "extensions": [
                "fe_launch"
            ]
        },
        "application/vnd.desmume.movie": {
            "source": "iana"
        },
        "application/vnd.dir-bi.plate-dl-nosuffix": {
            "source": "iana"
        },
        "application/vnd.dm.delegation+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.dna": {
            "source": "iana",
            "extensions": [
                "dna"
            ]
        },
        "application/vnd.document+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.dolby.mlp": {
            "source": "apache",
            "extensions": [
                "mlp"
            ]
        },
        "application/vnd.dolby.mobile.1": {
            "source": "iana"
        },
        "application/vnd.dolby.mobile.2": {
            "source": "iana"
        },
        "application/vnd.doremir.scorecloud-binary-document": {
            "source": "iana"
        },
        "application/vnd.dpgraph": {
            "source": "iana",
            "extensions": [
                "dpg"
            ]
        },
        "application/vnd.dreamfactory": {
            "source": "iana",
            "extensions": [
                "dfac"
            ]
        },
        "application/vnd.drive+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.ds-keypoint": {
            "source": "apache",
            "extensions": [
                "kpxx"
            ]
        },
        "application/vnd.dtg.local": {
            "source": "iana"
        },
        "application/vnd.dtg.local.flash": {
            "source": "iana"
        },
        "application/vnd.dtg.local.html": {
            "source": "iana"
        },
        "application/vnd.dvb.ait": {
            "source": "iana",
            "extensions": [
                "ait"
            ]
        },
        "application/vnd.dvb.dvbisl+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.dvb.dvbj": {
            "source": "iana"
        },
        "application/vnd.dvb.esgcontainer": {
            "source": "iana"
        },
        "application/vnd.dvb.ipdcdftnotifaccess": {
            "source": "iana"
        },
        "application/vnd.dvb.ipdcesgaccess": {
            "source": "iana"
        },
        "application/vnd.dvb.ipdcesgaccess2": {
            "source": "iana"
        },
        "application/vnd.dvb.ipdcesgpdd": {
            "source": "iana"
        },
        "application/vnd.dvb.ipdcroaming": {
            "source": "iana"
        },
        "application/vnd.dvb.iptv.alfec-base": {
            "source": "iana"
        },
        "application/vnd.dvb.iptv.alfec-enhancement": {
            "source": "iana"
        },
        "application/vnd.dvb.notif-aggregate-root+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.dvb.notif-container+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.dvb.notif-generic+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.dvb.notif-ia-msglist+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.dvb.notif-ia-registration-request+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.dvb.notif-ia-registration-response+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.dvb.notif-init+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.dvb.pfr": {
            "source": "iana"
        },
        "application/vnd.dvb.service": {
            "source": "iana",
            "extensions": [
                "svc"
            ]
        },
        "application/vnd.dxr": {
            "source": "iana"
        },
        "application/vnd.dynageo": {
            "source": "iana",
            "extensions": [
                "geo"
            ]
        },
        "application/vnd.dzr": {
            "source": "iana"
        },
        "application/vnd.easykaraoke.cdgdownload": {
            "source": "iana"
        },
        "application/vnd.ecdis-update": {
            "source": "iana"
        },
        "application/vnd.ecip.rlp": {
            "source": "iana"
        },
        "application/vnd.eclipse.ditto+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.ecowin.chart": {
            "source": "iana",
            "extensions": [
                "mag"
            ]
        },
        "application/vnd.ecowin.filerequest": {
            "source": "iana"
        },
        "application/vnd.ecowin.fileupdate": {
            "source": "iana"
        },
        "application/vnd.ecowin.series": {
            "source": "iana"
        },
        "application/vnd.ecowin.seriesrequest": {
            "source": "iana"
        },
        "application/vnd.ecowin.seriesupdate": {
            "source": "iana"
        },
        "application/vnd.efi.img": {
            "source": "iana"
        },
        "application/vnd.efi.iso": {
            "source": "iana"
        },
        "application/vnd.emclient.accessrequest+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.enliven": {
            "source": "iana",
            "extensions": [
                "nml"
            ]
        },
        "application/vnd.enphase.envoy": {
            "source": "iana"
        },
        "application/vnd.eprints.data+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.epson.esf": {
            "source": "iana",
            "extensions": [
                "esf"
            ]
        },
        "application/vnd.epson.msf": {
            "source": "iana",
            "extensions": [
                "msf"
            ]
        },
        "application/vnd.epson.quickanime": {
            "source": "iana",
            "extensions": [
                "qam"
            ]
        },
        "application/vnd.epson.salt": {
            "source": "iana",
            "extensions": [
                "slt"
            ]
        },
        "application/vnd.epson.ssf": {
            "source": "iana",
            "extensions": [
                "ssf"
            ]
        },
        "application/vnd.ericsson.quickcall": {
            "source": "iana"
        },
        "application/vnd.espass-espass+zip": {
            "source": "iana",
            "compressible": false
        },
        "application/vnd.eszigno3+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "es3",
                "et3"
            ]
        },
        "application/vnd.etsi.aoc+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.etsi.asic-e+zip": {
            "source": "iana",
            "compressible": false
        },
        "application/vnd.etsi.asic-s+zip": {
            "source": "iana",
            "compressible": false
        },
        "application/vnd.etsi.cug+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.etsi.iptvcommand+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.etsi.iptvdiscovery+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.etsi.iptvprofile+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.etsi.iptvsad-bc+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.etsi.iptvsad-cod+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.etsi.iptvsad-npvr+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.etsi.iptvservice+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.etsi.iptvsync+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.etsi.iptvueprofile+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.etsi.mcid+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.etsi.mheg5": {
            "source": "iana"
        },
        "application/vnd.etsi.overload-control-policy-dataset+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.etsi.pstn+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.etsi.sci+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.etsi.simservs+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.etsi.timestamp-token": {
            "source": "iana"
        },
        "application/vnd.etsi.tsl+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.etsi.tsl.der": {
            "source": "iana"
        },
        "application/vnd.eu.kasparian.car+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.eudora.data": {
            "source": "iana"
        },
        "application/vnd.evolv.ecig.profile": {
            "source": "iana"
        },
        "application/vnd.evolv.ecig.settings": {
            "source": "iana"
        },
        "application/vnd.evolv.ecig.theme": {
            "source": "iana"
        },
        "application/vnd.exstream-empower+zip": {
            "source": "iana",
            "compressible": false
        },
        "application/vnd.exstream-package": {
            "source": "iana"
        },
        "application/vnd.ezpix-album": {
            "source": "iana",
            "extensions": [
                "ez2"
            ]
        },
        "application/vnd.ezpix-package": {
            "source": "iana",
            "extensions": [
                "ez3"
            ]
        },
        "application/vnd.f-secure.mobile": {
            "source": "iana"
        },
        "application/vnd.familysearch.gedcom+zip": {
            "source": "iana",
            "compressible": false
        },
        "application/vnd.fastcopy-disk-image": {
            "source": "iana"
        },
        "application/vnd.fdf": {
            "source": "iana",
            "extensions": [
                "fdf"
            ]
        },
        "application/vnd.fdsn.mseed": {
            "source": "iana",
            "extensions": [
                "mseed"
            ]
        },
        "application/vnd.fdsn.seed": {
            "source": "iana",
            "extensions": [
                "seed",
                "dataless"
            ]
        },
        "application/vnd.ffsns": {
            "source": "iana"
        },
        "application/vnd.ficlab.flb+zip": {
            "source": "iana",
            "compressible": false
        },
        "application/vnd.filmit.zfc": {
            "source": "iana"
        },
        "application/vnd.fints": {
            "source": "iana"
        },
        "application/vnd.firemonkeys.cloudcell": {
            "source": "iana"
        },
        "application/vnd.flographit": {
            "source": "iana",
            "extensions": [
                "gph"
            ]
        },
        "application/vnd.fluxtime.clip": {
            "source": "iana",
            "extensions": [
                "ftc"
            ]
        },
        "application/vnd.font-fontforge-sfd": {
            "source": "iana"
        },
        "application/vnd.framemaker": {
            "source": "iana",
            "extensions": [
                "fm",
                "frame",
                "maker",
                "book"
            ]
        },
        "application/vnd.frogans.fnc": {
            "source": "iana",
            "extensions": [
                "fnc"
            ]
        },
        "application/vnd.frogans.ltf": {
            "source": "iana",
            "extensions": [
                "ltf"
            ]
        },
        "application/vnd.fsc.weblaunch": {
            "source": "iana",
            "extensions": [
                "fsc"
            ]
        },
        "application/vnd.fujifilm.fb.docuworks": {
            "source": "iana"
        },
        "application/vnd.fujifilm.fb.docuworks.binder": {
            "source": "iana"
        },
        "application/vnd.fujifilm.fb.docuworks.container": {
            "source": "iana"
        },
        "application/vnd.fujifilm.fb.jfi+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.fujitsu.oasys": {
            "source": "iana",
            "extensions": [
                "oas"
            ]
        },
        "application/vnd.fujitsu.oasys2": {
            "source": "iana",
            "extensions": [
                "oa2"
            ]
        },
        "application/vnd.fujitsu.oasys3": {
            "source": "iana",
            "extensions": [
                "oa3"
            ]
        },
        "application/vnd.fujitsu.oasysgp": {
            "source": "iana",
            "extensions": [
                "fg5"
            ]
        },
        "application/vnd.fujitsu.oasysprs": {
            "source": "iana",
            "extensions": [
                "bh2"
            ]
        },
        "application/vnd.fujixerox.art-ex": {
            "source": "iana"
        },
        "application/vnd.fujixerox.art4": {
            "source": "iana"
        },
        "application/vnd.fujixerox.ddd": {
            "source": "iana",
            "extensions": [
                "ddd"
            ]
        },
        "application/vnd.fujixerox.docuworks": {
            "source": "iana",
            "extensions": [
                "xdw"
            ]
        },
        "application/vnd.fujixerox.docuworks.binder": {
            "source": "iana",
            "extensions": [
                "xbd"
            ]
        },
        "application/vnd.fujixerox.docuworks.container": {
            "source": "iana"
        },
        "application/vnd.fujixerox.hbpl": {
            "source": "iana"
        },
        "application/vnd.fut-misnet": {
            "source": "iana"
        },
        "application/vnd.futoin+cbor": {
            "source": "iana"
        },
        "application/vnd.futoin+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.fuzzysheet": {
            "source": "iana",
            "extensions": [
                "fzs"
            ]
        },
        "application/vnd.genomatix.tuxedo": {
            "source": "iana",
            "extensions": [
                "txd"
            ]
        },
        "application/vnd.gentics.grd+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.geo+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.geocube+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.geogebra.file": {
            "source": "iana",
            "extensions": [
                "ggb"
            ]
        },
        "application/vnd.geogebra.slides": {
            "source": "iana"
        },
        "application/vnd.geogebra.tool": {
            "source": "iana",
            "extensions": [
                "ggt"
            ]
        },
        "application/vnd.geometry-explorer": {
            "source": "iana",
            "extensions": [
                "gex",
                "gre"
            ]
        },
        "application/vnd.geonext": {
            "source": "iana",
            "extensions": [
                "gxt"
            ]
        },
        "application/vnd.geoplan": {
            "source": "iana",
            "extensions": [
                "g2w"
            ]
        },
        "application/vnd.geospace": {
            "source": "iana",
            "extensions": [
                "g3w"
            ]
        },
        "application/vnd.gerber": {
            "source": "iana"
        },
        "application/vnd.globalplatform.card-content-mgt": {
            "source": "iana"
        },
        "application/vnd.globalplatform.card-content-mgt-response": {
            "source": "iana"
        },
        "application/vnd.gmx": {
            "source": "iana",
            "extensions": [
                "gmx"
            ]
        },
        "application/vnd.google-apps.document": {
            "compressible": false,
            "extensions": [
                "gdoc"
            ]
        },
        "application/vnd.google-apps.presentation": {
            "compressible": false,
            "extensions": [
                "gslides"
            ]
        },
        "application/vnd.google-apps.spreadsheet": {
            "compressible": false,
            "extensions": [
                "gsheet"
            ]
        },
        "application/vnd.google-earth.kml+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "kml"
            ]
        },
        "application/vnd.google-earth.kmz": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "kmz"
            ]
        },
        "application/vnd.gov.sk.e-form+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.gov.sk.e-form+zip": {
            "source": "iana",
            "compressible": false
        },
        "application/vnd.gov.sk.xmldatacontainer+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.grafeq": {
            "source": "iana",
            "extensions": [
                "gqf",
                "gqs"
            ]
        },
        "application/vnd.gridmp": {
            "source": "iana"
        },
        "application/vnd.groove-account": {
            "source": "iana",
            "extensions": [
                "gac"
            ]
        },
        "application/vnd.groove-help": {
            "source": "iana",
            "extensions": [
                "ghf"
            ]
        },
        "application/vnd.groove-identity-message": {
            "source": "iana",
            "extensions": [
                "gim"
            ]
        },
        "application/vnd.groove-injector": {
            "source": "iana",
            "extensions": [
                "grv"
            ]
        },
        "application/vnd.groove-tool-message": {
            "source": "iana",
            "extensions": [
                "gtm"
            ]
        },
        "application/vnd.groove-tool-template": {
            "source": "iana",
            "extensions": [
                "tpl"
            ]
        },
        "application/vnd.groove-vcard": {
            "source": "iana",
            "extensions": [
                "vcg"
            ]
        },
        "application/vnd.hal+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.hal+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "hal"
            ]
        },
        "application/vnd.handheld-entertainment+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "zmm"
            ]
        },
        "application/vnd.hbci": {
            "source": "iana",
            "extensions": [
                "hbci"
            ]
        },
        "application/vnd.hc+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.hcl-bireports": {
            "source": "iana"
        },
        "application/vnd.hdt": {
            "source": "iana"
        },
        "application/vnd.heroku+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.hhe.lesson-player": {
            "source": "iana",
            "extensions": [
                "les"
            ]
        },
        "application/vnd.hl7cda+xml": {
            "source": "iana",
            "charset": "UTF-8",
            "compressible": true
        },
        "application/vnd.hl7v2+xml": {
            "source": "iana",
            "charset": "UTF-8",
            "compressible": true
        },
        "application/vnd.hp-hpgl": {
            "source": "iana",
            "extensions": [
                "hpgl"
            ]
        },
        "application/vnd.hp-hpid": {
            "source": "iana",
            "extensions": [
                "hpid"
            ]
        },
        "application/vnd.hp-hps": {
            "source": "iana",
            "extensions": [
                "hps"
            ]
        },
        "application/vnd.hp-jlyt": {
            "source": "iana",
            "extensions": [
                "jlt"
            ]
        },
        "application/vnd.hp-pcl": {
            "source": "iana",
            "extensions": [
                "pcl"
            ]
        },
        "application/vnd.hp-pclxl": {
            "source": "iana",
            "extensions": [
                "pclxl"
            ]
        },
        "application/vnd.httphone": {
            "source": "iana"
        },
        "application/vnd.hydrostatix.sof-data": {
            "source": "iana",
            "extensions": [
                "sfd-hdstx"
            ]
        },
        "application/vnd.hyper+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.hyper-item+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.hyperdrive+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.hzn-3d-crossword": {
            "source": "iana"
        },
        "application/vnd.ibm.afplinedata": {
            "source": "iana"
        },
        "application/vnd.ibm.electronic-media": {
            "source": "iana"
        },
        "application/vnd.ibm.minipay": {
            "source": "iana",
            "extensions": [
                "mpy"
            ]
        },
        "application/vnd.ibm.modcap": {
            "source": "iana",
            "extensions": [
                "afp",
                "listafp",
                "list3820"
            ]
        },
        "application/vnd.ibm.rights-management": {
            "source": "iana",
            "extensions": [
                "irm"
            ]
        },
        "application/vnd.ibm.secure-container": {
            "source": "iana",
            "extensions": [
                "sc"
            ]
        },
        "application/vnd.iccprofile": {
            "source": "iana",
            "extensions": [
                "icc",
                "icm"
            ]
        },
        "application/vnd.ieee.1905": {
            "source": "iana"
        },
        "application/vnd.igloader": {
            "source": "iana",
            "extensions": [
                "igl"
            ]
        },
        "application/vnd.imagemeter.folder+zip": {
            "source": "iana",
            "compressible": false
        },
        "application/vnd.imagemeter.image+zip": {
            "source": "iana",
            "compressible": false
        },
        "application/vnd.immervision-ivp": {
            "source": "iana",
            "extensions": [
                "ivp"
            ]
        },
        "application/vnd.immervision-ivu": {
            "source": "iana",
            "extensions": [
                "ivu"
            ]
        },
        "application/vnd.ims.imsccv1p1": {
            "source": "iana"
        },
        "application/vnd.ims.imsccv1p2": {
            "source": "iana"
        },
        "application/vnd.ims.imsccv1p3": {
            "source": "iana"
        },
        "application/vnd.ims.lis.v2.result+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.ims.lti.v2.toolproxy+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.ims.lti.v2.toolproxy.id+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.ims.lti.v2.toolsettings+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.ims.lti.v2.toolsettings.simple+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.informedcontrol.rms+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.informix-visionary": {
            "source": "iana"
        },
        "application/vnd.infotech.project": {
            "source": "iana"
        },
        "application/vnd.infotech.project+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.innopath.wamp.notification": {
            "source": "iana"
        },
        "application/vnd.insors.igm": {
            "source": "iana",
            "extensions": [
                "igm"
            ]
        },
        "application/vnd.intercon.formnet": {
            "source": "iana",
            "extensions": [
                "xpw",
                "xpx"
            ]
        },
        "application/vnd.intergeo": {
            "source": "iana",
            "extensions": [
                "i2g"
            ]
        },
        "application/vnd.intertrust.digibox": {
            "source": "iana"
        },
        "application/vnd.intertrust.nncp": {
            "source": "iana"
        },
        "application/vnd.intu.qbo": {
            "source": "iana",
            "extensions": [
                "qbo"
            ]
        },
        "application/vnd.intu.qfx": {
            "source": "iana",
            "extensions": [
                "qfx"
            ]
        },
        "application/vnd.iptc.g2.catalogitem+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.iptc.g2.conceptitem+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.iptc.g2.knowledgeitem+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.iptc.g2.newsitem+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.iptc.g2.newsmessage+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.iptc.g2.packageitem+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.iptc.g2.planningitem+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.ipunplugged.rcprofile": {
            "source": "iana",
            "extensions": [
                "rcprofile"
            ]
        },
        "application/vnd.irepository.package+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "irp"
            ]
        },
        "application/vnd.is-xpr": {
            "source": "iana",
            "extensions": [
                "xpr"
            ]
        },
        "application/vnd.isac.fcs": {
            "source": "iana",
            "extensions": [
                "fcs"
            ]
        },
        "application/vnd.iso11783-10+zip": {
            "source": "iana",
            "compressible": false
        },
        "application/vnd.jam": {
            "source": "iana",
            "extensions": [
                "jam"
            ]
        },
        "application/vnd.japannet-directory-service": {
            "source": "iana"
        },
        "application/vnd.japannet-jpnstore-wakeup": {
            "source": "iana"
        },
        "application/vnd.japannet-payment-wakeup": {
            "source": "iana"
        },
        "application/vnd.japannet-registration": {
            "source": "iana"
        },
        "application/vnd.japannet-registration-wakeup": {
            "source": "iana"
        },
        "application/vnd.japannet-setstore-wakeup": {
            "source": "iana"
        },
        "application/vnd.japannet-verification": {
            "source": "iana"
        },
        "application/vnd.japannet-verification-wakeup": {
            "source": "iana"
        },
        "application/vnd.jcp.javame.midlet-rms": {
            "source": "iana",
            "extensions": [
                "rms"
            ]
        },
        "application/vnd.jisp": {
            "source": "iana",
            "extensions": [
                "jisp"
            ]
        },
        "application/vnd.joost.joda-archive": {
            "source": "iana",
            "extensions": [
                "joda"
            ]
        },
        "application/vnd.jsk.isdn-ngn": {
            "source": "iana"
        },
        "application/vnd.kahootz": {
            "source": "iana",
            "extensions": [
                "ktz",
                "ktr"
            ]
        },
        "application/vnd.kde.karbon": {
            "source": "iana",
            "extensions": [
                "karbon"
            ]
        },
        "application/vnd.kde.kchart": {
            "source": "iana",
            "extensions": [
                "chrt"
            ]
        },
        "application/vnd.kde.kformula": {
            "source": "iana",
            "extensions": [
                "kfo"
            ]
        },
        "application/vnd.kde.kivio": {
            "source": "iana",
            "extensions": [
                "flw"
            ]
        },
        "application/vnd.kde.kontour": {
            "source": "iana",
            "extensions": [
                "kon"
            ]
        },
        "application/vnd.kde.kpresenter": {
            "source": "iana",
            "extensions": [
                "kpr",
                "kpt"
            ]
        },
        "application/vnd.kde.kspread": {
            "source": "iana",
            "extensions": [
                "ksp"
            ]
        },
        "application/vnd.kde.kword": {
            "source": "iana",
            "extensions": [
                "kwd",
                "kwt"
            ]
        },
        "application/vnd.kenameaapp": {
            "source": "iana",
            "extensions": [
                "htke"
            ]
        },
        "application/vnd.kidspiration": {
            "source": "iana",
            "extensions": [
                "kia"
            ]
        },
        "application/vnd.kinar": {
            "source": "iana",
            "extensions": [
                "kne",
                "knp"
            ]
        },
        "application/vnd.koan": {
            "source": "iana",
            "extensions": [
                "skp",
                "skd",
                "skt",
                "skm"
            ]
        },
        "application/vnd.kodak-descriptor": {
            "source": "iana",
            "extensions": [
                "sse"
            ]
        },
        "application/vnd.las": {
            "source": "iana"
        },
        "application/vnd.las.las+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.las.las+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "lasxml"
            ]
        },
        "application/vnd.laszip": {
            "source": "iana"
        },
        "application/vnd.leap+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.liberty-request+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.llamagraphics.life-balance.desktop": {
            "source": "iana",
            "extensions": [
                "lbd"
            ]
        },
        "application/vnd.llamagraphics.life-balance.exchange+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "lbe"
            ]
        },
        "application/vnd.logipipe.circuit+zip": {
            "source": "iana",
            "compressible": false
        },
        "application/vnd.loom": {
            "source": "iana"
        },
        "application/vnd.lotus-1-2-3": {
            "source": "iana",
            "extensions": [
                "123"
            ]
        },
        "application/vnd.lotus-approach": {
            "source": "iana",
            "extensions": [
                "apr"
            ]
        },
        "application/vnd.lotus-freelance": {
            "source": "iana",
            "extensions": [
                "pre"
            ]
        },
        "application/vnd.lotus-notes": {
            "source": "iana",
            "extensions": [
                "nsf"
            ]
        },
        "application/vnd.lotus-organizer": {
            "source": "iana",
            "extensions": [
                "org"
            ]
        },
        "application/vnd.lotus-screencam": {
            "source": "iana",
            "extensions": [
                "scm"
            ]
        },
        "application/vnd.lotus-wordpro": {
            "source": "iana",
            "extensions": [
                "lwp"
            ]
        },
        "application/vnd.macports.portpkg": {
            "source": "iana",
            "extensions": [
                "portpkg"
            ]
        },
        "application/vnd.mapbox-vector-tile": {
            "source": "iana",
            "extensions": [
                "mvt"
            ]
        },
        "application/vnd.marlin.drm.actiontoken+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.marlin.drm.conftoken+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.marlin.drm.license+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.marlin.drm.mdcf": {
            "source": "iana"
        },
        "application/vnd.mason+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.maxar.archive.3tz+zip": {
            "source": "iana",
            "compressible": false
        },
        "application/vnd.maxmind.maxmind-db": {
            "source": "iana"
        },
        "application/vnd.mcd": {
            "source": "iana",
            "extensions": [
                "mcd"
            ]
        },
        "application/vnd.medcalcdata": {
            "source": "iana",
            "extensions": [
                "mc1"
            ]
        },
        "application/vnd.mediastation.cdkey": {
            "source": "iana",
            "extensions": [
                "cdkey"
            ]
        },
        "application/vnd.meridian-slingshot": {
            "source": "iana"
        },
        "application/vnd.mfer": {
            "source": "iana",
            "extensions": [
                "mwf"
            ]
        },
        "application/vnd.mfmp": {
            "source": "iana",
            "extensions": [
                "mfm"
            ]
        },
        "application/vnd.micro+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.micrografx.flo": {
            "source": "iana",
            "extensions": [
                "flo"
            ]
        },
        "application/vnd.micrografx.igx": {
            "source": "iana",
            "extensions": [
                "igx"
            ]
        },
        "application/vnd.microsoft.portable-executable": {
            "source": "iana"
        },
        "application/vnd.microsoft.windows.thumbnail-cache": {
            "source": "iana"
        },
        "application/vnd.miele+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.mif": {
            "source": "iana",
            "extensions": [
                "mif"
            ]
        },
        "application/vnd.minisoft-hp3000-save": {
            "source": "iana"
        },
        "application/vnd.mitsubishi.misty-guard.trustweb": {
            "source": "iana"
        },
        "application/vnd.mobius.daf": {
            "source": "iana",
            "extensions": [
                "daf"
            ]
        },
        "application/vnd.mobius.dis": {
            "source": "iana",
            "extensions": [
                "dis"
            ]
        },
        "application/vnd.mobius.mbk": {
            "source": "iana",
            "extensions": [
                "mbk"
            ]
        },
        "application/vnd.mobius.mqy": {
            "source": "iana",
            "extensions": [
                "mqy"
            ]
        },
        "application/vnd.mobius.msl": {
            "source": "iana",
            "extensions": [
                "msl"
            ]
        },
        "application/vnd.mobius.plc": {
            "source": "iana",
            "extensions": [
                "plc"
            ]
        },
        "application/vnd.mobius.txf": {
            "source": "iana",
            "extensions": [
                "txf"
            ]
        },
        "application/vnd.mophun.application": {
            "source": "iana",
            "extensions": [
                "mpn"
            ]
        },
        "application/vnd.mophun.certificate": {
            "source": "iana",
            "extensions": [
                "mpc"
            ]
        },
        "application/vnd.motorola.flexsuite": {
            "source": "iana"
        },
        "application/vnd.motorola.flexsuite.adsi": {
            "source": "iana"
        },
        "application/vnd.motorola.flexsuite.fis": {
            "source": "iana"
        },
        "application/vnd.motorola.flexsuite.gotap": {
            "source": "iana"
        },
        "application/vnd.motorola.flexsuite.kmr": {
            "source": "iana"
        },
        "application/vnd.motorola.flexsuite.ttc": {
            "source": "iana"
        },
        "application/vnd.motorola.flexsuite.wem": {
            "source": "iana"
        },
        "application/vnd.motorola.iprm": {
            "source": "iana"
        },
        "application/vnd.mozilla.xul+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "xul"
            ]
        },
        "application/vnd.ms-3mfdocument": {
            "source": "iana"
        },
        "application/vnd.ms-artgalry": {
            "source": "iana",
            "extensions": [
                "cil"
            ]
        },
        "application/vnd.ms-asf": {
            "source": "iana"
        },
        "application/vnd.ms-cab-compressed": {
            "source": "iana",
            "extensions": [
                "cab"
            ]
        },
        "application/vnd.ms-color.iccprofile": {
            "source": "apache"
        },
        "application/vnd.ms-excel": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "xls",
                "xlm",
                "xla",
                "xlc",
                "xlt",
                "xlw"
            ]
        },
        "application/vnd.ms-excel.addin.macroenabled.12": {
            "source": "iana",
            "extensions": [
                "xlam"
            ]
        },
        "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
            "source": "iana",
            "extensions": [
                "xlsb"
            ]
        },
        "application/vnd.ms-excel.sheet.macroenabled.12": {
            "source": "iana",
            "extensions": [
                "xlsm"
            ]
        },
        "application/vnd.ms-excel.template.macroenabled.12": {
            "source": "iana",
            "extensions": [
                "xltm"
            ]
        },
        "application/vnd.ms-fontobject": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "eot"
            ]
        },
        "application/vnd.ms-htmlhelp": {
            "source": "iana",
            "extensions": [
                "chm"
            ]
        },
        "application/vnd.ms-ims": {
            "source": "iana",
            "extensions": [
                "ims"
            ]
        },
        "application/vnd.ms-lrm": {
            "source": "iana",
            "extensions": [
                "lrm"
            ]
        },
        "application/vnd.ms-office.activex+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.ms-officetheme": {
            "source": "iana",
            "extensions": [
                "thmx"
            ]
        },
        "application/vnd.ms-opentype": {
            "source": "apache",
            "compressible": true
        },
        "application/vnd.ms-outlook": {
            "compressible": false,
            "extensions": [
                "msg"
            ]
        },
        "application/vnd.ms-package.obfuscated-opentype": {
            "source": "apache"
        },
        "application/vnd.ms-pki.seccat": {
            "source": "apache",
            "extensions": [
                "cat"
            ]
        },
        "application/vnd.ms-pki.stl": {
            "source": "apache",
            "extensions": [
                "stl"
            ]
        },
        "application/vnd.ms-playready.initiator+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.ms-powerpoint": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "ppt",
                "pps",
                "pot"
            ]
        },
        "application/vnd.ms-powerpoint.addin.macroenabled.12": {
            "source": "iana",
            "extensions": [
                "ppam"
            ]
        },
        "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
            "source": "iana",
            "extensions": [
                "pptm"
            ]
        },
        "application/vnd.ms-powerpoint.slide.macroenabled.12": {
            "source": "iana",
            "extensions": [
                "sldm"
            ]
        },
        "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
            "source": "iana",
            "extensions": [
                "ppsm"
            ]
        },
        "application/vnd.ms-powerpoint.template.macroenabled.12": {
            "source": "iana",
            "extensions": [
                "potm"
            ]
        },
        "application/vnd.ms-printdevicecapabilities+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.ms-printing.printticket+xml": {
            "source": "apache",
            "compressible": true
        },
        "application/vnd.ms-printschematicket+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.ms-project": {
            "source": "iana",
            "extensions": [
                "mpp",
                "mpt"
            ]
        },
        "application/vnd.ms-tnef": {
            "source": "iana"
        },
        "application/vnd.ms-windows.devicepairing": {
            "source": "iana"
        },
        "application/vnd.ms-windows.nwprinting.oob": {
            "source": "iana"
        },
        "application/vnd.ms-windows.printerpairing": {
            "source": "iana"
        },
        "application/vnd.ms-windows.wsd.oob": {
            "source": "iana"
        },
        "application/vnd.ms-wmdrm.lic-chlg-req": {
            "source": "iana"
        },
        "application/vnd.ms-wmdrm.lic-resp": {
            "source": "iana"
        },
        "application/vnd.ms-wmdrm.meter-chlg-req": {
            "source": "iana"
        },
        "application/vnd.ms-wmdrm.meter-resp": {
            "source": "iana"
        },
        "application/vnd.ms-word.document.macroenabled.12": {
            "source": "iana",
            "extensions": [
                "docm"
            ]
        },
        "application/vnd.ms-word.template.macroenabled.12": {
            "source": "iana",
            "extensions": [
                "dotm"
            ]
        },
        "application/vnd.ms-works": {
            "source": "iana",
            "extensions": [
                "wps",
                "wks",
                "wcm",
                "wdb"
            ]
        },
        "application/vnd.ms-wpl": {
            "source": "iana",
            "extensions": [
                "wpl"
            ]
        },
        "application/vnd.ms-xpsdocument": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "xps"
            ]
        },
        "application/vnd.msa-disk-image": {
            "source": "iana"
        },
        "application/vnd.mseq": {
            "source": "iana",
            "extensions": [
                "mseq"
            ]
        },
        "application/vnd.msign": {
            "source": "iana"
        },
        "application/vnd.multiad.creator": {
            "source": "iana"
        },
        "application/vnd.multiad.creator.cif": {
            "source": "iana"
        },
        "application/vnd.music-niff": {
            "source": "iana"
        },
        "application/vnd.musician": {
            "source": "iana",
            "extensions": [
                "mus"
            ]
        },
        "application/vnd.muvee.style": {
            "source": "iana",
            "extensions": [
                "msty"
            ]
        },
        "application/vnd.mynfc": {
            "source": "iana",
            "extensions": [
                "taglet"
            ]
        },
        "application/vnd.nacamar.ybrid+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.ncd.control": {
            "source": "iana"
        },
        "application/vnd.ncd.reference": {
            "source": "iana"
        },
        "application/vnd.nearst.inv+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.nebumind.line": {
            "source": "iana"
        },
        "application/vnd.nervana": {
            "source": "iana"
        },
        "application/vnd.netfpx": {
            "source": "iana"
        },
        "application/vnd.neurolanguage.nlu": {
            "source": "iana",
            "extensions": [
                "nlu"
            ]
        },
        "application/vnd.nimn": {
            "source": "iana"
        },
        "application/vnd.nintendo.nitro.rom": {
            "source": "iana"
        },
        "application/vnd.nintendo.snes.rom": {
            "source": "iana"
        },
        "application/vnd.nitf": {
            "source": "iana",
            "extensions": [
                "ntf",
                "nitf"
            ]
        },
        "application/vnd.noblenet-directory": {
            "source": "iana",
            "extensions": [
                "nnd"
            ]
        },
        "application/vnd.noblenet-sealer": {
            "source": "iana",
            "extensions": [
                "nns"
            ]
        },
        "application/vnd.noblenet-web": {
            "source": "iana",
            "extensions": [
                "nnw"
            ]
        },
        "application/vnd.nokia.catalogs": {
            "source": "iana"
        },
        "application/vnd.nokia.conml+wbxml": {
            "source": "iana"
        },
        "application/vnd.nokia.conml+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.nokia.iptv.config+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.nokia.isds-radio-presets": {
            "source": "iana"
        },
        "application/vnd.nokia.landmark+wbxml": {
            "source": "iana"
        },
        "application/vnd.nokia.landmark+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.nokia.landmarkcollection+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.nokia.n-gage.ac+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "ac"
            ]
        },
        "application/vnd.nokia.n-gage.data": {
            "source": "iana",
            "extensions": [
                "ngdat"
            ]
        },
        "application/vnd.nokia.n-gage.symbian.install": {
            "source": "iana",
            "extensions": [
                "n-gage"
            ]
        },
        "application/vnd.nokia.ncd": {
            "source": "iana"
        },
        "application/vnd.nokia.pcd+wbxml": {
            "source": "iana"
        },
        "application/vnd.nokia.pcd+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.nokia.radio-preset": {
            "source": "iana",
            "extensions": [
                "rpst"
            ]
        },
        "application/vnd.nokia.radio-presets": {
            "source": "iana",
            "extensions": [
                "rpss"
            ]
        },
        "application/vnd.novadigm.edm": {
            "source": "iana",
            "extensions": [
                "edm"
            ]
        },
        "application/vnd.novadigm.edx": {
            "source": "iana",
            "extensions": [
                "edx"
            ]
        },
        "application/vnd.novadigm.ext": {
            "source": "iana",
            "extensions": [
                "ext"
            ]
        },
        "application/vnd.ntt-local.content-share": {
            "source": "iana"
        },
        "application/vnd.ntt-local.file-transfer": {
            "source": "iana"
        },
        "application/vnd.ntt-local.ogw_remote-access": {
            "source": "iana"
        },
        "application/vnd.ntt-local.sip-ta_remote": {
            "source": "iana"
        },
        "application/vnd.ntt-local.sip-ta_tcp_stream": {
            "source": "iana"
        },
        "application/vnd.oasis.opendocument.chart": {
            "source": "iana",
            "extensions": [
                "odc"
            ]
        },
        "application/vnd.oasis.opendocument.chart-template": {
            "source": "iana",
            "extensions": [
                "otc"
            ]
        },
        "application/vnd.oasis.opendocument.database": {
            "source": "iana",
            "extensions": [
                "odb"
            ]
        },
        "application/vnd.oasis.opendocument.formula": {
            "source": "iana",
            "extensions": [
                "odf"
            ]
        },
        "application/vnd.oasis.opendocument.formula-template": {
            "source": "iana",
            "extensions": [
                "odft"
            ]
        },
        "application/vnd.oasis.opendocument.graphics": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "odg"
            ]
        },
        "application/vnd.oasis.opendocument.graphics-template": {
            "source": "iana",
            "extensions": [
                "otg"
            ]
        },
        "application/vnd.oasis.opendocument.image": {
            "source": "iana",
            "extensions": [
                "odi"
            ]
        },
        "application/vnd.oasis.opendocument.image-template": {
            "source": "iana",
            "extensions": [
                "oti"
            ]
        },
        "application/vnd.oasis.opendocument.presentation": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "odp"
            ]
        },
        "application/vnd.oasis.opendocument.presentation-template": {
            "source": "iana",
            "extensions": [
                "otp"
            ]
        },
        "application/vnd.oasis.opendocument.spreadsheet": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "ods"
            ]
        },
        "application/vnd.oasis.opendocument.spreadsheet-template": {
            "source": "iana",
            "extensions": [
                "ots"
            ]
        },
        "application/vnd.oasis.opendocument.text": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "odt"
            ]
        },
        "application/vnd.oasis.opendocument.text-master": {
            "source": "iana",
            "extensions": [
                "odm"
            ]
        },
        "application/vnd.oasis.opendocument.text-template": {
            "source": "iana",
            "extensions": [
                "ott"
            ]
        },
        "application/vnd.oasis.opendocument.text-web": {
            "source": "iana",
            "extensions": [
                "oth"
            ]
        },
        "application/vnd.obn": {
            "source": "iana"
        },
        "application/vnd.ocf+cbor": {
            "source": "iana"
        },
        "application/vnd.oci.image.manifest.v1+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.oftn.l10n+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.oipf.contentaccessdownload+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.oipf.contentaccessstreaming+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.oipf.cspg-hexbinary": {
            "source": "iana"
        },
        "application/vnd.oipf.dae.svg+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.oipf.dae.xhtml+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.oipf.mippvcontrolmessage+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.oipf.pae.gem": {
            "source": "iana"
        },
        "application/vnd.oipf.spdiscovery+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.oipf.spdlist+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.oipf.ueprofile+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.oipf.userprofile+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.olpc-sugar": {
            "source": "iana",
            "extensions": [
                "xo"
            ]
        },
        "application/vnd.oma-scws-config": {
            "source": "iana"
        },
        "application/vnd.oma-scws-http-request": {
            "source": "iana"
        },
        "application/vnd.oma-scws-http-response": {
            "source": "iana"
        },
        "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.oma.bcast.drm-trigger+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.oma.bcast.imd+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.oma.bcast.ltkm": {
            "source": "iana"
        },
        "application/vnd.oma.bcast.notification+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.oma.bcast.provisioningtrigger": {
            "source": "iana"
        },
        "application/vnd.oma.bcast.sgboot": {
            "source": "iana"
        },
        "application/vnd.oma.bcast.sgdd+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.oma.bcast.sgdu": {
            "source": "iana"
        },
        "application/vnd.oma.bcast.simple-symbol-container": {
            "source": "iana"
        },
        "application/vnd.oma.bcast.smartcard-trigger+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.oma.bcast.sprov+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.oma.bcast.stkm": {
            "source": "iana"
        },
        "application/vnd.oma.cab-address-book+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.oma.cab-feature-handler+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.oma.cab-pcc+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.oma.cab-subs-invite+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.oma.cab-user-prefs+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.oma.dcd": {
            "source": "iana"
        },
        "application/vnd.oma.dcdc": {
            "source": "iana"
        },
        "application/vnd.oma.dd2+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "dd2"
            ]
        },
        "application/vnd.oma.drm.risd+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.oma.group-usage-list+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.oma.lwm2m+cbor": {
            "source": "iana"
        },
        "application/vnd.oma.lwm2m+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.oma.lwm2m+tlv": {
            "source": "iana"
        },
        "application/vnd.oma.pal+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.oma.poc.detailed-progress-report+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.oma.poc.final-report+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.oma.poc.groups+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.oma.poc.invocation-descriptor+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.oma.poc.optimized-progress-report+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.oma.push": {
            "source": "iana"
        },
        "application/vnd.oma.scidm.messages+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.oma.xcap-directory+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.omads-email+xml": {
            "source": "iana",
            "charset": "UTF-8",
            "compressible": true
        },
        "application/vnd.omads-file+xml": {
            "source": "iana",
            "charset": "UTF-8",
            "compressible": true
        },
        "application/vnd.omads-folder+xml": {
            "source": "iana",
            "charset": "UTF-8",
            "compressible": true
        },
        "application/vnd.omaloc-supl-init": {
            "source": "iana"
        },
        "application/vnd.onepager": {
            "source": "iana"
        },
        "application/vnd.onepagertamp": {
            "source": "iana"
        },
        "application/vnd.onepagertamx": {
            "source": "iana"
        },
        "application/vnd.onepagertat": {
            "source": "iana"
        },
        "application/vnd.onepagertatp": {
            "source": "iana"
        },
        "application/vnd.onepagertatx": {
            "source": "iana"
        },
        "application/vnd.openblox.game+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "obgx"
            ]
        },
        "application/vnd.openblox.game-binary": {
            "source": "iana"
        },
        "application/vnd.openeye.oeb": {
            "source": "iana"
        },
        "application/vnd.openofficeorg.extension": {
            "source": "apache",
            "extensions": [
                "oxt"
            ]
        },
        "application/vnd.openstreetmap.data+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "osm"
            ]
        },
        "application/vnd.opentimestamps.ots": {
            "source": "iana"
        },
        "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.drawing+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "pptx"
            ]
        },
        "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slide": {
            "source": "iana",
            "extensions": [
                "sldx"
            ]
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
            "source": "iana",
            "extensions": [
                "ppsx"
            ]
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.template": {
            "source": "iana",
            "extensions": [
                "potx"
            ]
        },
        "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "xlsx"
            ]
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
            "source": "iana",
            "extensions": [
                "xltx"
            ]
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.theme+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.vmldrawing": {
            "source": "iana"
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "docx"
            ]
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
            "source": "iana",
            "extensions": [
                "dotx"
            ]
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-package.core-properties+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.openxmlformats-package.relationships+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.oracle.resource+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.orange.indata": {
            "source": "iana"
        },
        "application/vnd.osa.netdeploy": {
            "source": "iana"
        },
        "application/vnd.osgeo.mapguide.package": {
            "source": "iana",
            "extensions": [
                "mgp"
            ]
        },
        "application/vnd.osgi.bundle": {
            "source": "iana"
        },
        "application/vnd.osgi.dp": {
            "source": "iana",
            "extensions": [
                "dp"
            ]
        },
        "application/vnd.osgi.subsystem": {
            "source": "iana",
            "extensions": [
                "esa"
            ]
        },
        "application/vnd.otps.ct-kip+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.oxli.countgraph": {
            "source": "iana"
        },
        "application/vnd.pagerduty+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.palm": {
            "source": "iana",
            "extensions": [
                "pdb",
                "pqa",
                "oprc"
            ]
        },
        "application/vnd.panoply": {
            "source": "iana"
        },
        "application/vnd.paos.xml": {
            "source": "iana"
        },
        "application/vnd.patentdive": {
            "source": "iana"
        },
        "application/vnd.patientecommsdoc": {
            "source": "iana"
        },
        "application/vnd.pawaafile": {
            "source": "iana",
            "extensions": [
                "paw"
            ]
        },
        "application/vnd.pcos": {
            "source": "iana"
        },
        "application/vnd.pg.format": {
            "source": "iana",
            "extensions": [
                "str"
            ]
        },
        "application/vnd.pg.osasli": {
            "source": "iana",
            "extensions": [
                "ei6"
            ]
        },
        "application/vnd.piaccess.application-licence": {
            "source": "iana"
        },
        "application/vnd.picsel": {
            "source": "iana",
            "extensions": [
                "efif"
            ]
        },
        "application/vnd.pmi.widget": {
            "source": "iana",
            "extensions": [
                "wg"
            ]
        },
        "application/vnd.poc.group-advertisement+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.pocketlearn": {
            "source": "iana",
            "extensions": [
                "plf"
            ]
        },
        "application/vnd.powerbuilder6": {
            "source": "iana",
            "extensions": [
                "pbd"
            ]
        },
        "application/vnd.powerbuilder6-s": {
            "source": "iana"
        },
        "application/vnd.powerbuilder7": {
            "source": "iana"
        },
        "application/vnd.powerbuilder7-s": {
            "source": "iana"
        },
        "application/vnd.powerbuilder75": {
            "source": "iana"
        },
        "application/vnd.powerbuilder75-s": {
            "source": "iana"
        },
        "application/vnd.preminet": {
            "source": "iana"
        },
        "application/vnd.previewsystems.box": {
            "source": "iana",
            "extensions": [
                "box"
            ]
        },
        "application/vnd.proteus.magazine": {
            "source": "iana",
            "extensions": [
                "mgz"
            ]
        },
        "application/vnd.psfs": {
            "source": "iana"
        },
        "application/vnd.publishare-delta-tree": {
            "source": "iana",
            "extensions": [
                "qps"
            ]
        },
        "application/vnd.pvi.ptid1": {
            "source": "iana",
            "extensions": [
                "ptid"
            ]
        },
        "application/vnd.pwg-multiplexed": {
            "source": "iana"
        },
        "application/vnd.pwg-xhtml-print+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.qualcomm.brew-app-res": {
            "source": "iana"
        },
        "application/vnd.quarantainenet": {
            "source": "iana"
        },
        "application/vnd.quark.quarkxpress": {
            "source": "iana",
            "extensions": [
                "qxd",
                "qxt",
                "qwd",
                "qwt",
                "qxl",
                "qxb"
            ]
        },
        "application/vnd.quobject-quoxdocument": {
            "source": "iana"
        },
        "application/vnd.radisys.moml+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.radisys.msml+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.radisys.msml-audit+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.radisys.msml-audit-conf+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.radisys.msml-audit-conn+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.radisys.msml-audit-dialog+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.radisys.msml-audit-stream+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.radisys.msml-conf+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.radisys.msml-dialog+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.radisys.msml-dialog-base+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.radisys.msml-dialog-fax-detect+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.radisys.msml-dialog-group+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.radisys.msml-dialog-speech+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.radisys.msml-dialog-transform+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.rainstor.data": {
            "source": "iana"
        },
        "application/vnd.rapid": {
            "source": "iana"
        },
        "application/vnd.rar": {
            "source": "iana",
            "extensions": [
                "rar"
            ]
        },
        "application/vnd.realvnc.bed": {
            "source": "iana",
            "extensions": [
                "bed"
            ]
        },
        "application/vnd.recordare.musicxml": {
            "source": "iana",
            "extensions": [
                "mxl"
            ]
        },
        "application/vnd.recordare.musicxml+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "musicxml"
            ]
        },
        "application/vnd.renlearn.rlprint": {
            "source": "iana"
        },
        "application/vnd.resilient.logic": {
            "source": "iana"
        },
        "application/vnd.restful+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.rig.cryptonote": {
            "source": "iana",
            "extensions": [
                "cryptonote"
            ]
        },
        "application/vnd.rim.cod": {
            "source": "apache",
            "extensions": [
                "cod"
            ]
        },
        "application/vnd.rn-realmedia": {
            "source": "apache",
            "extensions": [
                "rm"
            ]
        },
        "application/vnd.rn-realmedia-vbr": {
            "source": "apache",
            "extensions": [
                "rmvb"
            ]
        },
        "application/vnd.route66.link66+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "link66"
            ]
        },
        "application/vnd.rs-274x": {
            "source": "iana"
        },
        "application/vnd.ruckus.download": {
            "source": "iana"
        },
        "application/vnd.s3sms": {
            "source": "iana"
        },
        "application/vnd.sailingtracker.track": {
            "source": "iana",
            "extensions": [
                "st"
            ]
        },
        "application/vnd.sar": {
            "source": "iana"
        },
        "application/vnd.sbm.cid": {
            "source": "iana"
        },
        "application/vnd.sbm.mid2": {
            "source": "iana"
        },
        "application/vnd.scribus": {
            "source": "iana"
        },
        "application/vnd.sealed.3df": {
            "source": "iana"
        },
        "application/vnd.sealed.csf": {
            "source": "iana"
        },
        "application/vnd.sealed.doc": {
            "source": "iana"
        },
        "application/vnd.sealed.eml": {
            "source": "iana"
        },
        "application/vnd.sealed.mht": {
            "source": "iana"
        },
        "application/vnd.sealed.net": {
            "source": "iana"
        },
        "application/vnd.sealed.ppt": {
            "source": "iana"
        },
        "application/vnd.sealed.tiff": {
            "source": "iana"
        },
        "application/vnd.sealed.xls": {
            "source": "iana"
        },
        "application/vnd.sealedmedia.softseal.html": {
            "source": "iana"
        },
        "application/vnd.sealedmedia.softseal.pdf": {
            "source": "iana"
        },
        "application/vnd.seemail": {
            "source": "iana",
            "extensions": [
                "see"
            ]
        },
        "application/vnd.seis+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.sema": {
            "source": "iana",
            "extensions": [
                "sema"
            ]
        },
        "application/vnd.semd": {
            "source": "iana",
            "extensions": [
                "semd"
            ]
        },
        "application/vnd.semf": {
            "source": "iana",
            "extensions": [
                "semf"
            ]
        },
        "application/vnd.shade-save-file": {
            "source": "iana"
        },
        "application/vnd.shana.informed.formdata": {
            "source": "iana",
            "extensions": [
                "ifm"
            ]
        },
        "application/vnd.shana.informed.formtemplate": {
            "source": "iana",
            "extensions": [
                "itp"
            ]
        },
        "application/vnd.shana.informed.interchange": {
            "source": "iana",
            "extensions": [
                "iif"
            ]
        },
        "application/vnd.shana.informed.package": {
            "source": "iana",
            "extensions": [
                "ipk"
            ]
        },
        "application/vnd.shootproof+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.shopkick+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.shp": {
            "source": "iana"
        },
        "application/vnd.shx": {
            "source": "iana"
        },
        "application/vnd.sigrok.session": {
            "source": "iana"
        },
        "application/vnd.simtech-mindmapper": {
            "source": "iana",
            "extensions": [
                "twd",
                "twds"
            ]
        },
        "application/vnd.siren+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.smaf": {
            "source": "iana",
            "extensions": [
                "mmf"
            ]
        },
        "application/vnd.smart.notebook": {
            "source": "iana"
        },
        "application/vnd.smart.teacher": {
            "source": "iana",
            "extensions": [
                "teacher"
            ]
        },
        "application/vnd.snesdev-page-table": {
            "source": "iana"
        },
        "application/vnd.software602.filler.form+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "fo"
            ]
        },
        "application/vnd.software602.filler.form-xml-zip": {
            "source": "iana"
        },
        "application/vnd.solent.sdkm+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "sdkm",
                "sdkd"
            ]
        },
        "application/vnd.spotfire.dxp": {
            "source": "iana",
            "extensions": [
                "dxp"
            ]
        },
        "application/vnd.spotfire.sfs": {
            "source": "iana",
            "extensions": [
                "sfs"
            ]
        },
        "application/vnd.sqlite3": {
            "source": "iana"
        },
        "application/vnd.sss-cod": {
            "source": "iana"
        },
        "application/vnd.sss-dtf": {
            "source": "iana"
        },
        "application/vnd.sss-ntf": {
            "source": "iana"
        },
        "application/vnd.stardivision.calc": {
            "source": "apache",
            "extensions": [
                "sdc"
            ]
        },
        "application/vnd.stardivision.draw": {
            "source": "apache",
            "extensions": [
                "sda"
            ]
        },
        "application/vnd.stardivision.impress": {
            "source": "apache",
            "extensions": [
                "sdd"
            ]
        },
        "application/vnd.stardivision.math": {
            "source": "apache",
            "extensions": [
                "smf"
            ]
        },
        "application/vnd.stardivision.writer": {
            "source": "apache",
            "extensions": [
                "sdw",
                "vor"
            ]
        },
        "application/vnd.stardivision.writer-global": {
            "source": "apache",
            "extensions": [
                "sgl"
            ]
        },
        "application/vnd.stepmania.package": {
            "source": "iana",
            "extensions": [
                "smzip"
            ]
        },
        "application/vnd.stepmania.stepchart": {
            "source": "iana",
            "extensions": [
                "sm"
            ]
        },
        "application/vnd.street-stream": {
            "source": "iana"
        },
        "application/vnd.sun.wadl+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "wadl"
            ]
        },
        "application/vnd.sun.xml.calc": {
            "source": "apache",
            "extensions": [
                "sxc"
            ]
        },
        "application/vnd.sun.xml.calc.template": {
            "source": "apache",
            "extensions": [
                "stc"
            ]
        },
        "application/vnd.sun.xml.draw": {
            "source": "apache",
            "extensions": [
                "sxd"
            ]
        },
        "application/vnd.sun.xml.draw.template": {
            "source": "apache",
            "extensions": [
                "std"
            ]
        },
        "application/vnd.sun.xml.impress": {
            "source": "apache",
            "extensions": [
                "sxi"
            ]
        },
        "application/vnd.sun.xml.impress.template": {
            "source": "apache",
            "extensions": [
                "sti"
            ]
        },
        "application/vnd.sun.xml.math": {
            "source": "apache",
            "extensions": [
                "sxm"
            ]
        },
        "application/vnd.sun.xml.writer": {
            "source": "apache",
            "extensions": [
                "sxw"
            ]
        },
        "application/vnd.sun.xml.writer.global": {
            "source": "apache",
            "extensions": [
                "sxg"
            ]
        },
        "application/vnd.sun.xml.writer.template": {
            "source": "apache",
            "extensions": [
                "stw"
            ]
        },
        "application/vnd.sus-calendar": {
            "source": "iana",
            "extensions": [
                "sus",
                "susp"
            ]
        },
        "application/vnd.svd": {
            "source": "iana",
            "extensions": [
                "svd"
            ]
        },
        "application/vnd.swiftview-ics": {
            "source": "iana"
        },
        "application/vnd.sycle+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.syft+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.symbian.install": {
            "source": "apache",
            "extensions": [
                "sis",
                "sisx"
            ]
        },
        "application/vnd.syncml+xml": {
            "source": "iana",
            "charset": "UTF-8",
            "compressible": true,
            "extensions": [
                "xsm"
            ]
        },
        "application/vnd.syncml.dm+wbxml": {
            "source": "iana",
            "charset": "UTF-8",
            "extensions": [
                "bdm"
            ]
        },
        "application/vnd.syncml.dm+xml": {
            "source": "iana",
            "charset": "UTF-8",
            "compressible": true,
            "extensions": [
                "xdm"
            ]
        },
        "application/vnd.syncml.dm.notification": {
            "source": "iana"
        },
        "application/vnd.syncml.dmddf+wbxml": {
            "source": "iana"
        },
        "application/vnd.syncml.dmddf+xml": {
            "source": "iana",
            "charset": "UTF-8",
            "compressible": true,
            "extensions": [
                "ddf"
            ]
        },
        "application/vnd.syncml.dmtnds+wbxml": {
            "source": "iana"
        },
        "application/vnd.syncml.dmtnds+xml": {
            "source": "iana",
            "charset": "UTF-8",
            "compressible": true
        },
        "application/vnd.syncml.ds.notification": {
            "source": "iana"
        },
        "application/vnd.tableschema+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.tao.intent-module-archive": {
            "source": "iana",
            "extensions": [
                "tao"
            ]
        },
        "application/vnd.tcpdump.pcap": {
            "source": "iana",
            "extensions": [
                "pcap",
                "cap",
                "dmp"
            ]
        },
        "application/vnd.think-cell.ppttc+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.tmd.mediaflex.api+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.tml": {
            "source": "iana"
        },
        "application/vnd.tmobile-livetv": {
            "source": "iana",
            "extensions": [
                "tmo"
            ]
        },
        "application/vnd.tri.onesource": {
            "source": "iana"
        },
        "application/vnd.trid.tpt": {
            "source": "iana",
            "extensions": [
                "tpt"
            ]
        },
        "application/vnd.triscape.mxs": {
            "source": "iana",
            "extensions": [
                "mxs"
            ]
        },
        "application/vnd.trueapp": {
            "source": "iana",
            "extensions": [
                "tra"
            ]
        },
        "application/vnd.truedoc": {
            "source": "iana"
        },
        "application/vnd.ubisoft.webplayer": {
            "source": "iana"
        },
        "application/vnd.ufdl": {
            "source": "iana",
            "extensions": [
                "ufd",
                "ufdl"
            ]
        },
        "application/vnd.uiq.theme": {
            "source": "iana",
            "extensions": [
                "utz"
            ]
        },
        "application/vnd.umajin": {
            "source": "iana",
            "extensions": [
                "umj"
            ]
        },
        "application/vnd.unity": {
            "source": "iana",
            "extensions": [
                "unityweb"
            ]
        },
        "application/vnd.uoml+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "uoml"
            ]
        },
        "application/vnd.uplanet.alert": {
            "source": "iana"
        },
        "application/vnd.uplanet.alert-wbxml": {
            "source": "iana"
        },
        "application/vnd.uplanet.bearer-choice": {
            "source": "iana"
        },
        "application/vnd.uplanet.bearer-choice-wbxml": {
            "source": "iana"
        },
        "application/vnd.uplanet.cacheop": {
            "source": "iana"
        },
        "application/vnd.uplanet.cacheop-wbxml": {
            "source": "iana"
        },
        "application/vnd.uplanet.channel": {
            "source": "iana"
        },
        "application/vnd.uplanet.channel-wbxml": {
            "source": "iana"
        },
        "application/vnd.uplanet.list": {
            "source": "iana"
        },
        "application/vnd.uplanet.list-wbxml": {
            "source": "iana"
        },
        "application/vnd.uplanet.listcmd": {
            "source": "iana"
        },
        "application/vnd.uplanet.listcmd-wbxml": {
            "source": "iana"
        },
        "application/vnd.uplanet.signal": {
            "source": "iana"
        },
        "application/vnd.uri-map": {
            "source": "iana"
        },
        "application/vnd.valve.source.material": {
            "source": "iana"
        },
        "application/vnd.vcx": {
            "source": "iana",
            "extensions": [
                "vcx"
            ]
        },
        "application/vnd.vd-study": {
            "source": "iana"
        },
        "application/vnd.vectorworks": {
            "source": "iana"
        },
        "application/vnd.vel+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.verimatrix.vcas": {
            "source": "iana"
        },
        "application/vnd.veritone.aion+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.veryant.thin": {
            "source": "iana"
        },
        "application/vnd.ves.encrypted": {
            "source": "iana"
        },
        "application/vnd.vidsoft.vidconference": {
            "source": "iana"
        },
        "application/vnd.visio": {
            "source": "iana",
            "extensions": [
                "vsd",
                "vst",
                "vss",
                "vsw"
            ]
        },
        "application/vnd.visionary": {
            "source": "iana",
            "extensions": [
                "vis"
            ]
        },
        "application/vnd.vividence.scriptfile": {
            "source": "iana"
        },
        "application/vnd.vsf": {
            "source": "iana",
            "extensions": [
                "vsf"
            ]
        },
        "application/vnd.wap.sic": {
            "source": "iana"
        },
        "application/vnd.wap.slc": {
            "source": "iana"
        },
        "application/vnd.wap.wbxml": {
            "source": "iana",
            "charset": "UTF-8",
            "extensions": [
                "wbxml"
            ]
        },
        "application/vnd.wap.wmlc": {
            "source": "iana",
            "extensions": [
                "wmlc"
            ]
        },
        "application/vnd.wap.wmlscriptc": {
            "source": "iana",
            "extensions": [
                "wmlsc"
            ]
        },
        "application/vnd.webturbo": {
            "source": "iana",
            "extensions": [
                "wtb"
            ]
        },
        "application/vnd.wfa.dpp": {
            "source": "iana"
        },
        "application/vnd.wfa.p2p": {
            "source": "iana"
        },
        "application/vnd.wfa.wsc": {
            "source": "iana"
        },
        "application/vnd.windows.devicepairing": {
            "source": "iana"
        },
        "application/vnd.wmc": {
            "source": "iana"
        },
        "application/vnd.wmf.bootstrap": {
            "source": "iana"
        },
        "application/vnd.wolfram.mathematica": {
            "source": "iana"
        },
        "application/vnd.wolfram.mathematica.package": {
            "source": "iana"
        },
        "application/vnd.wolfram.player": {
            "source": "iana",
            "extensions": [
                "nbp"
            ]
        },
        "application/vnd.wordperfect": {
            "source": "iana",
            "extensions": [
                "wpd"
            ]
        },
        "application/vnd.wqd": {
            "source": "iana",
            "extensions": [
                "wqd"
            ]
        },
        "application/vnd.wrq-hp3000-labelled": {
            "source": "iana"
        },
        "application/vnd.wt.stf": {
            "source": "iana",
            "extensions": [
                "stf"
            ]
        },
        "application/vnd.wv.csp+wbxml": {
            "source": "iana"
        },
        "application/vnd.wv.csp+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.wv.ssp+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.xacml+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.xara": {
            "source": "iana",
            "extensions": [
                "xar"
            ]
        },
        "application/vnd.xfdl": {
            "source": "iana",
            "extensions": [
                "xfdl"
            ]
        },
        "application/vnd.xfdl.webform": {
            "source": "iana"
        },
        "application/vnd.xmi+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/vnd.xmpie.cpkg": {
            "source": "iana"
        },
        "application/vnd.xmpie.dpkg": {
            "source": "iana"
        },
        "application/vnd.xmpie.plan": {
            "source": "iana"
        },
        "application/vnd.xmpie.ppkg": {
            "source": "iana"
        },
        "application/vnd.xmpie.xlim": {
            "source": "iana"
        },
        "application/vnd.yamaha.hv-dic": {
            "source": "iana",
            "extensions": [
                "hvd"
            ]
        },
        "application/vnd.yamaha.hv-script": {
            "source": "iana",
            "extensions": [
                "hvs"
            ]
        },
        "application/vnd.yamaha.hv-voice": {
            "source": "iana",
            "extensions": [
                "hvp"
            ]
        },
        "application/vnd.yamaha.openscoreformat": {
            "source": "iana",
            "extensions": [
                "osf"
            ]
        },
        "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "osfpvg"
            ]
        },
        "application/vnd.yamaha.remote-setup": {
            "source": "iana"
        },
        "application/vnd.yamaha.smaf-audio": {
            "source": "iana",
            "extensions": [
                "saf"
            ]
        },
        "application/vnd.yamaha.smaf-phrase": {
            "source": "iana",
            "extensions": [
                "spf"
            ]
        },
        "application/vnd.yamaha.through-ngn": {
            "source": "iana"
        },
        "application/vnd.yamaha.tunnel-udpencap": {
            "source": "iana"
        },
        "application/vnd.yaoweme": {
            "source": "iana"
        },
        "application/vnd.yellowriver-custom-menu": {
            "source": "iana",
            "extensions": [
                "cmp"
            ]
        },
        "application/vnd.youtube.yt": {
            "source": "iana"
        },
        "application/vnd.zul": {
            "source": "iana",
            "extensions": [
                "zir",
                "zirz"
            ]
        },
        "application/vnd.zzazz.deck+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "zaz"
            ]
        },
        "application/voicexml+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "vxml"
            ]
        },
        "application/voucher-cms+json": {
            "source": "iana",
            "compressible": true
        },
        "application/vq-rtcpxr": {
            "source": "iana"
        },
        "application/wasm": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "wasm"
            ]
        },
        "application/watcherinfo+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "wif"
            ]
        },
        "application/webpush-options+json": {
            "source": "iana",
            "compressible": true
        },
        "application/whoispp-query": {
            "source": "iana"
        },
        "application/whoispp-response": {
            "source": "iana"
        },
        "application/widget": {
            "source": "iana",
            "extensions": [
                "wgt"
            ]
        },
        "application/winhlp": {
            "source": "apache",
            "extensions": [
                "hlp"
            ]
        },
        "application/wita": {
            "source": "iana"
        },
        "application/wordperfect5.1": {
            "source": "iana"
        },
        "application/wsdl+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "wsdl"
            ]
        },
        "application/wspolicy+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "wspolicy"
            ]
        },
        "application/x-7z-compressed": {
            "source": "apache",
            "compressible": false,
            "extensions": [
                "7z"
            ]
        },
        "application/x-abiword": {
            "source": "apache",
            "extensions": [
                "abw"
            ]
        },
        "application/x-ace-compressed": {
            "source": "apache",
            "extensions": [
                "ace"
            ]
        },
        "application/x-amf": {
            "source": "apache"
        },
        "application/x-apple-diskimage": {
            "source": "apache",
            "extensions": [
                "dmg"
            ]
        },
        "application/x-arj": {
            "compressible": false,
            "extensions": [
                "arj"
            ]
        },
        "application/x-authorware-bin": {
            "source": "apache",
            "extensions": [
                "aab",
                "x32",
                "u32",
                "vox"
            ]
        },
        "application/x-authorware-map": {
            "source": "apache",
            "extensions": [
                "aam"
            ]
        },
        "application/x-authorware-seg": {
            "source": "apache",
            "extensions": [
                "aas"
            ]
        },
        "application/x-bcpio": {
            "source": "apache",
            "extensions": [
                "bcpio"
            ]
        },
        "application/x-bdoc": {
            "compressible": false,
            "extensions": [
                "bdoc"
            ]
        },
        "application/x-bittorrent": {
            "source": "apache",
            "extensions": [
                "torrent"
            ]
        },
        "application/x-blorb": {
            "source": "apache",
            "extensions": [
                "blb",
                "blorb"
            ]
        },
        "application/x-bzip": {
            "source": "apache",
            "compressible": false,
            "extensions": [
                "bz"
            ]
        },
        "application/x-bzip2": {
            "source": "apache",
            "compressible": false,
            "extensions": [
                "bz2",
                "boz"
            ]
        },
        "application/x-cbr": {
            "source": "apache",
            "extensions": [
                "cbr",
                "cba",
                "cbt",
                "cbz",
                "cb7"
            ]
        },
        "application/x-cdlink": {
            "source": "apache",
            "extensions": [
                "vcd"
            ]
        },
        "application/x-cfs-compressed": {
            "source": "apache",
            "extensions": [
                "cfs"
            ]
        },
        "application/x-chat": {
            "source": "apache",
            "extensions": [
                "chat"
            ]
        },
        "application/x-chess-pgn": {
            "source": "apache",
            "extensions": [
                "pgn"
            ]
        },
        "application/x-chrome-extension": {
            "extensions": [
                "crx"
            ]
        },
        "application/x-cocoa": {
            "source": "nginx",
            "extensions": [
                "cco"
            ]
        },
        "application/x-compress": {
            "source": "apache"
        },
        "application/x-conference": {
            "source": "apache",
            "extensions": [
                "nsc"
            ]
        },
        "application/x-cpio": {
            "source": "apache",
            "extensions": [
                "cpio"
            ]
        },
        "application/x-csh": {
            "source": "apache",
            "extensions": [
                "csh"
            ]
        },
        "application/x-deb": {
            "compressible": false
        },
        "application/x-debian-package": {
            "source": "apache",
            "extensions": [
                "deb",
                "udeb"
            ]
        },
        "application/x-dgc-compressed": {
            "source": "apache",
            "extensions": [
                "dgc"
            ]
        },
        "application/x-director": {
            "source": "apache",
            "extensions": [
                "dir",
                "dcr",
                "dxr",
                "cst",
                "cct",
                "cxt",
                "w3d",
                "fgd",
                "swa"
            ]
        },
        "application/x-doom": {
            "source": "apache",
            "extensions": [
                "wad"
            ]
        },
        "application/x-dtbncx+xml": {
            "source": "apache",
            "compressible": true,
            "extensions": [
                "ncx"
            ]
        },
        "application/x-dtbook+xml": {
            "source": "apache",
            "compressible": true,
            "extensions": [
                "dtb"
            ]
        },
        "application/x-dtbresource+xml": {
            "source": "apache",
            "compressible": true,
            "extensions": [
                "res"
            ]
        },
        "application/x-dvi": {
            "source": "apache",
            "compressible": false,
            "extensions": [
                "dvi"
            ]
        },
        "application/x-envoy": {
            "source": "apache",
            "extensions": [
                "evy"
            ]
        },
        "application/x-eva": {
            "source": "apache",
            "extensions": [
                "eva"
            ]
        },
        "application/x-font-bdf": {
            "source": "apache",
            "extensions": [
                "bdf"
            ]
        },
        "application/x-font-dos": {
            "source": "apache"
        },
        "application/x-font-framemaker": {
            "source": "apache"
        },
        "application/x-font-ghostscript": {
            "source": "apache",
            "extensions": [
                "gsf"
            ]
        },
        "application/x-font-libgrx": {
            "source": "apache"
        },
        "application/x-font-linux-psf": {
            "source": "apache",
            "extensions": [
                "psf"
            ]
        },
        "application/x-font-pcf": {
            "source": "apache",
            "extensions": [
                "pcf"
            ]
        },
        "application/x-font-snf": {
            "source": "apache",
            "extensions": [
                "snf"
            ]
        },
        "application/x-font-speedo": {
            "source": "apache"
        },
        "application/x-font-sunos-news": {
            "source": "apache"
        },
        "application/x-font-type1": {
            "source": "apache",
            "extensions": [
                "pfa",
                "pfb",
                "pfm",
                "afm"
            ]
        },
        "application/x-font-vfont": {
            "source": "apache"
        },
        "application/x-freearc": {
            "source": "apache",
            "extensions": [
                "arc"
            ]
        },
        "application/x-futuresplash": {
            "source": "apache",
            "extensions": [
                "spl"
            ]
        },
        "application/x-gca-compressed": {
            "source": "apache",
            "extensions": [
                "gca"
            ]
        },
        "application/x-glulx": {
            "source": "apache",
            "extensions": [
                "ulx"
            ]
        },
        "application/x-gnumeric": {
            "source": "apache",
            "extensions": [
                "gnumeric"
            ]
        },
        "application/x-gramps-xml": {
            "source": "apache",
            "extensions": [
                "gramps"
            ]
        },
        "application/x-gtar": {
            "source": "apache",
            "extensions": [
                "gtar"
            ]
        },
        "application/x-gzip": {
            "source": "apache"
        },
        "application/x-hdf": {
            "source": "apache",
            "extensions": [
                "hdf"
            ]
        },
        "application/x-httpd-php": {
            "compressible": true,
            "extensions": [
                "php"
            ]
        },
        "application/x-install-instructions": {
            "source": "apache",
            "extensions": [
                "install"
            ]
        },
        "application/x-iso9660-image": {
            "source": "apache",
            "extensions": [
                "iso"
            ]
        },
        "application/x-iwork-keynote-sffkey": {
            "extensions": [
                "key"
            ]
        },
        "application/x-iwork-numbers-sffnumbers": {
            "extensions": [
                "numbers"
            ]
        },
        "application/x-iwork-pages-sffpages": {
            "extensions": [
                "pages"
            ]
        },
        "application/x-java-archive-diff": {
            "source": "nginx",
            "extensions": [
                "jardiff"
            ]
        },
        "application/x-java-jnlp-file": {
            "source": "apache",
            "compressible": false,
            "extensions": [
                "jnlp"
            ]
        },
        "application/x-javascript": {
            "compressible": true
        },
        "application/x-keepass2": {
            "extensions": [
                "kdbx"
            ]
        },
        "application/x-latex": {
            "source": "apache",
            "compressible": false,
            "extensions": [
                "latex"
            ]
        },
        "application/x-lua-bytecode": {
            "extensions": [
                "luac"
            ]
        },
        "application/x-lzh-compressed": {
            "source": "apache",
            "extensions": [
                "lzh",
                "lha"
            ]
        },
        "application/x-makeself": {
            "source": "nginx",
            "extensions": [
                "run"
            ]
        },
        "application/x-mie": {
            "source": "apache",
            "extensions": [
                "mie"
            ]
        },
        "application/x-mobipocket-ebook": {
            "source": "apache",
            "extensions": [
                "prc",
                "mobi"
            ]
        },
        "application/x-mpegurl": {
            "compressible": false
        },
        "application/x-ms-application": {
            "source": "apache",
            "extensions": [
                "application"
            ]
        },
        "application/x-ms-shortcut": {
            "source": "apache",
            "extensions": [
                "lnk"
            ]
        },
        "application/x-ms-wmd": {
            "source": "apache",
            "extensions": [
                "wmd"
            ]
        },
        "application/x-ms-wmz": {
            "source": "apache",
            "extensions": [
                "wmz"
            ]
        },
        "application/x-ms-xbap": {
            "source": "apache",
            "extensions": [
                "xbap"
            ]
        },
        "application/x-msaccess": {
            "source": "apache",
            "extensions": [
                "mdb"
            ]
        },
        "application/x-msbinder": {
            "source": "apache",
            "extensions": [
                "obd"
            ]
        },
        "application/x-mscardfile": {
            "source": "apache",
            "extensions": [
                "crd"
            ]
        },
        "application/x-msclip": {
            "source": "apache",
            "extensions": [
                "clp"
            ]
        },
        "application/x-msdos-program": {
            "extensions": [
                "exe"
            ]
        },
        "application/x-msdownload": {
            "source": "apache",
            "extensions": [
                "exe",
                "dll",
                "com",
                "bat",
                "msi"
            ]
        },
        "application/x-msmediaview": {
            "source": "apache",
            "extensions": [
                "mvb",
                "m13",
                "m14"
            ]
        },
        "application/x-msmetafile": {
            "source": "apache",
            "extensions": [
                "wmf",
                "wmz",
                "emf",
                "emz"
            ]
        },
        "application/x-msmoney": {
            "source": "apache",
            "extensions": [
                "mny"
            ]
        },
        "application/x-mspublisher": {
            "source": "apache",
            "extensions": [
                "pub"
            ]
        },
        "application/x-msschedule": {
            "source": "apache",
            "extensions": [
                "scd"
            ]
        },
        "application/x-msterminal": {
            "source": "apache",
            "extensions": [
                "trm"
            ]
        },
        "application/x-mswrite": {
            "source": "apache",
            "extensions": [
                "wri"
            ]
        },
        "application/x-netcdf": {
            "source": "apache",
            "extensions": [
                "nc",
                "cdf"
            ]
        },
        "application/x-ns-proxy-autoconfig": {
            "compressible": true,
            "extensions": [
                "pac"
            ]
        },
        "application/x-nzb": {
            "source": "apache",
            "extensions": [
                "nzb"
            ]
        },
        "application/x-perl": {
            "source": "nginx",
            "extensions": [
                "pl",
                "pm"
            ]
        },
        "application/x-pilot": {
            "source": "nginx",
            "extensions": [
                "prc",
                "pdb"
            ]
        },
        "application/x-pkcs12": {
            "source": "apache",
            "compressible": false,
            "extensions": [
                "p12",
                "pfx"
            ]
        },
        "application/x-pkcs7-certificates": {
            "source": "apache",
            "extensions": [
                "p7b",
                "spc"
            ]
        },
        "application/x-pkcs7-certreqresp": {
            "source": "apache",
            "extensions": [
                "p7r"
            ]
        },
        "application/x-pki-message": {
            "source": "iana"
        },
        "application/x-rar-compressed": {
            "source": "apache",
            "compressible": false,
            "extensions": [
                "rar"
            ]
        },
        "application/x-redhat-package-manager": {
            "source": "nginx",
            "extensions": [
                "rpm"
            ]
        },
        "application/x-research-info-systems": {
            "source": "apache",
            "extensions": [
                "ris"
            ]
        },
        "application/x-sea": {
            "source": "nginx",
            "extensions": [
                "sea"
            ]
        },
        "application/x-sh": {
            "source": "apache",
            "compressible": true,
            "extensions": [
                "sh"
            ]
        },
        "application/x-shar": {
            "source": "apache",
            "extensions": [
                "shar"
            ]
        },
        "application/x-shockwave-flash": {
            "source": "apache",
            "compressible": false,
            "extensions": [
                "swf"
            ]
        },
        "application/x-silverlight-app": {
            "source": "apache",
            "extensions": [
                "xap"
            ]
        },
        "application/x-sql": {
            "source": "apache",
            "extensions": [
                "sql"
            ]
        },
        "application/x-stuffit": {
            "source": "apache",
            "compressible": false,
            "extensions": [
                "sit"
            ]
        },
        "application/x-stuffitx": {
            "source": "apache",
            "extensions": [
                "sitx"
            ]
        },
        "application/x-subrip": {
            "source": "apache",
            "extensions": [
                "srt"
            ]
        },
        "application/x-sv4cpio": {
            "source": "apache",
            "extensions": [
                "sv4cpio"
            ]
        },
        "application/x-sv4crc": {
            "source": "apache",
            "extensions": [
                "sv4crc"
            ]
        },
        "application/x-t3vm-image": {
            "source": "apache",
            "extensions": [
                "t3"
            ]
        },
        "application/x-tads": {
            "source": "apache",
            "extensions": [
                "gam"
            ]
        },
        "application/x-tar": {
            "source": "apache",
            "compressible": true,
            "extensions": [
                "tar"
            ]
        },
        "application/x-tcl": {
            "source": "apache",
            "extensions": [
                "tcl",
                "tk"
            ]
        },
        "application/x-tex": {
            "source": "apache",
            "extensions": [
                "tex"
            ]
        },
        "application/x-tex-tfm": {
            "source": "apache",
            "extensions": [
                "tfm"
            ]
        },
        "application/x-texinfo": {
            "source": "apache",
            "extensions": [
                "texinfo",
                "texi"
            ]
        },
        "application/x-tgif": {
            "source": "apache",
            "extensions": [
                "obj"
            ]
        },
        "application/x-ustar": {
            "source": "apache",
            "extensions": [
                "ustar"
            ]
        },
        "application/x-virtualbox-hdd": {
            "compressible": true,
            "extensions": [
                "hdd"
            ]
        },
        "application/x-virtualbox-ova": {
            "compressible": true,
            "extensions": [
                "ova"
            ]
        },
        "application/x-virtualbox-ovf": {
            "compressible": true,
            "extensions": [
                "ovf"
            ]
        },
        "application/x-virtualbox-vbox": {
            "compressible": true,
            "extensions": [
                "vbox"
            ]
        },
        "application/x-virtualbox-vbox-extpack": {
            "compressible": false,
            "extensions": [
                "vbox-extpack"
            ]
        },
        "application/x-virtualbox-vdi": {
            "compressible": true,
            "extensions": [
                "vdi"
            ]
        },
        "application/x-virtualbox-vhd": {
            "compressible": true,
            "extensions": [
                "vhd"
            ]
        },
        "application/x-virtualbox-vmdk": {
            "compressible": true,
            "extensions": [
                "vmdk"
            ]
        },
        "application/x-wais-source": {
            "source": "apache",
            "extensions": [
                "src"
            ]
        },
        "application/x-web-app-manifest+json": {
            "compressible": true,
            "extensions": [
                "webapp"
            ]
        },
        "application/x-www-form-urlencoded": {
            "source": "iana",
            "compressible": true
        },
        "application/x-x509-ca-cert": {
            "source": "iana",
            "extensions": [
                "der",
                "crt",
                "pem"
            ]
        },
        "application/x-x509-ca-ra-cert": {
            "source": "iana"
        },
        "application/x-x509-next-ca-cert": {
            "source": "iana"
        },
        "application/x-xfig": {
            "source": "apache",
            "extensions": [
                "fig"
            ]
        },
        "application/x-xliff+xml": {
            "source": "apache",
            "compressible": true,
            "extensions": [
                "xlf"
            ]
        },
        "application/x-xpinstall": {
            "source": "apache",
            "compressible": false,
            "extensions": [
                "xpi"
            ]
        },
        "application/x-xz": {
            "source": "apache",
            "extensions": [
                "xz"
            ]
        },
        "application/x-zmachine": {
            "source": "apache",
            "extensions": [
                "z1",
                "z2",
                "z3",
                "z4",
                "z5",
                "z6",
                "z7",
                "z8"
            ]
        },
        "application/x400-bp": {
            "source": "iana"
        },
        "application/xacml+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/xaml+xml": {
            "source": "apache",
            "compressible": true,
            "extensions": [
                "xaml"
            ]
        },
        "application/xcap-att+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "xav"
            ]
        },
        "application/xcap-caps+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "xca"
            ]
        },
        "application/xcap-diff+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "xdf"
            ]
        },
        "application/xcap-el+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "xel"
            ]
        },
        "application/xcap-error+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/xcap-ns+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "xns"
            ]
        },
        "application/xcon-conference-info+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/xcon-conference-info-diff+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/xenc+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "xenc"
            ]
        },
        "application/xhtml+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "xhtml",
                "xht"
            ]
        },
        "application/xhtml-voice+xml": {
            "source": "apache",
            "compressible": true
        },
        "application/xliff+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "xlf"
            ]
        },
        "application/xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "xml",
                "xsl",
                "xsd",
                "rng"
            ]
        },
        "application/xml-dtd": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "dtd"
            ]
        },
        "application/xml-external-parsed-entity": {
            "source": "iana"
        },
        "application/xml-patch+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/xmpp+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/xop+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "xop"
            ]
        },
        "application/xproc+xml": {
            "source": "apache",
            "compressible": true,
            "extensions": [
                "xpl"
            ]
        },
        "application/xslt+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "xsl",
                "xslt"
            ]
        },
        "application/xspf+xml": {
            "source": "apache",
            "compressible": true,
            "extensions": [
                "xspf"
            ]
        },
        "application/xv+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "mxml",
                "xhvml",
                "xvml",
                "xvm"
            ]
        },
        "application/yang": {
            "source": "iana",
            "extensions": [
                "yang"
            ]
        },
        "application/yang-data+json": {
            "source": "iana",
            "compressible": true
        },
        "application/yang-data+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/yang-patch+json": {
            "source": "iana",
            "compressible": true
        },
        "application/yang-patch+xml": {
            "source": "iana",
            "compressible": true
        },
        "application/yin+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "yin"
            ]
        },
        "application/zip": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "zip"
            ]
        },
        "application/zlib": {
            "source": "iana"
        },
        "application/zstd": {
            "source": "iana"
        },
        "audio/1d-interleaved-parityfec": {
            "source": "iana"
        },
        "audio/32kadpcm": {
            "source": "iana"
        },
        "audio/3gpp": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "3gpp"
            ]
        },
        "audio/3gpp2": {
            "source": "iana"
        },
        "audio/aac": {
            "source": "iana"
        },
        "audio/ac3": {
            "source": "iana"
        },
        "audio/adpcm": {
            "source": "apache",
            "extensions": [
                "adp"
            ]
        },
        "audio/amr": {
            "source": "iana",
            "extensions": [
                "amr"
            ]
        },
        "audio/amr-wb": {
            "source": "iana"
        },
        "audio/amr-wb+": {
            "source": "iana"
        },
        "audio/aptx": {
            "source": "iana"
        },
        "audio/asc": {
            "source": "iana"
        },
        "audio/atrac-advanced-lossless": {
            "source": "iana"
        },
        "audio/atrac-x": {
            "source": "iana"
        },
        "audio/atrac3": {
            "source": "iana"
        },
        "audio/basic": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "au",
                "snd"
            ]
        },
        "audio/bv16": {
            "source": "iana"
        },
        "audio/bv32": {
            "source": "iana"
        },
        "audio/clearmode": {
            "source": "iana"
        },
        "audio/cn": {
            "source": "iana"
        },
        "audio/dat12": {
            "source": "iana"
        },
        "audio/dls": {
            "source": "iana"
        },
        "audio/dsr-es201108": {
            "source": "iana"
        },
        "audio/dsr-es202050": {
            "source": "iana"
        },
        "audio/dsr-es202211": {
            "source": "iana"
        },
        "audio/dsr-es202212": {
            "source": "iana"
        },
        "audio/dv": {
            "source": "iana"
        },
        "audio/dvi4": {
            "source": "iana"
        },
        "audio/eac3": {
            "source": "iana"
        },
        "audio/encaprtp": {
            "source": "iana"
        },
        "audio/evrc": {
            "source": "iana"
        },
        "audio/evrc-qcp": {
            "source": "iana"
        },
        "audio/evrc0": {
            "source": "iana"
        },
        "audio/evrc1": {
            "source": "iana"
        },
        "audio/evrcb": {
            "source": "iana"
        },
        "audio/evrcb0": {
            "source": "iana"
        },
        "audio/evrcb1": {
            "source": "iana"
        },
        "audio/evrcnw": {
            "source": "iana"
        },
        "audio/evrcnw0": {
            "source": "iana"
        },
        "audio/evrcnw1": {
            "source": "iana"
        },
        "audio/evrcwb": {
            "source": "iana"
        },
        "audio/evrcwb0": {
            "source": "iana"
        },
        "audio/evrcwb1": {
            "source": "iana"
        },
        "audio/evs": {
            "source": "iana"
        },
        "audio/flexfec": {
            "source": "iana"
        },
        "audio/fwdred": {
            "source": "iana"
        },
        "audio/g711-0": {
            "source": "iana"
        },
        "audio/g719": {
            "source": "iana"
        },
        "audio/g722": {
            "source": "iana"
        },
        "audio/g7221": {
            "source": "iana"
        },
        "audio/g723": {
            "source": "iana"
        },
        "audio/g726-16": {
            "source": "iana"
        },
        "audio/g726-24": {
            "source": "iana"
        },
        "audio/g726-32": {
            "source": "iana"
        },
        "audio/g726-40": {
            "source": "iana"
        },
        "audio/g728": {
            "source": "iana"
        },
        "audio/g729": {
            "source": "iana"
        },
        "audio/g7291": {
            "source": "iana"
        },
        "audio/g729d": {
            "source": "iana"
        },
        "audio/g729e": {
            "source": "iana"
        },
        "audio/gsm": {
            "source": "iana"
        },
        "audio/gsm-efr": {
            "source": "iana"
        },
        "audio/gsm-hr-08": {
            "source": "iana"
        },
        "audio/ilbc": {
            "source": "iana"
        },
        "audio/ip-mr_v2.5": {
            "source": "iana"
        },
        "audio/isac": {
            "source": "apache"
        },
        "audio/l16": {
            "source": "iana"
        },
        "audio/l20": {
            "source": "iana"
        },
        "audio/l24": {
            "source": "iana",
            "compressible": false
        },
        "audio/l8": {
            "source": "iana"
        },
        "audio/lpc": {
            "source": "iana"
        },
        "audio/melp": {
            "source": "iana"
        },
        "audio/melp1200": {
            "source": "iana"
        },
        "audio/melp2400": {
            "source": "iana"
        },
        "audio/melp600": {
            "source": "iana"
        },
        "audio/mhas": {
            "source": "iana"
        },
        "audio/midi": {
            "source": "apache",
            "extensions": [
                "mid",
                "midi",
                "kar",
                "rmi"
            ]
        },
        "audio/mobile-xmf": {
            "source": "iana",
            "extensions": [
                "mxmf"
            ]
        },
        "audio/mp3": {
            "compressible": false,
            "extensions": [
                "mp3"
            ]
        },
        "audio/mp4": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "m4a",
                "mp4a"
            ]
        },
        "audio/mp4a-latm": {
            "source": "iana"
        },
        "audio/mpa": {
            "source": "iana"
        },
        "audio/mpa-robust": {
            "source": "iana"
        },
        "audio/mpeg": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "mpga",
                "mp2",
                "mp2a",
                "mp3",
                "m2a",
                "m3a"
            ]
        },
        "audio/mpeg4-generic": {
            "source": "iana"
        },
        "audio/musepack": {
            "source": "apache"
        },
        "audio/ogg": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "oga",
                "ogg",
                "spx",
                "opus"
            ]
        },
        "audio/opus": {
            "source": "iana"
        },
        "audio/parityfec": {
            "source": "iana"
        },
        "audio/pcma": {
            "source": "iana"
        },
        "audio/pcma-wb": {
            "source": "iana"
        },
        "audio/pcmu": {
            "source": "iana"
        },
        "audio/pcmu-wb": {
            "source": "iana"
        },
        "audio/prs.sid": {
            "source": "iana"
        },
        "audio/qcelp": {
            "source": "iana"
        },
        "audio/raptorfec": {
            "source": "iana"
        },
        "audio/red": {
            "source": "iana"
        },
        "audio/rtp-enc-aescm128": {
            "source": "iana"
        },
        "audio/rtp-midi": {
            "source": "iana"
        },
        "audio/rtploopback": {
            "source": "iana"
        },
        "audio/rtx": {
            "source": "iana"
        },
        "audio/s3m": {
            "source": "apache",
            "extensions": [
                "s3m"
            ]
        },
        "audio/scip": {
            "source": "iana"
        },
        "audio/silk": {
            "source": "apache",
            "extensions": [
                "sil"
            ]
        },
        "audio/smv": {
            "source": "iana"
        },
        "audio/smv-qcp": {
            "source": "iana"
        },
        "audio/smv0": {
            "source": "iana"
        },
        "audio/sofa": {
            "source": "iana"
        },
        "audio/sp-midi": {
            "source": "iana"
        },
        "audio/speex": {
            "source": "iana"
        },
        "audio/t140c": {
            "source": "iana"
        },
        "audio/t38": {
            "source": "iana"
        },
        "audio/telephone-event": {
            "source": "iana"
        },
        "audio/tetra_acelp": {
            "source": "iana"
        },
        "audio/tetra_acelp_bb": {
            "source": "iana"
        },
        "audio/tone": {
            "source": "iana"
        },
        "audio/tsvcis": {
            "source": "iana"
        },
        "audio/uemclip": {
            "source": "iana"
        },
        "audio/ulpfec": {
            "source": "iana"
        },
        "audio/usac": {
            "source": "iana"
        },
        "audio/vdvi": {
            "source": "iana"
        },
        "audio/vmr-wb": {
            "source": "iana"
        },
        "audio/vnd.3gpp.iufp": {
            "source": "iana"
        },
        "audio/vnd.4sb": {
            "source": "iana"
        },
        "audio/vnd.audiokoz": {
            "source": "iana"
        },
        "audio/vnd.celp": {
            "source": "iana"
        },
        "audio/vnd.cisco.nse": {
            "source": "iana"
        },
        "audio/vnd.cmles.radio-events": {
            "source": "iana"
        },
        "audio/vnd.cns.anp1": {
            "source": "iana"
        },
        "audio/vnd.cns.inf1": {
            "source": "iana"
        },
        "audio/vnd.dece.audio": {
            "source": "iana",
            "extensions": [
                "uva",
                "uvva"
            ]
        },
        "audio/vnd.digital-winds": {
            "source": "iana",
            "extensions": [
                "eol"
            ]
        },
        "audio/vnd.dlna.adts": {
            "source": "iana"
        },
        "audio/vnd.dolby.heaac.1": {
            "source": "iana"
        },
        "audio/vnd.dolby.heaac.2": {
            "source": "iana"
        },
        "audio/vnd.dolby.mlp": {
            "source": "iana"
        },
        "audio/vnd.dolby.mps": {
            "source": "iana"
        },
        "audio/vnd.dolby.pl2": {
            "source": "iana"
        },
        "audio/vnd.dolby.pl2x": {
            "source": "iana"
        },
        "audio/vnd.dolby.pl2z": {
            "source": "iana"
        },
        "audio/vnd.dolby.pulse.1": {
            "source": "iana"
        },
        "audio/vnd.dra": {
            "source": "iana",
            "extensions": [
                "dra"
            ]
        },
        "audio/vnd.dts": {
            "source": "iana",
            "extensions": [
                "dts"
            ]
        },
        "audio/vnd.dts.hd": {
            "source": "iana",
            "extensions": [
                "dtshd"
            ]
        },
        "audio/vnd.dts.uhd": {
            "source": "iana"
        },
        "audio/vnd.dvb.file": {
            "source": "iana"
        },
        "audio/vnd.everad.plj": {
            "source": "iana"
        },
        "audio/vnd.hns.audio": {
            "source": "iana"
        },
        "audio/vnd.lucent.voice": {
            "source": "iana",
            "extensions": [
                "lvp"
            ]
        },
        "audio/vnd.ms-playready.media.pya": {
            "source": "iana",
            "extensions": [
                "pya"
            ]
        },
        "audio/vnd.nokia.mobile-xmf": {
            "source": "iana"
        },
        "audio/vnd.nortel.vbk": {
            "source": "iana"
        },
        "audio/vnd.nuera.ecelp4800": {
            "source": "iana",
            "extensions": [
                "ecelp4800"
            ]
        },
        "audio/vnd.nuera.ecelp7470": {
            "source": "iana",
            "extensions": [
                "ecelp7470"
            ]
        },
        "audio/vnd.nuera.ecelp9600": {
            "source": "iana",
            "extensions": [
                "ecelp9600"
            ]
        },
        "audio/vnd.octel.sbc": {
            "source": "iana"
        },
        "audio/vnd.presonus.multitrack": {
            "source": "iana"
        },
        "audio/vnd.qcelp": {
            "source": "iana"
        },
        "audio/vnd.rhetorex.32kadpcm": {
            "source": "iana"
        },
        "audio/vnd.rip": {
            "source": "iana",
            "extensions": [
                "rip"
            ]
        },
        "audio/vnd.rn-realaudio": {
            "compressible": false
        },
        "audio/vnd.sealedmedia.softseal.mpeg": {
            "source": "iana"
        },
        "audio/vnd.vmx.cvsd": {
            "source": "iana"
        },
        "audio/vnd.wave": {
            "compressible": false
        },
        "audio/vorbis": {
            "source": "iana",
            "compressible": false
        },
        "audio/vorbis-config": {
            "source": "iana"
        },
        "audio/wav": {
            "compressible": false,
            "extensions": [
                "wav"
            ]
        },
        "audio/wave": {
            "compressible": false,
            "extensions": [
                "wav"
            ]
        },
        "audio/webm": {
            "source": "apache",
            "compressible": false,
            "extensions": [
                "weba"
            ]
        },
        "audio/x-aac": {
            "source": "apache",
            "compressible": false,
            "extensions": [
                "aac"
            ]
        },
        "audio/x-aiff": {
            "source": "apache",
            "extensions": [
                "aif",
                "aiff",
                "aifc"
            ]
        },
        "audio/x-caf": {
            "source": "apache",
            "compressible": false,
            "extensions": [
                "caf"
            ]
        },
        "audio/x-flac": {
            "source": "apache",
            "extensions": [
                "flac"
            ]
        },
        "audio/x-m4a": {
            "source": "nginx",
            "extensions": [
                "m4a"
            ]
        },
        "audio/x-matroska": {
            "source": "apache",
            "extensions": [
                "mka"
            ]
        },
        "audio/x-mpegurl": {
            "source": "apache",
            "extensions": [
                "m3u"
            ]
        },
        "audio/x-ms-wax": {
            "source": "apache",
            "extensions": [
                "wax"
            ]
        },
        "audio/x-ms-wma": {
            "source": "apache",
            "extensions": [
                "wma"
            ]
        },
        "audio/x-pn-realaudio": {
            "source": "apache",
            "extensions": [
                "ram",
                "ra"
            ]
        },
        "audio/x-pn-realaudio-plugin": {
            "source": "apache",
            "extensions": [
                "rmp"
            ]
        },
        "audio/x-realaudio": {
            "source": "nginx",
            "extensions": [
                "ra"
            ]
        },
        "audio/x-tta": {
            "source": "apache"
        },
        "audio/x-wav": {
            "source": "apache",
            "extensions": [
                "wav"
            ]
        },
        "audio/xm": {
            "source": "apache",
            "extensions": [
                "xm"
            ]
        },
        "chemical/x-cdx": {
            "source": "apache",
            "extensions": [
                "cdx"
            ]
        },
        "chemical/x-cif": {
            "source": "apache",
            "extensions": [
                "cif"
            ]
        },
        "chemical/x-cmdf": {
            "source": "apache",
            "extensions": [
                "cmdf"
            ]
        },
        "chemical/x-cml": {
            "source": "apache",
            "extensions": [
                "cml"
            ]
        },
        "chemical/x-csml": {
            "source": "apache",
            "extensions": [
                "csml"
            ]
        },
        "chemical/x-pdb": {
            "source": "apache"
        },
        "chemical/x-xyz": {
            "source": "apache",
            "extensions": [
                "xyz"
            ]
        },
        "font/collection": {
            "source": "iana",
            "extensions": [
                "ttc"
            ]
        },
        "font/otf": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "otf"
            ]
        },
        "font/sfnt": {
            "source": "iana"
        },
        "font/ttf": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "ttf"
            ]
        },
        "font/woff": {
            "source": "iana",
            "extensions": [
                "woff"
            ]
        },
        "font/woff2": {
            "source": "iana",
            "extensions": [
                "woff2"
            ]
        },
        "image/aces": {
            "source": "iana",
            "extensions": [
                "exr"
            ]
        },
        "image/apng": {
            "compressible": false,
            "extensions": [
                "apng"
            ]
        },
        "image/avci": {
            "source": "iana",
            "extensions": [
                "avci"
            ]
        },
        "image/avcs": {
            "source": "iana",
            "extensions": [
                "avcs"
            ]
        },
        "image/avif": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "avif"
            ]
        },
        "image/bmp": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "bmp"
            ]
        },
        "image/cgm": {
            "source": "iana",
            "extensions": [
                "cgm"
            ]
        },
        "image/dicom-rle": {
            "source": "iana",
            "extensions": [
                "drle"
            ]
        },
        "image/emf": {
            "source": "iana",
            "extensions": [
                "emf"
            ]
        },
        "image/fits": {
            "source": "iana",
            "extensions": [
                "fits"
            ]
        },
        "image/g3fax": {
            "source": "iana",
            "extensions": [
                "g3"
            ]
        },
        "image/gif": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "gif"
            ]
        },
        "image/heic": {
            "source": "iana",
            "extensions": [
                "heic"
            ]
        },
        "image/heic-sequence": {
            "source": "iana",
            "extensions": [
                "heics"
            ]
        },
        "image/heif": {
            "source": "iana",
            "extensions": [
                "heif"
            ]
        },
        "image/heif-sequence": {
            "source": "iana",
            "extensions": [
                "heifs"
            ]
        },
        "image/hej2k": {
            "source": "iana",
            "extensions": [
                "hej2"
            ]
        },
        "image/hsj2": {
            "source": "iana",
            "extensions": [
                "hsj2"
            ]
        },
        "image/ief": {
            "source": "iana",
            "extensions": [
                "ief"
            ]
        },
        "image/jls": {
            "source": "iana",
            "extensions": [
                "jls"
            ]
        },
        "image/jp2": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "jp2",
                "jpg2"
            ]
        },
        "image/jpeg": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "jpeg",
                "jpg",
                "jpe"
            ]
        },
        "image/jph": {
            "source": "iana",
            "extensions": [
                "jph"
            ]
        },
        "image/jphc": {
            "source": "iana",
            "extensions": [
                "jhc"
            ]
        },
        "image/jpm": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "jpm"
            ]
        },
        "image/jpx": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "jpx",
                "jpf"
            ]
        },
        "image/jxr": {
            "source": "iana",
            "extensions": [
                "jxr"
            ]
        },
        "image/jxra": {
            "source": "iana",
            "extensions": [
                "jxra"
            ]
        },
        "image/jxrs": {
            "source": "iana",
            "extensions": [
                "jxrs"
            ]
        },
        "image/jxs": {
            "source": "iana",
            "extensions": [
                "jxs"
            ]
        },
        "image/jxsc": {
            "source": "iana",
            "extensions": [
                "jxsc"
            ]
        },
        "image/jxsi": {
            "source": "iana",
            "extensions": [
                "jxsi"
            ]
        },
        "image/jxss": {
            "source": "iana",
            "extensions": [
                "jxss"
            ]
        },
        "image/ktx": {
            "source": "iana",
            "extensions": [
                "ktx"
            ]
        },
        "image/ktx2": {
            "source": "iana",
            "extensions": [
                "ktx2"
            ]
        },
        "image/naplps": {
            "source": "iana"
        },
        "image/pjpeg": {
            "compressible": false
        },
        "image/png": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "png"
            ]
        },
        "image/prs.btif": {
            "source": "iana",
            "extensions": [
                "btif"
            ]
        },
        "image/prs.pti": {
            "source": "iana",
            "extensions": [
                "pti"
            ]
        },
        "image/pwg-raster": {
            "source": "iana"
        },
        "image/sgi": {
            "source": "apache",
            "extensions": [
                "sgi"
            ]
        },
        "image/svg+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "svg",
                "svgz"
            ]
        },
        "image/t38": {
            "source": "iana",
            "extensions": [
                "t38"
            ]
        },
        "image/tiff": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "tif",
                "tiff"
            ]
        },
        "image/tiff-fx": {
            "source": "iana",
            "extensions": [
                "tfx"
            ]
        },
        "image/vnd.adobe.photoshop": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "psd"
            ]
        },
        "image/vnd.airzip.accelerator.azv": {
            "source": "iana",
            "extensions": [
                "azv"
            ]
        },
        "image/vnd.cns.inf2": {
            "source": "iana"
        },
        "image/vnd.dece.graphic": {
            "source": "iana",
            "extensions": [
                "uvi",
                "uvvi",
                "uvg",
                "uvvg"
            ]
        },
        "image/vnd.djvu": {
            "source": "iana",
            "extensions": [
                "djvu",
                "djv"
            ]
        },
        "image/vnd.dvb.subtitle": {
            "source": "iana",
            "extensions": [
                "sub"
            ]
        },
        "image/vnd.dwg": {
            "source": "iana",
            "extensions": [
                "dwg"
            ]
        },
        "image/vnd.dxf": {
            "source": "iana",
            "extensions": [
                "dxf"
            ]
        },
        "image/vnd.fastbidsheet": {
            "source": "iana",
            "extensions": [
                "fbs"
            ]
        },
        "image/vnd.fpx": {
            "source": "iana",
            "extensions": [
                "fpx"
            ]
        },
        "image/vnd.fst": {
            "source": "iana",
            "extensions": [
                "fst"
            ]
        },
        "image/vnd.fujixerox.edmics-mmr": {
            "source": "iana",
            "extensions": [
                "mmr"
            ]
        },
        "image/vnd.fujixerox.edmics-rlc": {
            "source": "iana",
            "extensions": [
                "rlc"
            ]
        },
        "image/vnd.globalgraphics.pgb": {
            "source": "iana"
        },
        "image/vnd.microsoft.icon": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "ico"
            ]
        },
        "image/vnd.mix": {
            "source": "iana"
        },
        "image/vnd.mozilla.apng": {
            "source": "iana"
        },
        "image/vnd.ms-dds": {
            "compressible": true,
            "extensions": [
                "dds"
            ]
        },
        "image/vnd.ms-modi": {
            "source": "iana",
            "extensions": [
                "mdi"
            ]
        },
        "image/vnd.ms-photo": {
            "source": "apache",
            "extensions": [
                "wdp"
            ]
        },
        "image/vnd.net-fpx": {
            "source": "iana",
            "extensions": [
                "npx"
            ]
        },
        "image/vnd.pco.b16": {
            "source": "iana",
            "extensions": [
                "b16"
            ]
        },
        "image/vnd.radiance": {
            "source": "iana"
        },
        "image/vnd.sealed.png": {
            "source": "iana"
        },
        "image/vnd.sealedmedia.softseal.gif": {
            "source": "iana"
        },
        "image/vnd.sealedmedia.softseal.jpg": {
            "source": "iana"
        },
        "image/vnd.svf": {
            "source": "iana"
        },
        "image/vnd.tencent.tap": {
            "source": "iana",
            "extensions": [
                "tap"
            ]
        },
        "image/vnd.valve.source.texture": {
            "source": "iana",
            "extensions": [
                "vtf"
            ]
        },
        "image/vnd.wap.wbmp": {
            "source": "iana",
            "extensions": [
                "wbmp"
            ]
        },
        "image/vnd.xiff": {
            "source": "iana",
            "extensions": [
                "xif"
            ]
        },
        "image/vnd.zbrush.pcx": {
            "source": "iana",
            "extensions": [
                "pcx"
            ]
        },
        "image/webp": {
            "source": "apache",
            "extensions": [
                "webp"
            ]
        },
        "image/wmf": {
            "source": "iana",
            "extensions": [
                "wmf"
            ]
        },
        "image/x-3ds": {
            "source": "apache",
            "extensions": [
                "3ds"
            ]
        },
        "image/x-cmu-raster": {
            "source": "apache",
            "extensions": [
                "ras"
            ]
        },
        "image/x-cmx": {
            "source": "apache",
            "extensions": [
                "cmx"
            ]
        },
        "image/x-freehand": {
            "source": "apache",
            "extensions": [
                "fh",
                "fhc",
                "fh4",
                "fh5",
                "fh7"
            ]
        },
        "image/x-icon": {
            "source": "apache",
            "compressible": true,
            "extensions": [
                "ico"
            ]
        },
        "image/x-jng": {
            "source": "nginx",
            "extensions": [
                "jng"
            ]
        },
        "image/x-mrsid-image": {
            "source": "apache",
            "extensions": [
                "sid"
            ]
        },
        "image/x-ms-bmp": {
            "source": "nginx",
            "compressible": true,
            "extensions": [
                "bmp"
            ]
        },
        "image/x-pcx": {
            "source": "apache",
            "extensions": [
                "pcx"
            ]
        },
        "image/x-pict": {
            "source": "apache",
            "extensions": [
                "pic",
                "pct"
            ]
        },
        "image/x-portable-anymap": {
            "source": "apache",
            "extensions": [
                "pnm"
            ]
        },
        "image/x-portable-bitmap": {
            "source": "apache",
            "extensions": [
                "pbm"
            ]
        },
        "image/x-portable-graymap": {
            "source": "apache",
            "extensions": [
                "pgm"
            ]
        },
        "image/x-portable-pixmap": {
            "source": "apache",
            "extensions": [
                "ppm"
            ]
        },
        "image/x-rgb": {
            "source": "apache",
            "extensions": [
                "rgb"
            ]
        },
        "image/x-tga": {
            "source": "apache",
            "extensions": [
                "tga"
            ]
        },
        "image/x-xbitmap": {
            "source": "apache",
            "extensions": [
                "xbm"
            ]
        },
        "image/x-xcf": {
            "compressible": false
        },
        "image/x-xpixmap": {
            "source": "apache",
            "extensions": [
                "xpm"
            ]
        },
        "image/x-xwindowdump": {
            "source": "apache",
            "extensions": [
                "xwd"
            ]
        },
        "message/cpim": {
            "source": "iana"
        },
        "message/delivery-status": {
            "source": "iana"
        },
        "message/disposition-notification": {
            "source": "iana",
            "extensions": [
                "disposition-notification"
            ]
        },
        "message/external-body": {
            "source": "iana"
        },
        "message/feedback-report": {
            "source": "iana"
        },
        "message/global": {
            "source": "iana",
            "extensions": [
                "u8msg"
            ]
        },
        "message/global-delivery-status": {
            "source": "iana",
            "extensions": [
                "u8dsn"
            ]
        },
        "message/global-disposition-notification": {
            "source": "iana",
            "extensions": [
                "u8mdn"
            ]
        },
        "message/global-headers": {
            "source": "iana",
            "extensions": [
                "u8hdr"
            ]
        },
        "message/http": {
            "source": "iana",
            "compressible": false
        },
        "message/imdn+xml": {
            "source": "iana",
            "compressible": true
        },
        "message/news": {
            "source": "iana"
        },
        "message/partial": {
            "source": "iana",
            "compressible": false
        },
        "message/rfc822": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "eml",
                "mime"
            ]
        },
        "message/s-http": {
            "source": "iana"
        },
        "message/sip": {
            "source": "iana"
        },
        "message/sipfrag": {
            "source": "iana"
        },
        "message/tracking-status": {
            "source": "iana"
        },
        "message/vnd.si.simp": {
            "source": "iana"
        },
        "message/vnd.wfa.wsc": {
            "source": "iana",
            "extensions": [
                "wsc"
            ]
        },
        "model/3mf": {
            "source": "iana",
            "extensions": [
                "3mf"
            ]
        },
        "model/e57": {
            "source": "iana"
        },
        "model/gltf+json": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "gltf"
            ]
        },
        "model/gltf-binary": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "glb"
            ]
        },
        "model/iges": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "igs",
                "iges"
            ]
        },
        "model/mesh": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "msh",
                "mesh",
                "silo"
            ]
        },
        "model/mtl": {
            "source": "iana",
            "extensions": [
                "mtl"
            ]
        },
        "model/obj": {
            "source": "iana",
            "extensions": [
                "obj"
            ]
        },
        "model/step": {
            "source": "iana"
        },
        "model/step+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "stpx"
            ]
        },
        "model/step+zip": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "stpz"
            ]
        },
        "model/step-xml+zip": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "stpxz"
            ]
        },
        "model/stl": {
            "source": "iana",
            "extensions": [
                "stl"
            ]
        },
        "model/vnd.collada+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "dae"
            ]
        },
        "model/vnd.dwf": {
            "source": "iana",
            "extensions": [
                "dwf"
            ]
        },
        "model/vnd.flatland.3dml": {
            "source": "iana"
        },
        "model/vnd.gdl": {
            "source": "iana",
            "extensions": [
                "gdl"
            ]
        },
        "model/vnd.gs-gdl": {
            "source": "apache"
        },
        "model/vnd.gs.gdl": {
            "source": "iana"
        },
        "model/vnd.gtw": {
            "source": "iana",
            "extensions": [
                "gtw"
            ]
        },
        "model/vnd.moml+xml": {
            "source": "iana",
            "compressible": true
        },
        "model/vnd.mts": {
            "source": "iana",
            "extensions": [
                "mts"
            ]
        },
        "model/vnd.opengex": {
            "source": "iana",
            "extensions": [
                "ogex"
            ]
        },
        "model/vnd.parasolid.transmit.binary": {
            "source": "iana",
            "extensions": [
                "x_b"
            ]
        },
        "model/vnd.parasolid.transmit.text": {
            "source": "iana",
            "extensions": [
                "x_t"
            ]
        },
        "model/vnd.pytha.pyox": {
            "source": "iana"
        },
        "model/vnd.rosette.annotated-data-model": {
            "source": "iana"
        },
        "model/vnd.sap.vds": {
            "source": "iana",
            "extensions": [
                "vds"
            ]
        },
        "model/vnd.usdz+zip": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "usdz"
            ]
        },
        "model/vnd.valve.source.compiled-map": {
            "source": "iana",
            "extensions": [
                "bsp"
            ]
        },
        "model/vnd.vtu": {
            "source": "iana",
            "extensions": [
                "vtu"
            ]
        },
        "model/vrml": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "wrl",
                "vrml"
            ]
        },
        "model/x3d+binary": {
            "source": "apache",
            "compressible": false,
            "extensions": [
                "x3db",
                "x3dbz"
            ]
        },
        "model/x3d+fastinfoset": {
            "source": "iana",
            "extensions": [
                "x3db"
            ]
        },
        "model/x3d+vrml": {
            "source": "apache",
            "compressible": false,
            "extensions": [
                "x3dv",
                "x3dvz"
            ]
        },
        "model/x3d+xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "x3d",
                "x3dz"
            ]
        },
        "model/x3d-vrml": {
            "source": "iana",
            "extensions": [
                "x3dv"
            ]
        },
        "multipart/alternative": {
            "source": "iana",
            "compressible": false
        },
        "multipart/appledouble": {
            "source": "iana"
        },
        "multipart/byteranges": {
            "source": "iana"
        },
        "multipart/digest": {
            "source": "iana"
        },
        "multipart/encrypted": {
            "source": "iana",
            "compressible": false
        },
        "multipart/form-data": {
            "source": "iana",
            "compressible": false
        },
        "multipart/header-set": {
            "source": "iana"
        },
        "multipart/mixed": {
            "source": "iana"
        },
        "multipart/multilingual": {
            "source": "iana"
        },
        "multipart/parallel": {
            "source": "iana"
        },
        "multipart/related": {
            "source": "iana",
            "compressible": false
        },
        "multipart/report": {
            "source": "iana"
        },
        "multipart/signed": {
            "source": "iana",
            "compressible": false
        },
        "multipart/vnd.bint.med-plus": {
            "source": "iana"
        },
        "multipart/voice-message": {
            "source": "iana"
        },
        "multipart/x-mixed-replace": {
            "source": "iana"
        },
        "text/1d-interleaved-parityfec": {
            "source": "iana"
        },
        "text/cache-manifest": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "appcache",
                "manifest"
            ]
        },
        "text/calendar": {
            "source": "iana",
            "extensions": [
                "ics",
                "ifb"
            ]
        },
        "text/calender": {
            "compressible": true
        },
        "text/cmd": {
            "compressible": true
        },
        "text/coffeescript": {
            "extensions": [
                "coffee",
                "litcoffee"
            ]
        },
        "text/cql": {
            "source": "iana"
        },
        "text/cql-expression": {
            "source": "iana"
        },
        "text/cql-identifier": {
            "source": "iana"
        },
        "text/css": {
            "source": "iana",
            "charset": "UTF-8",
            "compressible": true,
            "extensions": [
                "css"
            ]
        },
        "text/csv": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "csv"
            ]
        },
        "text/csv-schema": {
            "source": "iana"
        },
        "text/directory": {
            "source": "iana"
        },
        "text/dns": {
            "source": "iana"
        },
        "text/ecmascript": {
            "source": "iana"
        },
        "text/encaprtp": {
            "source": "iana"
        },
        "text/enriched": {
            "source": "iana"
        },
        "text/fhirpath": {
            "source": "iana"
        },
        "text/flexfec": {
            "source": "iana"
        },
        "text/fwdred": {
            "source": "iana"
        },
        "text/gff3": {
            "source": "iana"
        },
        "text/grammar-ref-list": {
            "source": "iana"
        },
        "text/html": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "html",
                "htm",
                "shtml"
            ]
        },
        "text/jade": {
            "extensions": [
                "jade"
            ]
        },
        "text/javascript": {
            "source": "iana",
            "compressible": true
        },
        "text/jcr-cnd": {
            "source": "iana"
        },
        "text/jsx": {
            "compressible": true,
            "extensions": [
                "jsx"
            ]
        },
        "text/less": {
            "compressible": true,
            "extensions": [
                "less"
            ]
        },
        "text/markdown": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "markdown",
                "md"
            ]
        },
        "text/mathml": {
            "source": "nginx",
            "extensions": [
                "mml"
            ]
        },
        "text/mdx": {
            "compressible": true,
            "extensions": [
                "mdx"
            ]
        },
        "text/mizar": {
            "source": "iana"
        },
        "text/n3": {
            "source": "iana",
            "charset": "UTF-8",
            "compressible": true,
            "extensions": [
                "n3"
            ]
        },
        "text/parameters": {
            "source": "iana",
            "charset": "UTF-8"
        },
        "text/parityfec": {
            "source": "iana"
        },
        "text/plain": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "txt",
                "text",
                "conf",
                "def",
                "list",
                "log",
                "in",
                "ini"
            ]
        },
        "text/provenance-notation": {
            "source": "iana",
            "charset": "UTF-8"
        },
        "text/prs.fallenstein.rst": {
            "source": "iana"
        },
        "text/prs.lines.tag": {
            "source": "iana",
            "extensions": [
                "dsc"
            ]
        },
        "text/prs.prop.logic": {
            "source": "iana"
        },
        "text/raptorfec": {
            "source": "iana"
        },
        "text/red": {
            "source": "iana"
        },
        "text/rfc822-headers": {
            "source": "iana"
        },
        "text/richtext": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "rtx"
            ]
        },
        "text/rtf": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "rtf"
            ]
        },
        "text/rtp-enc-aescm128": {
            "source": "iana"
        },
        "text/rtploopback": {
            "source": "iana"
        },
        "text/rtx": {
            "source": "iana"
        },
        "text/sgml": {
            "source": "iana",
            "extensions": [
                "sgml",
                "sgm"
            ]
        },
        "text/shaclc": {
            "source": "iana"
        },
        "text/shex": {
            "source": "iana",
            "extensions": [
                "shex"
            ]
        },
        "text/slim": {
            "extensions": [
                "slim",
                "slm"
            ]
        },
        "text/spdx": {
            "source": "iana",
            "extensions": [
                "spdx"
            ]
        },
        "text/strings": {
            "source": "iana"
        },
        "text/stylus": {
            "extensions": [
                "stylus",
                "styl"
            ]
        },
        "text/t140": {
            "source": "iana"
        },
        "text/tab-separated-values": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "tsv"
            ]
        },
        "text/troff": {
            "source": "iana",
            "extensions": [
                "t",
                "tr",
                "roff",
                "man",
                "me",
                "ms"
            ]
        },
        "text/turtle": {
            "source": "iana",
            "charset": "UTF-8",
            "extensions": [
                "ttl"
            ]
        },
        "text/ulpfec": {
            "source": "iana"
        },
        "text/uri-list": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "uri",
                "uris",
                "urls"
            ]
        },
        "text/vcard": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "vcard"
            ]
        },
        "text/vnd.a": {
            "source": "iana"
        },
        "text/vnd.abc": {
            "source": "iana"
        },
        "text/vnd.ascii-art": {
            "source": "iana"
        },
        "text/vnd.curl": {
            "source": "iana",
            "extensions": [
                "curl"
            ]
        },
        "text/vnd.curl.dcurl": {
            "source": "apache",
            "extensions": [
                "dcurl"
            ]
        },
        "text/vnd.curl.mcurl": {
            "source": "apache",
            "extensions": [
                "mcurl"
            ]
        },
        "text/vnd.curl.scurl": {
            "source": "apache",
            "extensions": [
                "scurl"
            ]
        },
        "text/vnd.debian.copyright": {
            "source": "iana",
            "charset": "UTF-8"
        },
        "text/vnd.dmclientscript": {
            "source": "iana"
        },
        "text/vnd.dvb.subtitle": {
            "source": "iana",
            "extensions": [
                "sub"
            ]
        },
        "text/vnd.esmertec.theme-descriptor": {
            "source": "iana",
            "charset": "UTF-8"
        },
        "text/vnd.familysearch.gedcom": {
            "source": "iana",
            "extensions": [
                "ged"
            ]
        },
        "text/vnd.ficlab.flt": {
            "source": "iana"
        },
        "text/vnd.fly": {
            "source": "iana",
            "extensions": [
                "fly"
            ]
        },
        "text/vnd.fmi.flexstor": {
            "source": "iana",
            "extensions": [
                "flx"
            ]
        },
        "text/vnd.gml": {
            "source": "iana"
        },
        "text/vnd.graphviz": {
            "source": "iana",
            "extensions": [
                "gv"
            ]
        },
        "text/vnd.hans": {
            "source": "iana"
        },
        "text/vnd.hgl": {
            "source": "iana"
        },
        "text/vnd.in3d.3dml": {
            "source": "iana",
            "extensions": [
                "3dml"
            ]
        },
        "text/vnd.in3d.spot": {
            "source": "iana",
            "extensions": [
                "spot"
            ]
        },
        "text/vnd.iptc.newsml": {
            "source": "iana"
        },
        "text/vnd.iptc.nitf": {
            "source": "iana"
        },
        "text/vnd.latex-z": {
            "source": "iana"
        },
        "text/vnd.motorola.reflex": {
            "source": "iana"
        },
        "text/vnd.ms-mediapackage": {
            "source": "iana"
        },
        "text/vnd.net2phone.commcenter.command": {
            "source": "iana"
        },
        "text/vnd.radisys.msml-basic-layout": {
            "source": "iana"
        },
        "text/vnd.senx.warpscript": {
            "source": "iana"
        },
        "text/vnd.si.uricatalogue": {
            "source": "iana"
        },
        "text/vnd.sosi": {
            "source": "iana"
        },
        "text/vnd.sun.j2me.app-descriptor": {
            "source": "iana",
            "charset": "UTF-8",
            "extensions": [
                "jad"
            ]
        },
        "text/vnd.trolltech.linguist": {
            "source": "iana",
            "charset": "UTF-8"
        },
        "text/vnd.wap.si": {
            "source": "iana"
        },
        "text/vnd.wap.sl": {
            "source": "iana"
        },
        "text/vnd.wap.wml": {
            "source": "iana",
            "extensions": [
                "wml"
            ]
        },
        "text/vnd.wap.wmlscript": {
            "source": "iana",
            "extensions": [
                "wmls"
            ]
        },
        "text/vtt": {
            "source": "iana",
            "charset": "UTF-8",
            "compressible": true,
            "extensions": [
                "vtt"
            ]
        },
        "text/x-asm": {
            "source": "apache",
            "extensions": [
                "s",
                "asm"
            ]
        },
        "text/x-c": {
            "source": "apache",
            "extensions": [
                "c",
                "cc",
                "cxx",
                "cpp",
                "h",
                "hh",
                "dic"
            ]
        },
        "text/x-component": {
            "source": "nginx",
            "extensions": [
                "htc"
            ]
        },
        "text/x-fortran": {
            "source": "apache",
            "extensions": [
                "f",
                "for",
                "f77",
                "f90"
            ]
        },
        "text/x-gwt-rpc": {
            "compressible": true
        },
        "text/x-handlebars-template": {
            "extensions": [
                "hbs"
            ]
        },
        "text/x-java-source": {
            "source": "apache",
            "extensions": [
                "java"
            ]
        },
        "text/x-jquery-tmpl": {
            "compressible": true
        },
        "text/x-lua": {
            "extensions": [
                "lua"
            ]
        },
        "text/x-markdown": {
            "compressible": true,
            "extensions": [
                "mkd"
            ]
        },
        "text/x-nfo": {
            "source": "apache",
            "extensions": [
                "nfo"
            ]
        },
        "text/x-opml": {
            "source": "apache",
            "extensions": [
                "opml"
            ]
        },
        "text/x-org": {
            "compressible": true,
            "extensions": [
                "org"
            ]
        },
        "text/x-pascal": {
            "source": "apache",
            "extensions": [
                "p",
                "pas"
            ]
        },
        "text/x-processing": {
            "compressible": true,
            "extensions": [
                "pde"
            ]
        },
        "text/x-sass": {
            "extensions": [
                "sass"
            ]
        },
        "text/x-scss": {
            "extensions": [
                "scss"
            ]
        },
        "text/x-setext": {
            "source": "apache",
            "extensions": [
                "etx"
            ]
        },
        "text/x-sfv": {
            "source": "apache",
            "extensions": [
                "sfv"
            ]
        },
        "text/x-suse-ymp": {
            "compressible": true,
            "extensions": [
                "ymp"
            ]
        },
        "text/x-uuencode": {
            "source": "apache",
            "extensions": [
                "uu"
            ]
        },
        "text/x-vcalendar": {
            "source": "apache",
            "extensions": [
                "vcs"
            ]
        },
        "text/x-vcard": {
            "source": "apache",
            "extensions": [
                "vcf"
            ]
        },
        "text/xml": {
            "source": "iana",
            "compressible": true,
            "extensions": [
                "xml"
            ]
        },
        "text/xml-external-parsed-entity": {
            "source": "iana"
        },
        "text/yaml": {
            "compressible": true,
            "extensions": [
                "yaml",
                "yml"
            ]
        },
        "video/1d-interleaved-parityfec": {
            "source": "iana"
        },
        "video/3gpp": {
            "source": "iana",
            "extensions": [
                "3gp",
                "3gpp"
            ]
        },
        "video/3gpp-tt": {
            "source": "iana"
        },
        "video/3gpp2": {
            "source": "iana",
            "extensions": [
                "3g2"
            ]
        },
        "video/av1": {
            "source": "iana"
        },
        "video/bmpeg": {
            "source": "iana"
        },
        "video/bt656": {
            "source": "iana"
        },
        "video/celb": {
            "source": "iana"
        },
        "video/dv": {
            "source": "iana"
        },
        "video/encaprtp": {
            "source": "iana"
        },
        "video/ffv1": {
            "source": "iana"
        },
        "video/flexfec": {
            "source": "iana"
        },
        "video/h261": {
            "source": "iana",
            "extensions": [
                "h261"
            ]
        },
        "video/h263": {
            "source": "iana",
            "extensions": [
                "h263"
            ]
        },
        "video/h263-1998": {
            "source": "iana"
        },
        "video/h263-2000": {
            "source": "iana"
        },
        "video/h264": {
            "source": "iana",
            "extensions": [
                "h264"
            ]
        },
        "video/h264-rcdo": {
            "source": "iana"
        },
        "video/h264-svc": {
            "source": "iana"
        },
        "video/h265": {
            "source": "iana"
        },
        "video/iso.segment": {
            "source": "iana",
            "extensions": [
                "m4s"
            ]
        },
        "video/jpeg": {
            "source": "iana",
            "extensions": [
                "jpgv"
            ]
        },
        "video/jpeg2000": {
            "source": "iana"
        },
        "video/jpm": {
            "source": "apache",
            "extensions": [
                "jpm",
                "jpgm"
            ]
        },
        "video/jxsv": {
            "source": "iana"
        },
        "video/mj2": {
            "source": "iana",
            "extensions": [
                "mj2",
                "mjp2"
            ]
        },
        "video/mp1s": {
            "source": "iana"
        },
        "video/mp2p": {
            "source": "iana"
        },
        "video/mp2t": {
            "source": "iana",
            "extensions": [
                "ts"
            ]
        },
        "video/mp4": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "mp4",
                "mp4v",
                "mpg4"
            ]
        },
        "video/mp4v-es": {
            "source": "iana"
        },
        "video/mpeg": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "mpeg",
                "mpg",
                "mpe",
                "m1v",
                "m2v"
            ]
        },
        "video/mpeg4-generic": {
            "source": "iana"
        },
        "video/mpv": {
            "source": "iana"
        },
        "video/nv": {
            "source": "iana"
        },
        "video/ogg": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "ogv"
            ]
        },
        "video/parityfec": {
            "source": "iana"
        },
        "video/pointer": {
            "source": "iana"
        },
        "video/quicktime": {
            "source": "iana",
            "compressible": false,
            "extensions": [
                "qt",
                "mov"
            ]
        },
        "video/raptorfec": {
            "source": "iana"
        },
        "video/raw": {
            "source": "iana"
        },
        "video/rtp-enc-aescm128": {
            "source": "iana"
        },
        "video/rtploopback": {
            "source": "iana"
        },
        "video/rtx": {
            "source": "iana"
        },
        "video/scip": {
            "source": "iana"
        },
        "video/smpte291": {
            "source": "iana"
        },
        "video/smpte292m": {
            "source": "iana"
        },
        "video/ulpfec": {
            "source": "iana"
        },
        "video/vc1": {
            "source": "iana"
        },
        "video/vc2": {
            "source": "iana"
        },
        "video/vnd.cctv": {
            "source": "iana"
        },
        "video/vnd.dece.hd": {
            "source": "iana",
            "extensions": [
                "uvh",
                "uvvh"
            ]
        },
        "video/vnd.dece.mobile": {
            "source": "iana",
            "extensions": [
                "uvm",
                "uvvm"
            ]
        },
        "video/vnd.dece.mp4": {
            "source": "iana"
        },
        "video/vnd.dece.pd": {
            "source": "iana",
            "extensions": [
                "uvp",
                "uvvp"
            ]
        },
        "video/vnd.dece.sd": {
            "source": "iana",
            "extensions": [
                "uvs",
                "uvvs"
            ]
        },
        "video/vnd.dece.video": {
            "source": "iana",
            "extensions": [
                "uvv",
                "uvvv"
            ]
        },
        "video/vnd.directv.mpeg": {
            "source": "iana"
        },
        "video/vnd.directv.mpeg-tts": {
            "source": "iana"
        },
        "video/vnd.dlna.mpeg-tts": {
            "source": "iana"
        },
        "video/vnd.dvb.file": {
            "source": "iana",
            "extensions": [
                "dvb"
            ]
        },
        "video/vnd.fvt": {
            "source": "iana",
            "extensions": [
                "fvt"
            ]
        },
        "video/vnd.hns.video": {
            "source": "iana"
        },
        "video/vnd.iptvforum.1dparityfec-1010": {
            "source": "iana"
        },
        "video/vnd.iptvforum.1dparityfec-2005": {
            "source": "iana"
        },
        "video/vnd.iptvforum.2dparityfec-1010": {
            "source": "iana"
        },
        "video/vnd.iptvforum.2dparityfec-2005": {
            "source": "iana"
        },
        "video/vnd.iptvforum.ttsavc": {
            "source": "iana"
        },
        "video/vnd.iptvforum.ttsmpeg2": {
            "source": "iana"
        },
        "video/vnd.motorola.video": {
            "source": "iana"
        },
        "video/vnd.motorola.videop": {
            "source": "iana"
        },
        "video/vnd.mpegurl": {
            "source": "iana",
            "extensions": [
                "mxu",
                "m4u"
            ]
        },
        "video/vnd.ms-playready.media.pyv": {
            "source": "iana",
            "extensions": [
                "pyv"
            ]
        },
        "video/vnd.nokia.interleaved-multimedia": {
            "source": "iana"
        },
        "video/vnd.nokia.mp4vr": {
            "source": "iana"
        },
        "video/vnd.nokia.videovoip": {
            "source": "iana"
        },
        "video/vnd.objectvideo": {
            "source": "iana"
        },
        "video/vnd.radgamettools.bink": {
            "source": "iana"
        },
        "video/vnd.radgamettools.smacker": {
            "source": "iana"
        },
        "video/vnd.sealed.mpeg1": {
            "source": "iana"
        },
        "video/vnd.sealed.mpeg4": {
            "source": "iana"
        },
        "video/vnd.sealed.swf": {
            "source": "iana"
        },
        "video/vnd.sealedmedia.softseal.mov": {
            "source": "iana"
        },
        "video/vnd.uvvu.mp4": {
            "source": "iana",
            "extensions": [
                "uvu",
                "uvvu"
            ]
        },
        "video/vnd.vivo": {
            "source": "iana",
            "extensions": [
                "viv"
            ]
        },
        "video/vnd.youtube.yt": {
            "source": "iana"
        },
        "video/vp8": {
            "source": "iana"
        },
        "video/vp9": {
            "source": "iana"
        },
        "video/webm": {
            "source": "apache",
            "compressible": false,
            "extensions": [
                "webm"
            ]
        },
        "video/x-f4v": {
            "source": "apache",
            "extensions": [
                "f4v"
            ]
        },
        "video/x-fli": {
            "source": "apache",
            "extensions": [
                "fli"
            ]
        },
        "video/x-flv": {
            "source": "apache",
            "compressible": false,
            "extensions": [
                "flv"
            ]
        },
        "video/x-m4v": {
            "source": "apache",
            "extensions": [
                "m4v"
            ]
        },
        "video/x-matroska": {
            "source": "apache",
            "compressible": false,
            "extensions": [
                "mkv",
                "mk3d",
                "mks"
            ]
        },
        "video/x-mng": {
            "source": "apache",
            "extensions": [
                "mng"
            ]
        },
        "video/x-ms-asf": {
            "source": "apache",
            "extensions": [
                "asf",
                "asx"
            ]
        },
        "video/x-ms-vob": {
            "source": "apache",
            "extensions": [
                "vob"
            ]
        },
        "video/x-ms-wm": {
            "source": "apache",
            "extensions": [
                "wm"
            ]
        },
        "video/x-ms-wmv": {
            "source": "apache",
            "compressible": false,
            "extensions": [
                "wmv"
            ]
        },
        "video/x-ms-wmx": {
            "source": "apache",
            "extensions": [
                "wmx"
            ]
        },
        "video/x-ms-wvx": {
            "source": "apache",
            "extensions": [
                "wvx"
            ]
        },
        "video/x-msvideo": {
            "source": "apache",
            "extensions": [
                "avi"
            ]
        },
        "video/x-sgi-movie": {
            "source": "apache",
            "extensions": [
                "movie"
            ]
        },
        "video/x-smv": {
            "source": "apache",
            "extensions": [
                "smv"
            ]
        },
        "x-conference/x-cooltalk": {
            "source": "apache",
            "extensions": [
                "ice"
            ]
        },
        "x-shader/x-fragment": {
            "compressible": true
        },
        "x-shader/x-vertex": {
            "compressible": true
        }
    };
}
,
"2da46d7c":/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "isPlainObject", ()=>isPlainObject);
    function isObject(o) {
        return Object.prototype.toString.call(o) === '[object Object]';
    }
    function isPlainObject(o) {
        var ctor, prot;
        if (isObject(o) === false) return false;
        ctor = o.constructor;
        if (ctor === undefined) return true;
        prot = ctor.prototype;
        if (isObject(prot) === false) return false;
        if (prot.hasOwnProperty('isPrototypeOf') === false) {
            return false;
        }
        return true;
    }
}
,
"2e00eeca":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const mimicFn = farmRequire("9f93fed5", true);
    const calledFunctions = new WeakMap();
    const onetime = (function_, options = {})=>{
        if (typeof function_ !== 'function') {
            throw new TypeError('Expected a function');
        }
        let returnValue;
        let callCount = 0;
        const functionName = function_.displayName || function_.name || '<anonymous>';
        const onetime = function(...arguments_) {
            calledFunctions.set(onetime, ++callCount);
            if (callCount === 1) {
                returnValue = function_.apply(this, arguments_);
                function_ = null;
            } else if (options.throw === true) {
                throw new Error(`Function \`${functionName}\` can only be called once`);
            }
            return returnValue;
        };
        mimicFn(onetime, function_);
        calledFunctions.set(onetime, callCount);
        return onetime;
    };
    module.exports = onetime;
    module.exports.default = onetime;
    module.exports.callCount = (function_)=>{
        if (!calledFunctions.has(function_)) {
            throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
        }
        return calledFunctions.get(function_);
    };
}
,
"2e2a91c0":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
    function escapeCommand(arg) {
        arg = arg.replace(metaCharsRegExp, '^$1');
        return arg;
    }
    function escapeArgument(arg, doubleEscapeMetaChars) {
        arg = `${arg}`;
        arg = arg.replace(/(\\*)"/g, '$1$1\\"');
        arg = arg.replace(/(\\*)$/, '$1$1');
        arg = `"${arg}"`;
        arg = arg.replace(metaCharsRegExp, '^$1');
        if (doubleEscapeMetaChars) {
            arg = arg.replace(metaCharsRegExp, '^$1');
        }
        return arg;
    }
    module.exports.command = escapeCommand;
    module.exports.argument = escapeArgument;
}
,
"2f90b0a5":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.Debug = void 0;
    const createDebug = farmRequire("50d83445", true);
    exports.Debug = createDebug('http-proxy-middleware');
}
,
"303b4a27":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "normalizeResolve", ()=>normalizeResolve);
    var _f_constants = farmRequire("97f6a66c");
    function normalizeResolve(config, resolvedCompilation) {
        let dedupe = [
            ...config?.compilation?.custom[_f_constants.CUSTOM_KEYS.resolve_dedupe] ?? []
        ];
        if (config?.compilation?.resolve?.dedupe) {
            dedupe = config.compilation.resolve.dedupe;
            delete config.compilation.resolve.dedupe;
        }
        resolvedCompilation.custom[_f_constants.CUSTOM_KEYS.resolve_dedupe] = JSON.stringify(dedupe);
    }
}
,
"30e626fc":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const { Duplex } = global.nodeRequire('stream', true);
    const { randomFillSync } = global.nodeRequire('crypto', true);
    const PerMessageDeflate = farmRequire("6e9f2004", true);
    const { EMPTY_BUFFER } = farmRequire("75844d1d", true);
    const { isValidStatusCode } = farmRequire("9887cd18", true);
    const { mask: applyMask, toBuffer } = farmRequire("2be17525", true);
    const kByteLength = Symbol('kByteLength');
    const maskBuffer = Buffer.alloc(4);
    class Sender {
        constructor(socket, extensions, generateMask){
            this._extensions = extensions || {};
            if (generateMask) {
                this._generateMask = generateMask;
                this._maskBuffer = Buffer.alloc(4);
            }
            this._socket = socket;
            this._firstFragment = true;
            this._compress = false;
            this._bufferedBytes = 0;
            this._deflating = false;
            this._queue = [];
        }
        static frame(data, options) {
            let mask;
            let merge = false;
            let offset = 2;
            let skipMasking = false;
            if (options.mask) {
                mask = options.maskBuffer || maskBuffer;
                if (options.generateMask) {
                    options.generateMask(mask);
                } else {
                    randomFillSync(mask, 0, 4);
                }
                skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
                offset = 6;
            }
            let dataLength;
            if (typeof data === 'string') {
                if ((!options.mask || skipMasking) && options[kByteLength] !== undefined) {
                    dataLength = options[kByteLength];
                } else {
                    data = Buffer.from(data);
                    dataLength = data.length;
                }
            } else {
                dataLength = data.length;
                merge = options.mask && options.readOnly && !skipMasking;
            }
            let payloadLength = dataLength;
            if (dataLength >= 65536) {
                offset += 8;
                payloadLength = 127;
            } else if (dataLength > 125) {
                offset += 2;
                payloadLength = 126;
            }
            const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
            target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
            if (options.rsv1) target[0] |= 0x40;
            target[1] = payloadLength;
            if (payloadLength === 126) {
                target.writeUInt16BE(dataLength, 2);
            } else if (payloadLength === 127) {
                target[2] = target[3] = 0;
                target.writeUIntBE(dataLength, 4, 6);
            }
            if (!options.mask) return [
                target,
                data
            ];
            target[1] |= 0x80;
            target[offset - 4] = mask[0];
            target[offset - 3] = mask[1];
            target[offset - 2] = mask[2];
            target[offset - 1] = mask[3];
            if (skipMasking) return [
                target,
                data
            ];
            if (merge) {
                applyMask(data, mask, target, offset, dataLength);
                return [
                    target
                ];
            }
            applyMask(data, mask, data, 0, dataLength);
            return [
                target,
                data
            ];
        }
        close(code, data, mask, cb) {
            let buf;
            if (code === undefined) {
                buf = EMPTY_BUFFER;
            } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
                throw new TypeError('First argument must be a valid error code number');
            } else if (data === undefined || !data.length) {
                buf = Buffer.allocUnsafe(2);
                buf.writeUInt16BE(code, 0);
            } else {
                const length = Buffer.byteLength(data);
                if (length > 123) {
                    throw new RangeError('The message must not be greater than 123 bytes');
                }
                buf = Buffer.allocUnsafe(2 + length);
                buf.writeUInt16BE(code, 0);
                if (typeof data === 'string') {
                    buf.write(data, 2);
                } else {
                    buf.set(data, 2);
                }
            }
            const options = {
                [kByteLength]: buf.length,
                fin: true,
                generateMask: this._generateMask,
                mask,
                maskBuffer: this._maskBuffer,
                opcode: 0x08,
                readOnly: false,
                rsv1: false
            };
            if (this._deflating) {
                this.enqueue([
                    this.dispatch,
                    buf,
                    false,
                    options,
                    cb
                ]);
            } else {
                this.sendFrame(Sender.frame(buf, options), cb);
            }
        }
        ping(data, mask, cb) {
            let byteLength;
            let readOnly;
            if (typeof data === 'string') {
                byteLength = Buffer.byteLength(data);
                readOnly = false;
            } else {
                data = toBuffer(data);
                byteLength = data.length;
                readOnly = toBuffer.readOnly;
            }
            if (byteLength > 125) {
                throw new RangeError('The data size must not be greater than 125 bytes');
            }
            const options = {
                [kByteLength]: byteLength,
                fin: true,
                generateMask: this._generateMask,
                mask,
                maskBuffer: this._maskBuffer,
                opcode: 0x09,
                readOnly,
                rsv1: false
            };
            if (this._deflating) {
                this.enqueue([
                    this.dispatch,
                    data,
                    false,
                    options,
                    cb
                ]);
            } else {
                this.sendFrame(Sender.frame(data, options), cb);
            }
        }
        pong(data, mask, cb) {
            let byteLength;
            let readOnly;
            if (typeof data === 'string') {
                byteLength = Buffer.byteLength(data);
                readOnly = false;
            } else {
                data = toBuffer(data);
                byteLength = data.length;
                readOnly = toBuffer.readOnly;
            }
            if (byteLength > 125) {
                throw new RangeError('The data size must not be greater than 125 bytes');
            }
            const options = {
                [kByteLength]: byteLength,
                fin: true,
                generateMask: this._generateMask,
                mask,
                maskBuffer: this._maskBuffer,
                opcode: 0x0a,
                readOnly,
                rsv1: false
            };
            if (this._deflating) {
                this.enqueue([
                    this.dispatch,
                    data,
                    false,
                    options,
                    cb
                ]);
            } else {
                this.sendFrame(Sender.frame(data, options), cb);
            }
        }
        send(data, options, cb) {
            const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
            let opcode = options.binary ? 2 : 1;
            let rsv1 = options.compress;
            let byteLength;
            let readOnly;
            if (typeof data === 'string') {
                byteLength = Buffer.byteLength(data);
                readOnly = false;
            } else {
                data = toBuffer(data);
                byteLength = data.length;
                readOnly = toBuffer.readOnly;
            }
            if (this._firstFragment) {
                this._firstFragment = false;
                if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? 'server_no_context_takeover' : 'client_no_context_takeover']) {
                    rsv1 = byteLength >= perMessageDeflate._threshold;
                }
                this._compress = rsv1;
            } else {
                rsv1 = false;
                opcode = 0;
            }
            if (options.fin) this._firstFragment = true;
            if (perMessageDeflate) {
                const opts = {
                    [kByteLength]: byteLength,
                    fin: options.fin,
                    generateMask: this._generateMask,
                    mask: options.mask,
                    maskBuffer: this._maskBuffer,
                    opcode,
                    readOnly,
                    rsv1
                };
                if (this._deflating) {
                    this.enqueue([
                        this.dispatch,
                        data,
                        this._compress,
                        opts,
                        cb
                    ]);
                } else {
                    this.dispatch(data, this._compress, opts, cb);
                }
            } else {
                this.sendFrame(Sender.frame(data, {
                    [kByteLength]: byteLength,
                    fin: options.fin,
                    generateMask: this._generateMask,
                    mask: options.mask,
                    maskBuffer: this._maskBuffer,
                    opcode,
                    readOnly,
                    rsv1: false
                }), cb);
            }
        }
        dispatch(data, compress, options, cb) {
            if (!compress) {
                this.sendFrame(Sender.frame(data, options), cb);
                return;
            }
            const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
            this._bufferedBytes += options[kByteLength];
            this._deflating = true;
            perMessageDeflate.compress(data, options.fin, (_, buf)=>{
                if (this._socket.destroyed) {
                    const err = new Error('The socket was closed while data was being compressed');
                    if (typeof cb === 'function') cb(err);
                    for(let i = 0; i < this._queue.length; i++){
                        const params = this._queue[i];
                        const callback = params[params.length - 1];
                        if (typeof callback === 'function') callback(err);
                    }
                    return;
                }
                this._bufferedBytes -= options[kByteLength];
                this._deflating = false;
                options.readOnly = false;
                this.sendFrame(Sender.frame(buf, options), cb);
                this.dequeue();
            });
        }
        dequeue() {
            while(!this._deflating && this._queue.length){
                const params = this._queue.shift();
                this._bufferedBytes -= params[3][kByteLength];
                Reflect.apply(params[0], this, params.slice(1));
            }
        }
        enqueue(params) {
            this._bufferedBytes += params[3][kByteLength];
            this._queue.push(params);
        }
        sendFrame(list, cb) {
            if (list.length === 2) {
                this._socket.cork();
                this._socket.write(list[0]);
                this._socket.write(list[1], cb);
                this._socket.uncork();
            } else {
                this._socket.write(list[0], cb);
            }
        }
    }
    module.exports = Sender;
}
,
"31748dff":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
            desc = {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            };
        }
        Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    });
    var __exportStar = this && this.__exportStar || function(m, exports1) {
        for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
    };
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    __exportStar(farmRequire("2a212bb3", true), exports);
    __exportStar(farmRequire("bbe0ad7e", true), exports);
    __exportStar(farmRequire("df6e4745", true), exports);
    __exportStar(farmRequire("d6873c6c", true), exports);
}
,
"3226da43":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "default", ()=>z);
    module.o(exports, "z", ()=>z);
    var util;
    (function(util) {
        util.assertEqual = (val)=>val;
        function assertIs(_arg) {}
        util.assertIs = assertIs;
        function assertNever(_x) {
            throw new Error();
        }
        util.assertNever = assertNever;
        util.arrayToEnum = (items)=>{
            const obj = {};
            for (const item of items){
                obj[item] = item;
            }
            return obj;
        };
        util.getValidEnumValues = (obj)=>{
            const validKeys = util.objectKeys(obj).filter((k)=>typeof obj[obj[k]] !== "number");
            const filtered = {};
            for (const k of validKeys){
                filtered[k] = obj[k];
            }
            return util.objectValues(filtered);
        };
        util.objectValues = (obj)=>{
            return util.objectKeys(obj).map(function(e) {
                return obj[e];
            });
        };
        util.objectKeys = typeof Object.keys === "function" ? (obj)=>Object.keys(obj) : (object)=>{
            const keys = [];
            for(const key in object){
                if (Object.prototype.hasOwnProperty.call(object, key)) {
                    keys.push(key);
                }
            }
            return keys;
        };
        util.find = (arr, checker)=>{
            for (const item of arr){
                if (checker(item)) return item;
            }
            return undefined;
        };
        util.isInteger = typeof Number.isInteger === "function" ? (val)=>Number.isInteger(val) : (val)=>typeof val === "number" && isFinite(val) && Math.floor(val) === val;
        function joinValues(array, separator = " | ") {
            return array.map((val)=>typeof val === "string" ? `'${val}'` : val).join(separator);
        }
        util.joinValues = joinValues;
        util.jsonStringifyReplacer = (_, value)=>{
            if (typeof value === "bigint") {
                return value.toString();
            }
            return value;
        };
    })(util || (util = {}));
    var objectUtil;
    (function(objectUtil) {
        objectUtil.mergeShapes = (first, second)=>{
            return {
                ...first,
                ...second
            };
        };
    })(objectUtil || (objectUtil = {}));
    const ZodParsedType = util.arrayToEnum([
        "string",
        "nan",
        "number",
        "integer",
        "float",
        "boolean",
        "date",
        "bigint",
        "symbol",
        "function",
        "undefined",
        "null",
        "array",
        "object",
        "unknown",
        "promise",
        "void",
        "never",
        "map",
        "set"
    ]);
    const getParsedType = (data)=>{
        const t = typeof data;
        switch(t){
            case "undefined":
                return ZodParsedType.undefined;
            case "string":
                return ZodParsedType.string;
            case "number":
                return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
            case "boolean":
                return ZodParsedType.boolean;
            case "function":
                return ZodParsedType.function;
            case "bigint":
                return ZodParsedType.bigint;
            case "symbol":
                return ZodParsedType.symbol;
            case "object":
                if (Array.isArray(data)) {
                    return ZodParsedType.array;
                }
                if (data === null) {
                    return ZodParsedType.null;
                }
                if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
                    return ZodParsedType.promise;
                }
                if (typeof Map !== "undefined" && data instanceof Map) {
                    return ZodParsedType.map;
                }
                if (typeof Set !== "undefined" && data instanceof Set) {
                    return ZodParsedType.set;
                }
                if (typeof Date !== "undefined" && data instanceof Date) {
                    return ZodParsedType.date;
                }
                return ZodParsedType.object;
            default:
                return ZodParsedType.unknown;
        }
    };
    const ZodIssueCode = util.arrayToEnum([
        "invalid_type",
        "invalid_literal",
        "custom",
        "invalid_union",
        "invalid_union_discriminator",
        "invalid_enum_value",
        "unrecognized_keys",
        "invalid_arguments",
        "invalid_return_type",
        "invalid_date",
        "invalid_string",
        "too_small",
        "too_big",
        "invalid_intersection_types",
        "not_multiple_of",
        "not_finite"
    ]);
    const quotelessJson = (obj)=>{
        const json = JSON.stringify(obj, null, 2);
        return json.replace(/"([^"]+)":/g, "$1:");
    };
    class ZodError extends Error {
        constructor(issues){
            super();
            this.issues = [];
            this.addIssue = (sub)=>{
                this.issues = [
                    ...this.issues,
                    sub
                ];
            };
            this.addIssues = (subs = [])=>{
                this.issues = [
                    ...this.issues,
                    ...subs
                ];
            };
            const actualProto = new.target.prototype;
            if (Object.setPrototypeOf) {
                Object.setPrototypeOf(this, actualProto);
            } else {
                this.__proto__ = actualProto;
            }
            this.name = "ZodError";
            this.issues = issues;
        }
        get errors() {
            return this.issues;
        }
        format(_mapper) {
            const mapper = _mapper || function(issue) {
                return issue.message;
            };
            const fieldErrors = {
                _errors: []
            };
            const processError = (error)=>{
                for (const issue of error.issues){
                    if (issue.code === "invalid_union") {
                        issue.unionErrors.map(processError);
                    } else if (issue.code === "invalid_return_type") {
                        processError(issue.returnTypeError);
                    } else if (issue.code === "invalid_arguments") {
                        processError(issue.argumentsError);
                    } else if (issue.path.length === 0) {
                        fieldErrors._errors.push(mapper(issue));
                    } else {
                        let curr = fieldErrors;
                        let i = 0;
                        while(i < issue.path.length){
                            const el = issue.path[i];
                            const terminal = i === issue.path.length - 1;
                            if (!terminal) {
                                curr[el] = curr[el] || {
                                    _errors: []
                                };
                            } else {
                                curr[el] = curr[el] || {
                                    _errors: []
                                };
                                curr[el]._errors.push(mapper(issue));
                            }
                            curr = curr[el];
                            i++;
                        }
                    }
                }
            };
            processError(this);
            return fieldErrors;
        }
        static assert(value) {
            if (!(value instanceof ZodError)) {
                throw new Error(`Not a ZodError: ${value}`);
            }
        }
        toString() {
            return this.message;
        }
        get message() {
            return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
        }
        get isEmpty() {
            return this.issues.length === 0;
        }
        flatten(mapper = (issue)=>issue.message) {
            const fieldErrors = {};
            const formErrors = [];
            for (const sub of this.issues){
                if (sub.path.length > 0) {
                    fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
                    fieldErrors[sub.path[0]].push(mapper(sub));
                } else {
                    formErrors.push(mapper(sub));
                }
            }
            return {
                formErrors,
                fieldErrors
            };
        }
        get formErrors() {
            return this.flatten();
        }
    }
    ZodError.create = (issues)=>{
        const error = new ZodError(issues);
        return error;
    };
    const errorMap = (issue, _ctx)=>{
        let message;
        switch(issue.code){
            case ZodIssueCode.invalid_type:
                if (issue.received === ZodParsedType.undefined) {
                    message = "Required";
                } else {
                    message = `Expected ${issue.expected}, received ${issue.received}`;
                }
                break;
            case ZodIssueCode.invalid_literal:
                message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
                break;
            case ZodIssueCode.unrecognized_keys:
                message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
                break;
            case ZodIssueCode.invalid_union:
                message = `Invalid input`;
                break;
            case ZodIssueCode.invalid_union_discriminator:
                message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
                break;
            case ZodIssueCode.invalid_enum_value:
                message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
                break;
            case ZodIssueCode.invalid_arguments:
                message = `Invalid function arguments`;
                break;
            case ZodIssueCode.invalid_return_type:
                message = `Invalid function return type`;
                break;
            case ZodIssueCode.invalid_date:
                message = `Invalid date`;
                break;
            case ZodIssueCode.invalid_string:
                if (typeof issue.validation === "object") {
                    if ("includes" in issue.validation) {
                        message = `Invalid input: must include "${issue.validation.includes}"`;
                        if (typeof issue.validation.position === "number") {
                            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
                        }
                    } else if ("startsWith" in issue.validation) {
                        message = `Invalid input: must start with "${issue.validation.startsWith}"`;
                    } else if ("endsWith" in issue.validation) {
                        message = `Invalid input: must end with "${issue.validation.endsWith}"`;
                    } else {
                        util.assertNever(issue.validation);
                    }
                } else if (issue.validation !== "regex") {
                    message = `Invalid ${issue.validation}`;
                } else {
                    message = "Invalid";
                }
                break;
            case ZodIssueCode.too_small:
                if (issue.type === "array") message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
                else if (issue.type === "string") message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
                else if (issue.type === "number") message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
                else if (issue.type === "date") message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
                else message = "Invalid input";
                break;
            case ZodIssueCode.too_big:
                if (issue.type === "array") message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
                else if (issue.type === "string") message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
                else if (issue.type === "number") message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
                else if (issue.type === "bigint") message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
                else if (issue.type === "date") message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
                else message = "Invalid input";
                break;
            case ZodIssueCode.custom:
                message = `Invalid input`;
                break;
            case ZodIssueCode.invalid_intersection_types:
                message = `Intersection results could not be merged`;
                break;
            case ZodIssueCode.not_multiple_of:
                message = `Number must be a multiple of ${issue.multipleOf}`;
                break;
            case ZodIssueCode.not_finite:
                message = "Number must be finite";
                break;
            default:
                message = _ctx.defaultError;
                util.assertNever(issue);
        }
        return {
            message
        };
    };
    let overrideErrorMap = errorMap;
    function setErrorMap(map) {
        overrideErrorMap = map;
    }
    function getErrorMap() {
        return overrideErrorMap;
    }
    const makeIssue = (params)=>{
        const { data, path, errorMaps, issueData } = params;
        const fullPath = [
            ...path,
            ...issueData.path || []
        ];
        const fullIssue = {
            ...issueData,
            path: fullPath
        };
        if (issueData.message !== undefined) {
            return {
                ...issueData,
                path: fullPath,
                message: issueData.message
            };
        }
        let errorMessage = "";
        const maps = errorMaps.filter((m)=>!!m).slice().reverse();
        for (const map of maps){
            errorMessage = map(fullIssue, {
                data,
                defaultError: errorMessage
            }).message;
        }
        return {
            ...issueData,
            path: fullPath,
            message: errorMessage
        };
    };
    const EMPTY_PATH = [];
    function addIssueToContext(ctx, issueData) {
        const overrideMap = getErrorMap();
        const issue = makeIssue({
            issueData: issueData,
            data: ctx.data,
            path: ctx.path,
            errorMaps: [
                ctx.common.contextualErrorMap,
                ctx.schemaErrorMap,
                overrideMap,
                overrideMap === errorMap ? undefined : errorMap
            ].filter((x)=>!!x)
        });
        ctx.common.issues.push(issue);
    }
    class ParseStatus {
        constructor(){
            this.value = "valid";
        }
        dirty() {
            if (this.value === "valid") this.value = "dirty";
        }
        abort() {
            if (this.value !== "aborted") this.value = "aborted";
        }
        static mergeArray(status, results) {
            const arrayValue = [];
            for (const s of results){
                if (s.status === "aborted") return INVALID;
                if (s.status === "dirty") status.dirty();
                arrayValue.push(s.value);
            }
            return {
                status: status.value,
                value: arrayValue
            };
        }
        static async mergeObjectAsync(status, pairs) {
            const syncPairs = [];
            for (const pair of pairs){
                const key = await pair.key;
                const value = await pair.value;
                syncPairs.push({
                    key,
                    value
                });
            }
            return ParseStatus.mergeObjectSync(status, syncPairs);
        }
        static mergeObjectSync(status, pairs) {
            const finalObject = {};
            for (const pair of pairs){
                const { key, value } = pair;
                if (key.status === "aborted") return INVALID;
                if (value.status === "aborted") return INVALID;
                if (key.status === "dirty") status.dirty();
                if (value.status === "dirty") status.dirty();
                if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
                    finalObject[key.value] = value.value;
                }
            }
            return {
                status: status.value,
                value: finalObject
            };
        }
    }
    const INVALID = Object.freeze({
        status: "aborted"
    });
    const DIRTY = (value)=>({
            status: "dirty",
            value
        });
    const OK = (value)=>({
            status: "valid",
            value
        });
    const isAborted = (x)=>x.status === "aborted";
    const isDirty = (x)=>x.status === "dirty";
    const isValid = (x)=>x.status === "valid";
    const isAsync = (x)=>typeof Promise !== "undefined" && x instanceof Promise;
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    }
    var errorUtil;
    (function(errorUtil) {
        errorUtil.errToObj = (message)=>typeof message === "string" ? {
                message
            } : message || {};
        errorUtil.toString = (message)=>typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
    })(errorUtil || (errorUtil = {}));
    var _ZodEnum_cache, _ZodNativeEnum_cache;
    class ParseInputLazyPath {
        constructor(parent, value, path, key){
            this._cachedPath = [];
            this.parent = parent;
            this.data = value;
            this._path = path;
            this._key = key;
        }
        get path() {
            if (!this._cachedPath.length) {
                if (this._key instanceof Array) {
                    this._cachedPath.push(...this._path, ...this._key);
                } else {
                    this._cachedPath.push(...this._path, this._key);
                }
            }
            return this._cachedPath;
        }
    }
    const handleResult = (ctx, result)=>{
        if (isValid(result)) {
            return {
                success: true,
                data: result.value
            };
        } else {
            if (!ctx.common.issues.length) {
                throw new Error("Validation failed but no issues detected.");
            }
            return {
                success: false,
                get error () {
                    if (this._error) return this._error;
                    const error = new ZodError(ctx.common.issues);
                    this._error = error;
                    return this._error;
                }
            };
        }
    };
    function processCreateParams(params) {
        if (!params) return {};
        const { errorMap, invalid_type_error, required_error, description } = params;
        if (errorMap && (invalid_type_error || required_error)) {
            throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
        }
        if (errorMap) return {
            errorMap: errorMap,
            description
        };
        const customMap = (iss, ctx)=>{
            var _a, _b;
            const { message } = params;
            if (iss.code === "invalid_enum_value") {
                return {
                    message: message !== null && message !== void 0 ? message : ctx.defaultError
                };
            }
            if (typeof ctx.data === "undefined") {
                return {
                    message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError
                };
            }
            if (iss.code !== "invalid_type") return {
                message: ctx.defaultError
            };
            return {
                message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError
            };
        };
        return {
            errorMap: customMap,
            description
        };
    }
    class ZodType {
        constructor(def){
            this.spa = this.safeParseAsync;
            this._def = def;
            this.parse = this.parse.bind(this);
            this.safeParse = this.safeParse.bind(this);
            this.parseAsync = this.parseAsync.bind(this);
            this.safeParseAsync = this.safeParseAsync.bind(this);
            this.spa = this.spa.bind(this);
            this.refine = this.refine.bind(this);
            this.refinement = this.refinement.bind(this);
            this.superRefine = this.superRefine.bind(this);
            this.optional = this.optional.bind(this);
            this.nullable = this.nullable.bind(this);
            this.nullish = this.nullish.bind(this);
            this.array = this.array.bind(this);
            this.promise = this.promise.bind(this);
            this.or = this.or.bind(this);
            this.and = this.and.bind(this);
            this.transform = this.transform.bind(this);
            this.brand = this.brand.bind(this);
            this.default = this.default.bind(this);
            this.catch = this.catch.bind(this);
            this.describe = this.describe.bind(this);
            this.pipe = this.pipe.bind(this);
            this.readonly = this.readonly.bind(this);
            this.isNullable = this.isNullable.bind(this);
            this.isOptional = this.isOptional.bind(this);
        }
        get description() {
            return this._def.description;
        }
        _getType(input) {
            return getParsedType(input.data);
        }
        _getOrReturnCtx(input, ctx) {
            return ctx || {
                common: input.parent.common,
                data: input.data,
                parsedType: getParsedType(input.data),
                schemaErrorMap: this._def.errorMap,
                path: input.path,
                parent: input.parent
            };
        }
        _processInputParams(input) {
            return {
                status: new ParseStatus(),
                ctx: {
                    common: input.parent.common,
                    data: input.data,
                    parsedType: getParsedType(input.data),
                    schemaErrorMap: this._def.errorMap,
                    path: input.path,
                    parent: input.parent
                }
            };
        }
        _parseSync(input) {
            const result = this._parse(input);
            if (isAsync(result)) {
                throw new Error("Synchronous parse encountered promise.");
            }
            return result;
        }
        _parseAsync(input) {
            const result = this._parse(input);
            return Promise.resolve(result);
        }
        parse(data, params) {
            const result = this.safeParse(data, params);
            if (result.success) return result.data;
            throw result.error;
        }
        safeParse(data, params) {
            var _a;
            const ctx = {
                common: {
                    issues: [],
                    async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
                    contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
                },
                path: (params === null || params === void 0 ? void 0 : params.path) || [],
                schemaErrorMap: this._def.errorMap,
                parent: null,
                data,
                parsedType: getParsedType(data)
            };
            const result = this._parseSync({
                data,
                path: ctx.path,
                parent: ctx
            });
            return handleResult(ctx, result);
        }
        async parseAsync(data, params) {
            const result = await this.safeParseAsync(data, params);
            if (result.success) return result.data;
            throw result.error;
        }
        async safeParseAsync(data, params) {
            const ctx = {
                common: {
                    issues: [],
                    contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
                    async: true
                },
                path: (params === null || params === void 0 ? void 0 : params.path) || [],
                schemaErrorMap: this._def.errorMap,
                parent: null,
                data,
                parsedType: getParsedType(data)
            };
            const maybeAsyncResult = this._parse({
                data,
                path: ctx.path,
                parent: ctx
            });
            const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
            return handleResult(ctx, result);
        }
        refine(check, message) {
            const getIssueProperties = (val)=>{
                if (typeof message === "string" || typeof message === "undefined") {
                    return {
                        message
                    };
                } else if (typeof message === "function") {
                    return message(val);
                } else {
                    return message;
                }
            };
            return this._refinement((val, ctx)=>{
                const result = check(val);
                const setError = ()=>ctx.addIssue({
                        code: ZodIssueCode.custom,
                        ...getIssueProperties(val)
                    });
                if (typeof Promise !== "undefined" && result instanceof Promise) {
                    return result.then((data)=>{
                        if (!data) {
                            setError();
                            return false;
                        } else {
                            return true;
                        }
                    });
                }
                if (!result) {
                    setError();
                    return false;
                } else {
                    return true;
                }
            });
        }
        refinement(check, refinementData) {
            return this._refinement((val, ctx)=>{
                if (!check(val)) {
                    ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
                    return false;
                } else {
                    return true;
                }
            });
        }
        _refinement(refinement) {
            return new ZodEffects({
                schema: this,
                typeName: ZodFirstPartyTypeKind.ZodEffects,
                effect: {
                    type: "refinement",
                    refinement
                }
            });
        }
        superRefine(refinement) {
            return this._refinement(refinement);
        }
        optional() {
            return ZodOptional.create(this, this._def);
        }
        nullable() {
            return ZodNullable.create(this, this._def);
        }
        nullish() {
            return this.nullable().optional();
        }
        array() {
            return ZodArray.create(this, this._def);
        }
        promise() {
            return ZodPromise.create(this, this._def);
        }
        or(option) {
            return ZodUnion.create([
                this,
                option
            ], this._def);
        }
        and(incoming) {
            return ZodIntersection.create(this, incoming, this._def);
        }
        transform(transform) {
            return new ZodEffects({
                ...processCreateParams(this._def),
                schema: this,
                typeName: ZodFirstPartyTypeKind.ZodEffects,
                effect: {
                    type: "transform",
                    transform
                }
            });
        }
        default(def) {
            const defaultValueFunc = typeof def === "function" ? def : ()=>def;
            return new ZodDefault({
                ...processCreateParams(this._def),
                innerType: this,
                defaultValue: defaultValueFunc,
                typeName: ZodFirstPartyTypeKind.ZodDefault
            });
        }
        brand() {
            return new ZodBranded({
                typeName: ZodFirstPartyTypeKind.ZodBranded,
                type: this,
                ...processCreateParams(this._def)
            });
        }
        catch(def) {
            const catchValueFunc = typeof def === "function" ? def : ()=>def;
            return new ZodCatch({
                ...processCreateParams(this._def),
                innerType: this,
                catchValue: catchValueFunc,
                typeName: ZodFirstPartyTypeKind.ZodCatch
            });
        }
        describe(description) {
            const This = this.constructor;
            return new This({
                ...this._def,
                description
            });
        }
        pipe(target) {
            return ZodPipeline.create(this, target);
        }
        readonly() {
            return ZodReadonly.create(this);
        }
        isOptional() {
            return this.safeParse(undefined).success;
        }
        isNullable() {
            return this.safeParse(null).success;
        }
    }
    const cuidRegex = /^c[^\s-]{8,}$/i;
    const cuid2Regex = /^[0-9a-z]+$/;
    const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
    const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
    const nanoidRegex = /^[a-z0-9_-]{21}$/i;
    const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
    const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
    const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    let emojiRegex;
    const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    const ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
    const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
    const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
    const dateRegex = new RegExp(`^${dateRegexSource}$`);
    function timeRegexSource(args) {
        let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
        if (args.precision) {
            regex = `${regex}\\.\\d{${args.precision}}`;
        } else if (args.precision == null) {
            regex = `${regex}(\\.\\d+)?`;
        }
        return regex;
    }
    function timeRegex(args) {
        return new RegExp(`^${timeRegexSource(args)}$`);
    }
    function datetimeRegex(args) {
        let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
        const opts = [];
        opts.push(args.local ? `Z?` : `Z`);
        if (args.offset) opts.push(`([+-]\\d{2}:?\\d{2})`);
        regex = `${regex}(${opts.join("|")})`;
        return new RegExp(`^${regex}$`);
    }
    function isValidIP(ip, version) {
        if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
            return true;
        }
        if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
            return true;
        }
        return false;
    }
    class ZodString extends ZodType {
        _parse(input) {
            if (this._def.coerce) {
                input.data = String(input.data);
            }
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.string) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.string,
                    received: ctx.parsedType
                });
                return INVALID;
            }
            const status = new ParseStatus();
            let ctx = undefined;
            for (const check of this._def.checks){
                if (check.kind === "min") {
                    if (input.data.length < check.value) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            minimum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: false,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if (check.kind === "max") {
                    if (input.data.length > check.value) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            maximum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: false,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if (check.kind === "length") {
                    const tooBig = input.data.length > check.value;
                    const tooSmall = input.data.length < check.value;
                    if (tooBig || tooSmall) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        if (tooBig) {
                            addIssueToContext(ctx, {
                                code: ZodIssueCode.too_big,
                                maximum: check.value,
                                type: "string",
                                inclusive: true,
                                exact: true,
                                message: check.message
                            });
                        } else if (tooSmall) {
                            addIssueToContext(ctx, {
                                code: ZodIssueCode.too_small,
                                minimum: check.value,
                                type: "string",
                                inclusive: true,
                                exact: true,
                                message: check.message
                            });
                        }
                        status.dirty();
                    }
                } else if (check.kind === "email") {
                    if (!emailRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "email",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if (check.kind === "emoji") {
                    if (!emojiRegex) {
                        emojiRegex = new RegExp(_emojiRegex, "u");
                    }
                    if (!emojiRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "emoji",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if (check.kind === "uuid") {
                    if (!uuidRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "uuid",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if (check.kind === "nanoid") {
                    if (!nanoidRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "nanoid",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if (check.kind === "cuid") {
                    if (!cuidRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "cuid",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if (check.kind === "cuid2") {
                    if (!cuid2Regex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "cuid2",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if (check.kind === "ulid") {
                    if (!ulidRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "ulid",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if (check.kind === "url") {
                    try {
                        new URL(input.data);
                    } catch (_a) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "url",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if (check.kind === "regex") {
                    check.regex.lastIndex = 0;
                    const testResult = check.regex.test(input.data);
                    if (!testResult) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "regex",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if (check.kind === "trim") {
                    input.data = input.data.trim();
                } else if (check.kind === "includes") {
                    if (!input.data.includes(check.value, check.position)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_string,
                            validation: {
                                includes: check.value,
                                position: check.position
                            },
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if (check.kind === "toLowerCase") {
                    input.data = input.data.toLowerCase();
                } else if (check.kind === "toUpperCase") {
                    input.data = input.data.toUpperCase();
                } else if (check.kind === "startsWith") {
                    if (!input.data.startsWith(check.value)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_string,
                            validation: {
                                startsWith: check.value
                            },
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if (check.kind === "endsWith") {
                    if (!input.data.endsWith(check.value)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_string,
                            validation: {
                                endsWith: check.value
                            },
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if (check.kind === "datetime") {
                    const regex = datetimeRegex(check);
                    if (!regex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_string,
                            validation: "datetime",
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if (check.kind === "date") {
                    const regex = dateRegex;
                    if (!regex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_string,
                            validation: "date",
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if (check.kind === "time") {
                    const regex = timeRegex(check);
                    if (!regex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_string,
                            validation: "time",
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if (check.kind === "duration") {
                    if (!durationRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "duration",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if (check.kind === "ip") {
                    if (!isValidIP(input.data, check.version)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "ip",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if (check.kind === "base64") {
                    if (!base64Regex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "base64",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else {
                    util.assertNever(check);
                }
            }
            return {
                status: status.value,
                value: input.data
            };
        }
        _regex(regex, validation, message) {
            return this.refinement((data)=>regex.test(data), {
                validation,
                code: ZodIssueCode.invalid_string,
                ...errorUtil.errToObj(message)
            });
        }
        _addCheck(check) {
            return new ZodString({
                ...this._def,
                checks: [
                    ...this._def.checks,
                    check
                ]
            });
        }
        email(message) {
            return this._addCheck({
                kind: "email",
                ...errorUtil.errToObj(message)
            });
        }
        url(message) {
            return this._addCheck({
                kind: "url",
                ...errorUtil.errToObj(message)
            });
        }
        emoji(message) {
            return this._addCheck({
                kind: "emoji",
                ...errorUtil.errToObj(message)
            });
        }
        uuid(message) {
            return this._addCheck({
                kind: "uuid",
                ...errorUtil.errToObj(message)
            });
        }
        nanoid(message) {
            return this._addCheck({
                kind: "nanoid",
                ...errorUtil.errToObj(message)
            });
        }
        cuid(message) {
            return this._addCheck({
                kind: "cuid",
                ...errorUtil.errToObj(message)
            });
        }
        cuid2(message) {
            return this._addCheck({
                kind: "cuid2",
                ...errorUtil.errToObj(message)
            });
        }
        ulid(message) {
            return this._addCheck({
                kind: "ulid",
                ...errorUtil.errToObj(message)
            });
        }
        base64(message) {
            return this._addCheck({
                kind: "base64",
                ...errorUtil.errToObj(message)
            });
        }
        ip(options) {
            return this._addCheck({
                kind: "ip",
                ...errorUtil.errToObj(options)
            });
        }
        datetime(options) {
            var _a, _b;
            if (typeof options === "string") {
                return this._addCheck({
                    kind: "datetime",
                    precision: null,
                    offset: false,
                    local: false,
                    message: options
                });
            }
            return this._addCheck({
                kind: "datetime",
                precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
                offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
                local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
                ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
            });
        }
        date(message) {
            return this._addCheck({
                kind: "date",
                message
            });
        }
        time(options) {
            if (typeof options === "string") {
                return this._addCheck({
                    kind: "time",
                    precision: null,
                    message: options
                });
            }
            return this._addCheck({
                kind: "time",
                precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
                ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
            });
        }
        duration(message) {
            return this._addCheck({
                kind: "duration",
                ...errorUtil.errToObj(message)
            });
        }
        regex(regex, message) {
            return this._addCheck({
                kind: "regex",
                regex: regex,
                ...errorUtil.errToObj(message)
            });
        }
        includes(value, options) {
            return this._addCheck({
                kind: "includes",
                value: value,
                position: options === null || options === void 0 ? void 0 : options.position,
                ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
            });
        }
        startsWith(value, message) {
            return this._addCheck({
                kind: "startsWith",
                value: value,
                ...errorUtil.errToObj(message)
            });
        }
        endsWith(value, message) {
            return this._addCheck({
                kind: "endsWith",
                value: value,
                ...errorUtil.errToObj(message)
            });
        }
        min(minLength, message) {
            return this._addCheck({
                kind: "min",
                value: minLength,
                ...errorUtil.errToObj(message)
            });
        }
        max(maxLength, message) {
            return this._addCheck({
                kind: "max",
                value: maxLength,
                ...errorUtil.errToObj(message)
            });
        }
        length(len, message) {
            return this._addCheck({
                kind: "length",
                value: len,
                ...errorUtil.errToObj(message)
            });
        }
        nonempty(message) {
            return this.min(1, errorUtil.errToObj(message));
        }
        trim() {
            return new ZodString({
                ...this._def,
                checks: [
                    ...this._def.checks,
                    {
                        kind: "trim"
                    }
                ]
            });
        }
        toLowerCase() {
            return new ZodString({
                ...this._def,
                checks: [
                    ...this._def.checks,
                    {
                        kind: "toLowerCase"
                    }
                ]
            });
        }
        toUpperCase() {
            return new ZodString({
                ...this._def,
                checks: [
                    ...this._def.checks,
                    {
                        kind: "toUpperCase"
                    }
                ]
            });
        }
        get isDatetime() {
            return !!this._def.checks.find((ch)=>ch.kind === "datetime");
        }
        get isDate() {
            return !!this._def.checks.find((ch)=>ch.kind === "date");
        }
        get isTime() {
            return !!this._def.checks.find((ch)=>ch.kind === "time");
        }
        get isDuration() {
            return !!this._def.checks.find((ch)=>ch.kind === "duration");
        }
        get isEmail() {
            return !!this._def.checks.find((ch)=>ch.kind === "email");
        }
        get isURL() {
            return !!this._def.checks.find((ch)=>ch.kind === "url");
        }
        get isEmoji() {
            return !!this._def.checks.find((ch)=>ch.kind === "emoji");
        }
        get isUUID() {
            return !!this._def.checks.find((ch)=>ch.kind === "uuid");
        }
        get isNANOID() {
            return !!this._def.checks.find((ch)=>ch.kind === "nanoid");
        }
        get isCUID() {
            return !!this._def.checks.find((ch)=>ch.kind === "cuid");
        }
        get isCUID2() {
            return !!this._def.checks.find((ch)=>ch.kind === "cuid2");
        }
        get isULID() {
            return !!this._def.checks.find((ch)=>ch.kind === "ulid");
        }
        get isIP() {
            return !!this._def.checks.find((ch)=>ch.kind === "ip");
        }
        get isBase64() {
            return !!this._def.checks.find((ch)=>ch.kind === "base64");
        }
        get minLength() {
            let min = null;
            for (const ch of this._def.checks){
                if (ch.kind === "min") {
                    if (min === null || ch.value > min) min = ch.value;
                }
            }
            return min;
        }
        get maxLength() {
            let max = null;
            for (const ch of this._def.checks){
                if (ch.kind === "max") {
                    if (max === null || ch.value < max) max = ch.value;
                }
            }
            return max;
        }
    }
    ZodString.create = (params)=>{
        var _a;
        return new ZodString({
            checks: [],
            typeName: ZodFirstPartyTypeKind.ZodString,
            coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
            ...processCreateParams(params)
        });
    };
    function floatSafeRemainder(val, step) {
        const valDecCount = (val.toString().split(".")[1] || "").length;
        const stepDecCount = (step.toString().split(".")[1] || "").length;
        const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
        const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
        const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
        return valInt % stepInt / Math.pow(10, decCount);
    }
    class ZodNumber extends ZodType {
        constructor(){
            super(...arguments);
            this.min = this.gte;
            this.max = this.lte;
            this.step = this.multipleOf;
        }
        _parse(input) {
            if (this._def.coerce) {
                input.data = Number(input.data);
            }
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.number) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.number,
                    received: ctx.parsedType
                });
                return INVALID;
            }
            let ctx = undefined;
            const status = new ParseStatus();
            for (const check of this._def.checks){
                if (check.kind === "int") {
                    if (!util.isInteger(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_type,
                            expected: "integer",
                            received: "float",
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if (check.kind === "min") {
                    const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
                    if (tooSmall) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            minimum: check.value,
                            type: "number",
                            inclusive: check.inclusive,
                            exact: false,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if (check.kind === "max") {
                    const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
                    if (tooBig) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            maximum: check.value,
                            type: "number",
                            inclusive: check.inclusive,
                            exact: false,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if (check.kind === "multipleOf") {
                    if (floatSafeRemainder(input.data, check.value) !== 0) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.not_multiple_of,
                            multipleOf: check.value,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if (check.kind === "finite") {
                    if (!Number.isFinite(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.not_finite,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else {
                    util.assertNever(check);
                }
            }
            return {
                status: status.value,
                value: input.data
            };
        }
        gte(value, message) {
            return this.setLimit("min", value, true, errorUtil.toString(message));
        }
        gt(value, message) {
            return this.setLimit("min", value, false, errorUtil.toString(message));
        }
        lte(value, message) {
            return this.setLimit("max", value, true, errorUtil.toString(message));
        }
        lt(value, message) {
            return this.setLimit("max", value, false, errorUtil.toString(message));
        }
        setLimit(kind, value, inclusive, message) {
            return new ZodNumber({
                ...this._def,
                checks: [
                    ...this._def.checks,
                    {
                        kind,
                        value,
                        inclusive,
                        message: errorUtil.toString(message)
                    }
                ]
            });
        }
        _addCheck(check) {
            return new ZodNumber({
                ...this._def,
                checks: [
                    ...this._def.checks,
                    check
                ]
            });
        }
        int(message) {
            return this._addCheck({
                kind: "int",
                message: errorUtil.toString(message)
            });
        }
        positive(message) {
            return this._addCheck({
                kind: "min",
                value: 0,
                inclusive: false,
                message: errorUtil.toString(message)
            });
        }
        negative(message) {
            return this._addCheck({
                kind: "max",
                value: 0,
                inclusive: false,
                message: errorUtil.toString(message)
            });
        }
        nonpositive(message) {
            return this._addCheck({
                kind: "max",
                value: 0,
                inclusive: true,
                message: errorUtil.toString(message)
            });
        }
        nonnegative(message) {
            return this._addCheck({
                kind: "min",
                value: 0,
                inclusive: true,
                message: errorUtil.toString(message)
            });
        }
        multipleOf(value, message) {
            return this._addCheck({
                kind: "multipleOf",
                value: value,
                message: errorUtil.toString(message)
            });
        }
        finite(message) {
            return this._addCheck({
                kind: "finite",
                message: errorUtil.toString(message)
            });
        }
        safe(message) {
            return this._addCheck({
                kind: "min",
                inclusive: true,
                value: Number.MIN_SAFE_INTEGER,
                message: errorUtil.toString(message)
            })._addCheck({
                kind: "max",
                inclusive: true,
                value: Number.MAX_SAFE_INTEGER,
                message: errorUtil.toString(message)
            });
        }
        get minValue() {
            let min = null;
            for (const ch of this._def.checks){
                if (ch.kind === "min") {
                    if (min === null || ch.value > min) min = ch.value;
                }
            }
            return min;
        }
        get maxValue() {
            let max = null;
            for (const ch of this._def.checks){
                if (ch.kind === "max") {
                    if (max === null || ch.value < max) max = ch.value;
                }
            }
            return max;
        }
        get isInt() {
            return !!this._def.checks.find((ch)=>ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
        }
        get isFinite() {
            let max = null, min = null;
            for (const ch of this._def.checks){
                if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
                    return true;
                } else if (ch.kind === "min") {
                    if (min === null || ch.value > min) min = ch.value;
                } else if (ch.kind === "max") {
                    if (max === null || ch.value < max) max = ch.value;
                }
            }
            return Number.isFinite(min) && Number.isFinite(max);
        }
    }
    ZodNumber.create = (params)=>{
        return new ZodNumber({
            checks: [],
            typeName: ZodFirstPartyTypeKind.ZodNumber,
            coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
            ...processCreateParams(params)
        });
    };
    class ZodBigInt extends ZodType {
        constructor(){
            super(...arguments);
            this.min = this.gte;
            this.max = this.lte;
        }
        _parse(input) {
            if (this._def.coerce) {
                input.data = BigInt(input.data);
            }
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.bigint) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.bigint,
                    received: ctx.parsedType
                });
                return INVALID;
            }
            let ctx = undefined;
            const status = new ParseStatus();
            for (const check of this._def.checks){
                if (check.kind === "min") {
                    const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
                    if (tooSmall) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            type: "bigint",
                            minimum: check.value,
                            inclusive: check.inclusive,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if (check.kind === "max") {
                    const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
                    if (tooBig) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            type: "bigint",
                            maximum: check.value,
                            inclusive: check.inclusive,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if (check.kind === "multipleOf") {
                    if (input.data % check.value !== BigInt(0)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.not_multiple_of,
                            multipleOf: check.value,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else {
                    util.assertNever(check);
                }
            }
            return {
                status: status.value,
                value: input.data
            };
        }
        gte(value, message) {
            return this.setLimit("min", value, true, errorUtil.toString(message));
        }
        gt(value, message) {
            return this.setLimit("min", value, false, errorUtil.toString(message));
        }
        lte(value, message) {
            return this.setLimit("max", value, true, errorUtil.toString(message));
        }
        lt(value, message) {
            return this.setLimit("max", value, false, errorUtil.toString(message));
        }
        setLimit(kind, value, inclusive, message) {
            return new ZodBigInt({
                ...this._def,
                checks: [
                    ...this._def.checks,
                    {
                        kind,
                        value,
                        inclusive,
                        message: errorUtil.toString(message)
                    }
                ]
            });
        }
        _addCheck(check) {
            return new ZodBigInt({
                ...this._def,
                checks: [
                    ...this._def.checks,
                    check
                ]
            });
        }
        positive(message) {
            return this._addCheck({
                kind: "min",
                value: BigInt(0),
                inclusive: false,
                message: errorUtil.toString(message)
            });
        }
        negative(message) {
            return this._addCheck({
                kind: "max",
                value: BigInt(0),
                inclusive: false,
                message: errorUtil.toString(message)
            });
        }
        nonpositive(message) {
            return this._addCheck({
                kind: "max",
                value: BigInt(0),
                inclusive: true,
                message: errorUtil.toString(message)
            });
        }
        nonnegative(message) {
            return this._addCheck({
                kind: "min",
                value: BigInt(0),
                inclusive: true,
                message: errorUtil.toString(message)
            });
        }
        multipleOf(value, message) {
            return this._addCheck({
                kind: "multipleOf",
                value,
                message: errorUtil.toString(message)
            });
        }
        get minValue() {
            let min = null;
            for (const ch of this._def.checks){
                if (ch.kind === "min") {
                    if (min === null || ch.value > min) min = ch.value;
                }
            }
            return min;
        }
        get maxValue() {
            let max = null;
            for (const ch of this._def.checks){
                if (ch.kind === "max") {
                    if (max === null || ch.value < max) max = ch.value;
                }
            }
            return max;
        }
    }
    ZodBigInt.create = (params)=>{
        var _a;
        return new ZodBigInt({
            checks: [],
            typeName: ZodFirstPartyTypeKind.ZodBigInt,
            coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
            ...processCreateParams(params)
        });
    };
    class ZodBoolean extends ZodType {
        _parse(input) {
            if (this._def.coerce) {
                input.data = Boolean(input.data);
            }
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.boolean) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.boolean,
                    received: ctx.parsedType
                });
                return INVALID;
            }
            return OK(input.data);
        }
    }
    ZodBoolean.create = (params)=>{
        return new ZodBoolean({
            typeName: ZodFirstPartyTypeKind.ZodBoolean,
            coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
            ...processCreateParams(params)
        });
    };
    class ZodDate extends ZodType {
        _parse(input) {
            if (this._def.coerce) {
                input.data = new Date(input.data);
            }
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.date) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.date,
                    received: ctx.parsedType
                });
                return INVALID;
            }
            if (isNaN(input.data.getTime())) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_date
                });
                return INVALID;
            }
            const status = new ParseStatus();
            let ctx = undefined;
            for (const check of this._def.checks){
                if (check.kind === "min") {
                    if (input.data.getTime() < check.value) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            message: check.message,
                            inclusive: true,
                            exact: false,
                            minimum: check.value,
                            type: "date"
                        });
                        status.dirty();
                    }
                } else if (check.kind === "max") {
                    if (input.data.getTime() > check.value) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            message: check.message,
                            inclusive: true,
                            exact: false,
                            maximum: check.value,
                            type: "date"
                        });
                        status.dirty();
                    }
                } else {
                    util.assertNever(check);
                }
            }
            return {
                status: status.value,
                value: new Date(input.data.getTime())
            };
        }
        _addCheck(check) {
            return new ZodDate({
                ...this._def,
                checks: [
                    ...this._def.checks,
                    check
                ]
            });
        }
        min(minDate, message) {
            return this._addCheck({
                kind: "min",
                value: minDate.getTime(),
                message: errorUtil.toString(message)
            });
        }
        max(maxDate, message) {
            return this._addCheck({
                kind: "max",
                value: maxDate.getTime(),
                message: errorUtil.toString(message)
            });
        }
        get minDate() {
            let min = null;
            for (const ch of this._def.checks){
                if (ch.kind === "min") {
                    if (min === null || ch.value > min) min = ch.value;
                }
            }
            return min != null ? new Date(min) : null;
        }
        get maxDate() {
            let max = null;
            for (const ch of this._def.checks){
                if (ch.kind === "max") {
                    if (max === null || ch.value < max) max = ch.value;
                }
            }
            return max != null ? new Date(max) : null;
        }
    }
    ZodDate.create = (params)=>{
        return new ZodDate({
            checks: [],
            coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
            typeName: ZodFirstPartyTypeKind.ZodDate,
            ...processCreateParams(params)
        });
    };
    class ZodSymbol extends ZodType {
        _parse(input) {
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.symbol) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.symbol,
                    received: ctx.parsedType
                });
                return INVALID;
            }
            return OK(input.data);
        }
    }
    ZodSymbol.create = (params)=>{
        return new ZodSymbol({
            typeName: ZodFirstPartyTypeKind.ZodSymbol,
            ...processCreateParams(params)
        });
    };
    class ZodUndefined extends ZodType {
        _parse(input) {
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.undefined) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.undefined,
                    received: ctx.parsedType
                });
                return INVALID;
            }
            return OK(input.data);
        }
    }
    ZodUndefined.create = (params)=>{
        return new ZodUndefined({
            typeName: ZodFirstPartyTypeKind.ZodUndefined,
            ...processCreateParams(params)
        });
    };
    class ZodNull extends ZodType {
        _parse(input) {
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.null) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.null,
                    received: ctx.parsedType
                });
                return INVALID;
            }
            return OK(input.data);
        }
    }
    ZodNull.create = (params)=>{
        return new ZodNull({
            typeName: ZodFirstPartyTypeKind.ZodNull,
            ...processCreateParams(params)
        });
    };
    class ZodAny extends ZodType {
        constructor(){
            super(...arguments);
            this._any = true;
        }
        _parse(input) {
            return OK(input.data);
        }
    }
    ZodAny.create = (params)=>{
        return new ZodAny({
            typeName: ZodFirstPartyTypeKind.ZodAny,
            ...processCreateParams(params)
        });
    };
    class ZodUnknown extends ZodType {
        constructor(){
            super(...arguments);
            this._unknown = true;
        }
        _parse(input) {
            return OK(input.data);
        }
    }
    ZodUnknown.create = (params)=>{
        return new ZodUnknown({
            typeName: ZodFirstPartyTypeKind.ZodUnknown,
            ...processCreateParams(params)
        });
    };
    class ZodNever extends ZodType {
        _parse(input) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.never,
                received: ctx.parsedType
            });
            return INVALID;
        }
    }
    ZodNever.create = (params)=>{
        return new ZodNever({
            typeName: ZodFirstPartyTypeKind.ZodNever,
            ...processCreateParams(params)
        });
    };
    class ZodVoid extends ZodType {
        _parse(input) {
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.undefined) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.void,
                    received: ctx.parsedType
                });
                return INVALID;
            }
            return OK(input.data);
        }
    }
    ZodVoid.create = (params)=>{
        return new ZodVoid({
            typeName: ZodFirstPartyTypeKind.ZodVoid,
            ...processCreateParams(params)
        });
    };
    class ZodArray extends ZodType {
        _parse(input) {
            const { ctx, status } = this._processInputParams(input);
            const def = this._def;
            if (ctx.parsedType !== ZodParsedType.array) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.array,
                    received: ctx.parsedType
                });
                return INVALID;
            }
            if (def.exactLength !== null) {
                const tooBig = ctx.data.length > def.exactLength.value;
                const tooSmall = ctx.data.length < def.exactLength.value;
                if (tooBig || tooSmall) {
                    addIssueToContext(ctx, {
                        code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
                        minimum: tooSmall ? def.exactLength.value : undefined,
                        maximum: tooBig ? def.exactLength.value : undefined,
                        type: "array",
                        inclusive: true,
                        exact: true,
                        message: def.exactLength.message
                    });
                    status.dirty();
                }
            }
            if (def.minLength !== null) {
                if (ctx.data.length < def.minLength.value) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: def.minLength.value,
                        type: "array",
                        inclusive: true,
                        exact: false,
                        message: def.minLength.message
                    });
                    status.dirty();
                }
            }
            if (def.maxLength !== null) {
                if (ctx.data.length > def.maxLength.value) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: def.maxLength.value,
                        type: "array",
                        inclusive: true,
                        exact: false,
                        message: def.maxLength.message
                    });
                    status.dirty();
                }
            }
            if (ctx.common.async) {
                return Promise.all([
                    ...ctx.data
                ].map((item, i)=>{
                    return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
                })).then((result)=>{
                    return ParseStatus.mergeArray(status, result);
                });
            }
            const result = [
                ...ctx.data
            ].map((item, i)=>{
                return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
            });
            return ParseStatus.mergeArray(status, result);
        }
        get element() {
            return this._def.type;
        }
        min(minLength, message) {
            return new ZodArray({
                ...this._def,
                minLength: {
                    value: minLength,
                    message: errorUtil.toString(message)
                }
            });
        }
        max(maxLength, message) {
            return new ZodArray({
                ...this._def,
                maxLength: {
                    value: maxLength,
                    message: errorUtil.toString(message)
                }
            });
        }
        length(len, message) {
            return new ZodArray({
                ...this._def,
                exactLength: {
                    value: len,
                    message: errorUtil.toString(message)
                }
            });
        }
        nonempty(message) {
            return this.min(1, message);
        }
    }
    ZodArray.create = (schema, params)=>{
        return new ZodArray({
            type: schema,
            minLength: null,
            maxLength: null,
            exactLength: null,
            typeName: ZodFirstPartyTypeKind.ZodArray,
            ...processCreateParams(params)
        });
    };
    function deepPartialify(schema) {
        if (schema instanceof ZodObject) {
            const newShape = {};
            for(const key in schema.shape){
                const fieldSchema = schema.shape[key];
                newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
            }
            return new ZodObject({
                ...schema._def,
                shape: ()=>newShape
            });
        } else if (schema instanceof ZodArray) {
            return new ZodArray({
                ...schema._def,
                type: deepPartialify(schema.element)
            });
        } else if (schema instanceof ZodOptional) {
            return ZodOptional.create(deepPartialify(schema.unwrap()));
        } else if (schema instanceof ZodNullable) {
            return ZodNullable.create(deepPartialify(schema.unwrap()));
        } else if (schema instanceof ZodTuple) {
            return ZodTuple.create(schema.items.map((item)=>deepPartialify(item)));
        } else {
            return schema;
        }
    }
    class ZodObject extends ZodType {
        constructor(){
            super(...arguments);
            this._cached = null;
            this.nonstrict = this.passthrough;
            this.augment = this.extend;
        }
        _getCached() {
            if (this._cached !== null) return this._cached;
            const shape = this._def.shape();
            const keys = util.objectKeys(shape);
            return this._cached = {
                shape,
                keys
            };
        }
        _parse(input) {
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.object) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.object,
                    received: ctx.parsedType
                });
                return INVALID;
            }
            const { status, ctx } = this._processInputParams(input);
            const { shape, keys: shapeKeys } = this._getCached();
            const extraKeys = [];
            if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
                for(const key in ctx.data){
                    if (!shapeKeys.includes(key)) {
                        extraKeys.push(key);
                    }
                }
            }
            const pairs = [];
            for (const key of shapeKeys){
                const keyValidator = shape[key];
                const value = ctx.data[key];
                pairs.push({
                    key: {
                        status: "valid",
                        value: key
                    },
                    value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                    alwaysSet: key in ctx.data
                });
            }
            if (this._def.catchall instanceof ZodNever) {
                const unknownKeys = this._def.unknownKeys;
                if (unknownKeys === "passthrough") {
                    for (const key of extraKeys){
                        pairs.push({
                            key: {
                                status: "valid",
                                value: key
                            },
                            value: {
                                status: "valid",
                                value: ctx.data[key]
                            }
                        });
                    }
                } else if (unknownKeys === "strict") {
                    if (extraKeys.length > 0) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.unrecognized_keys,
                            keys: extraKeys
                        });
                        status.dirty();
                    }
                } else if (unknownKeys === "strip") ;
                else {
                    throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
                }
            } else {
                const catchall = this._def.catchall;
                for (const key of extraKeys){
                    const value = ctx.data[key];
                    pairs.push({
                        key: {
                            status: "valid",
                            value: key
                        },
                        value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                        alwaysSet: key in ctx.data
                    });
                }
            }
            if (ctx.common.async) {
                return Promise.resolve().then(async ()=>{
                    const syncPairs = [];
                    for (const pair of pairs){
                        const key = await pair.key;
                        const value = await pair.value;
                        syncPairs.push({
                            key,
                            value,
                            alwaysSet: pair.alwaysSet
                        });
                    }
                    return syncPairs;
                }).then((syncPairs)=>{
                    return ParseStatus.mergeObjectSync(status, syncPairs);
                });
            } else {
                return ParseStatus.mergeObjectSync(status, pairs);
            }
        }
        get shape() {
            return this._def.shape();
        }
        strict(message) {
            errorUtil.errToObj;
            return new ZodObject({
                ...this._def,
                unknownKeys: "strict",
                ...message !== undefined ? {
                    errorMap: (issue, ctx)=>{
                        var _a, _b, _c, _d;
                        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
                        if (issue.code === "unrecognized_keys") return {
                            message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
                        };
                        return {
                            message: defaultError
                        };
                    }
                } : {}
            });
        }
        strip() {
            return new ZodObject({
                ...this._def,
                unknownKeys: "strip"
            });
        }
        passthrough() {
            return new ZodObject({
                ...this._def,
                unknownKeys: "passthrough"
            });
        }
        extend(augmentation) {
            return new ZodObject({
                ...this._def,
                shape: ()=>({
                        ...this._def.shape(),
                        ...augmentation
                    })
            });
        }
        merge(merging) {
            const merged = new ZodObject({
                unknownKeys: merging._def.unknownKeys,
                catchall: merging._def.catchall,
                shape: ()=>({
                        ...this._def.shape(),
                        ...merging._def.shape()
                    }),
                typeName: ZodFirstPartyTypeKind.ZodObject
            });
            return merged;
        }
        setKey(key, schema) {
            return this.augment({
                [key]: schema
            });
        }
        catchall(index) {
            return new ZodObject({
                ...this._def,
                catchall: index
            });
        }
        pick(mask) {
            const shape = {};
            util.objectKeys(mask).forEach((key)=>{
                if (mask[key] && this.shape[key]) {
                    shape[key] = this.shape[key];
                }
            });
            return new ZodObject({
                ...this._def,
                shape: ()=>shape
            });
        }
        omit(mask) {
            const shape = {};
            util.objectKeys(this.shape).forEach((key)=>{
                if (!mask[key]) {
                    shape[key] = this.shape[key];
                }
            });
            return new ZodObject({
                ...this._def,
                shape: ()=>shape
            });
        }
        deepPartial() {
            return deepPartialify(this);
        }
        partial(mask) {
            const newShape = {};
            util.objectKeys(this.shape).forEach((key)=>{
                const fieldSchema = this.shape[key];
                if (mask && !mask[key]) {
                    newShape[key] = fieldSchema;
                } else {
                    newShape[key] = fieldSchema.optional();
                }
            });
            return new ZodObject({
                ...this._def,
                shape: ()=>newShape
            });
        }
        required(mask) {
            const newShape = {};
            util.objectKeys(this.shape).forEach((key)=>{
                if (mask && !mask[key]) {
                    newShape[key] = this.shape[key];
                } else {
                    const fieldSchema = this.shape[key];
                    let newField = fieldSchema;
                    while(newField instanceof ZodOptional){
                        newField = newField._def.innerType;
                    }
                    newShape[key] = newField;
                }
            });
            return new ZodObject({
                ...this._def,
                shape: ()=>newShape
            });
        }
        keyof() {
            return createZodEnum(util.objectKeys(this.shape));
        }
    }
    ZodObject.create = (shape, params)=>{
        return new ZodObject({
            shape: ()=>shape,
            unknownKeys: "strip",
            catchall: ZodNever.create(),
            typeName: ZodFirstPartyTypeKind.ZodObject,
            ...processCreateParams(params)
        });
    };
    ZodObject.strictCreate = (shape, params)=>{
        return new ZodObject({
            shape: ()=>shape,
            unknownKeys: "strict",
            catchall: ZodNever.create(),
            typeName: ZodFirstPartyTypeKind.ZodObject,
            ...processCreateParams(params)
        });
    };
    ZodObject.lazycreate = (shape, params)=>{
        return new ZodObject({
            shape,
            unknownKeys: "strip",
            catchall: ZodNever.create(),
            typeName: ZodFirstPartyTypeKind.ZodObject,
            ...processCreateParams(params)
        });
    };
    class ZodUnion extends ZodType {
        _parse(input) {
            const { ctx } = this._processInputParams(input);
            const options = this._def.options;
            function handleResults(results) {
                for (const result of results){
                    if (result.result.status === "valid") {
                        return result.result;
                    }
                }
                for (const result of results){
                    if (result.result.status === "dirty") {
                        ctx.common.issues.push(...result.ctx.common.issues);
                        return result.result;
                    }
                }
                const unionErrors = results.map((result)=>new ZodError(result.ctx.common.issues));
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_union,
                    unionErrors
                });
                return INVALID;
            }
            if (ctx.common.async) {
                return Promise.all(options.map(async (option)=>{
                    const childCtx = {
                        ...ctx,
                        common: {
                            ...ctx.common,
                            issues: []
                        },
                        parent: null
                    };
                    return {
                        result: await option._parseAsync({
                            data: ctx.data,
                            path: ctx.path,
                            parent: childCtx
                        }),
                        ctx: childCtx
                    };
                })).then(handleResults);
            } else {
                let dirty = undefined;
                const issues = [];
                for (const option of options){
                    const childCtx = {
                        ...ctx,
                        common: {
                            ...ctx.common,
                            issues: []
                        },
                        parent: null
                    };
                    const result = option._parseSync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: childCtx
                    });
                    if (result.status === "valid") {
                        return result;
                    } else if (result.status === "dirty" && !dirty) {
                        dirty = {
                            result,
                            ctx: childCtx
                        };
                    }
                    if (childCtx.common.issues.length) {
                        issues.push(childCtx.common.issues);
                    }
                }
                if (dirty) {
                    ctx.common.issues.push(...dirty.ctx.common.issues);
                    return dirty.result;
                }
                const unionErrors = issues.map((issues)=>new ZodError(issues));
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_union,
                    unionErrors
                });
                return INVALID;
            }
        }
        get options() {
            return this._def.options;
        }
    }
    ZodUnion.create = (types, params)=>{
        return new ZodUnion({
            options: types,
            typeName: ZodFirstPartyTypeKind.ZodUnion,
            ...processCreateParams(params)
        });
    };
    const getDiscriminator = (type)=>{
        if (type instanceof ZodLazy) {
            return getDiscriminator(type.schema);
        } else if (type instanceof ZodEffects) {
            return getDiscriminator(type.innerType());
        } else if (type instanceof ZodLiteral) {
            return [
                type.value
            ];
        } else if (type instanceof ZodEnum) {
            return type.options;
        } else if (type instanceof ZodNativeEnum) {
            return util.objectValues(type.enum);
        } else if (type instanceof ZodDefault) {
            return getDiscriminator(type._def.innerType);
        } else if (type instanceof ZodUndefined) {
            return [
                undefined
            ];
        } else if (type instanceof ZodNull) {
            return [
                null
            ];
        } else if (type instanceof ZodOptional) {
            return [
                undefined,
                ...getDiscriminator(type.unwrap())
            ];
        } else if (type instanceof ZodNullable) {
            return [
                null,
                ...getDiscriminator(type.unwrap())
            ];
        } else if (type instanceof ZodBranded) {
            return getDiscriminator(type.unwrap());
        } else if (type instanceof ZodReadonly) {
            return getDiscriminator(type.unwrap());
        } else if (type instanceof ZodCatch) {
            return getDiscriminator(type._def.innerType);
        } else {
            return [];
        }
    };
    class ZodDiscriminatedUnion extends ZodType {
        _parse(input) {
            const { ctx } = this._processInputParams(input);
            if (ctx.parsedType !== ZodParsedType.object) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.object,
                    received: ctx.parsedType
                });
                return INVALID;
            }
            const discriminator = this.discriminator;
            const discriminatorValue = ctx.data[discriminator];
            const option = this.optionsMap.get(discriminatorValue);
            if (!option) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_union_discriminator,
                    options: Array.from(this.optionsMap.keys()),
                    path: [
                        discriminator
                    ]
                });
                return INVALID;
            }
            if (ctx.common.async) {
                return option._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                });
            } else {
                return option._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                });
            }
        }
        get discriminator() {
            return this._def.discriminator;
        }
        get options() {
            return this._def.options;
        }
        get optionsMap() {
            return this._def.optionsMap;
        }
        static create(discriminator, options, params) {
            const optionsMap = new Map();
            for (const type of options){
                const discriminatorValues = getDiscriminator(type.shape[discriminator]);
                if (!discriminatorValues.length) {
                    throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
                }
                for (const value of discriminatorValues){
                    if (optionsMap.has(value)) {
                        throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                    }
                    optionsMap.set(value, type);
                }
            }
            return new ZodDiscriminatedUnion({
                typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
                discriminator,
                options,
                optionsMap,
                ...processCreateParams(params)
            });
        }
    }
    function mergeValues(a, b) {
        const aType = getParsedType(a);
        const bType = getParsedType(b);
        if (a === b) {
            return {
                valid: true,
                data: a
            };
        } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
            const bKeys = util.objectKeys(b);
            const sharedKeys = util.objectKeys(a).filter((key)=>bKeys.indexOf(key) !== -1);
            const newObj = {
                ...a,
                ...b
            };
            for (const key of sharedKeys){
                const sharedValue = mergeValues(a[key], b[key]);
                if (!sharedValue.valid) {
                    return {
                        valid: false
                    };
                }
                newObj[key] = sharedValue.data;
            }
            return {
                valid: true,
                data: newObj
            };
        } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
            if (a.length !== b.length) {
                return {
                    valid: false
                };
            }
            const newArray = [];
            for(let index = 0; index < a.length; index++){
                const itemA = a[index];
                const itemB = b[index];
                const sharedValue = mergeValues(itemA, itemB);
                if (!sharedValue.valid) {
                    return {
                        valid: false
                    };
                }
                newArray.push(sharedValue.data);
            }
            return {
                valid: true,
                data: newArray
            };
        } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
            return {
                valid: true,
                data: a
            };
        } else {
            return {
                valid: false
            };
        }
    }
    class ZodIntersection extends ZodType {
        _parse(input) {
            const { status, ctx } = this._processInputParams(input);
            const handleParsed = (parsedLeft, parsedRight)=>{
                if (isAborted(parsedLeft) || isAborted(parsedRight)) {
                    return INVALID;
                }
                const merged = mergeValues(parsedLeft.value, parsedRight.value);
                if (!merged.valid) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_intersection_types
                    });
                    return INVALID;
                }
                if (isDirty(parsedLeft) || isDirty(parsedRight)) {
                    status.dirty();
                }
                return {
                    status: status.value,
                    value: merged.data
                };
            };
            if (ctx.common.async) {
                return Promise.all([
                    this._def.left._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: ctx
                    }),
                    this._def.right._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: ctx
                    })
                ]).then(([left, right])=>handleParsed(left, right));
            } else {
                return handleParsed(this._def.left._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                }), this._def.right._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                }));
            }
        }
    }
    ZodIntersection.create = (left, right, params)=>{
        return new ZodIntersection({
            left: left,
            right: right,
            typeName: ZodFirstPartyTypeKind.ZodIntersection,
            ...processCreateParams(params)
        });
    };
    class ZodTuple extends ZodType {
        _parse(input) {
            const { status, ctx } = this._processInputParams(input);
            if (ctx.parsedType !== ZodParsedType.array) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.array,
                    received: ctx.parsedType
                });
                return INVALID;
            }
            if (ctx.data.length < this._def.items.length) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: this._def.items.length,
                    inclusive: true,
                    exact: false,
                    type: "array"
                });
                return INVALID;
            }
            const rest = this._def.rest;
            if (!rest && ctx.data.length > this._def.items.length) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: this._def.items.length,
                    inclusive: true,
                    exact: false,
                    type: "array"
                });
                status.dirty();
            }
            const items = [
                ...ctx.data
            ].map((item, itemIndex)=>{
                const schema = this._def.items[itemIndex] || this._def.rest;
                if (!schema) return null;
                return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
            }).filter((x)=>!!x);
            if (ctx.common.async) {
                return Promise.all(items).then((results)=>{
                    return ParseStatus.mergeArray(status, results);
                });
            } else {
                return ParseStatus.mergeArray(status, items);
            }
        }
        get items() {
            return this._def.items;
        }
        rest(rest) {
            return new ZodTuple({
                ...this._def,
                rest
            });
        }
    }
    ZodTuple.create = (schemas, params)=>{
        if (!Array.isArray(schemas)) {
            throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
        }
        return new ZodTuple({
            items: schemas,
            typeName: ZodFirstPartyTypeKind.ZodTuple,
            rest: null,
            ...processCreateParams(params)
        });
    };
    class ZodRecord extends ZodType {
        get keySchema() {
            return this._def.keyType;
        }
        get valueSchema() {
            return this._def.valueType;
        }
        _parse(input) {
            const { status, ctx } = this._processInputParams(input);
            if (ctx.parsedType !== ZodParsedType.object) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.object,
                    received: ctx.parsedType
                });
                return INVALID;
            }
            const pairs = [];
            const keyType = this._def.keyType;
            const valueType = this._def.valueType;
            for(const key in ctx.data){
                pairs.push({
                    key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
                    value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
                    alwaysSet: key in ctx.data
                });
            }
            if (ctx.common.async) {
                return ParseStatus.mergeObjectAsync(status, pairs);
            } else {
                return ParseStatus.mergeObjectSync(status, pairs);
            }
        }
        get element() {
            return this._def.valueType;
        }
        static create(first, second, third) {
            if (second instanceof ZodType) {
                return new ZodRecord({
                    keyType: first,
                    valueType: second,
                    typeName: ZodFirstPartyTypeKind.ZodRecord,
                    ...processCreateParams(third)
                });
            }
            return new ZodRecord({
                keyType: ZodString.create(),
                valueType: first,
                typeName: ZodFirstPartyTypeKind.ZodRecord,
                ...processCreateParams(second)
            });
        }
    }
    class ZodMap extends ZodType {
        get keySchema() {
            return this._def.keyType;
        }
        get valueSchema() {
            return this._def.valueType;
        }
        _parse(input) {
            const { status, ctx } = this._processInputParams(input);
            if (ctx.parsedType !== ZodParsedType.map) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.map,
                    received: ctx.parsedType
                });
                return INVALID;
            }
            const keyType = this._def.keyType;
            const valueType = this._def.valueType;
            const pairs = [
                ...ctx.data.entries()
            ].map(([key, value], index)=>{
                return {
                    key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [
                        index,
                        "key"
                    ])),
                    value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [
                        index,
                        "value"
                    ]))
                };
            });
            if (ctx.common.async) {
                const finalMap = new Map();
                return Promise.resolve().then(async ()=>{
                    for (const pair of pairs){
                        const key = await pair.key;
                        const value = await pair.value;
                        if (key.status === "aborted" || value.status === "aborted") {
                            return INVALID;
                        }
                        if (key.status === "dirty" || value.status === "dirty") {
                            status.dirty();
                        }
                        finalMap.set(key.value, value.value);
                    }
                    return {
                        status: status.value,
                        value: finalMap
                    };
                });
            } else {
                const finalMap = new Map();
                for (const pair of pairs){
                    const key = pair.key;
                    const value = pair.value;
                    if (key.status === "aborted" || value.status === "aborted") {
                        return INVALID;
                    }
                    if (key.status === "dirty" || value.status === "dirty") {
                        status.dirty();
                    }
                    finalMap.set(key.value, value.value);
                }
                return {
                    status: status.value,
                    value: finalMap
                };
            }
        }
    }
    ZodMap.create = (keyType, valueType, params)=>{
        return new ZodMap({
            valueType,
            keyType,
            typeName: ZodFirstPartyTypeKind.ZodMap,
            ...processCreateParams(params)
        });
    };
    class ZodSet extends ZodType {
        _parse(input) {
            const { status, ctx } = this._processInputParams(input);
            if (ctx.parsedType !== ZodParsedType.set) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.set,
                    received: ctx.parsedType
                });
                return INVALID;
            }
            const def = this._def;
            if (def.minSize !== null) {
                if (ctx.data.size < def.minSize.value) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: def.minSize.value,
                        type: "set",
                        inclusive: true,
                        exact: false,
                        message: def.minSize.message
                    });
                    status.dirty();
                }
            }
            if (def.maxSize !== null) {
                if (ctx.data.size > def.maxSize.value) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: def.maxSize.value,
                        type: "set",
                        inclusive: true,
                        exact: false,
                        message: def.maxSize.message
                    });
                    status.dirty();
                }
            }
            const valueType = this._def.valueType;
            function finalizeSet(elements) {
                const parsedSet = new Set();
                for (const element of elements){
                    if (element.status === "aborted") return INVALID;
                    if (element.status === "dirty") status.dirty();
                    parsedSet.add(element.value);
                }
                return {
                    status: status.value,
                    value: parsedSet
                };
            }
            const elements = [
                ...ctx.data.values()
            ].map((item, i)=>valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
            if (ctx.common.async) {
                return Promise.all(elements).then((elements)=>finalizeSet(elements));
            } else {
                return finalizeSet(elements);
            }
        }
        min(minSize, message) {
            return new ZodSet({
                ...this._def,
                minSize: {
                    value: minSize,
                    message: errorUtil.toString(message)
                }
            });
        }
        max(maxSize, message) {
            return new ZodSet({
                ...this._def,
                maxSize: {
                    value: maxSize,
                    message: errorUtil.toString(message)
                }
            });
        }
        size(size, message) {
            return this.min(size, message).max(size, message);
        }
        nonempty(message) {
            return this.min(1, message);
        }
    }
    ZodSet.create = (valueType, params)=>{
        return new ZodSet({
            valueType,
            minSize: null,
            maxSize: null,
            typeName: ZodFirstPartyTypeKind.ZodSet,
            ...processCreateParams(params)
        });
    };
    class ZodFunction extends ZodType {
        constructor(){
            super(...arguments);
            this.validate = this.implement;
        }
        _parse(input) {
            const { ctx } = this._processInputParams(input);
            if (ctx.parsedType !== ZodParsedType.function) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.function,
                    received: ctx.parsedType
                });
                return INVALID;
            }
            function makeArgsIssue(args, error) {
                return makeIssue({
                    data: args,
                    path: ctx.path,
                    errorMaps: [
                        ctx.common.contextualErrorMap,
                        ctx.schemaErrorMap,
                        getErrorMap(),
                        errorMap
                    ].filter((x)=>!!x),
                    issueData: {
                        code: ZodIssueCode.invalid_arguments,
                        argumentsError: error
                    }
                });
            }
            function makeReturnsIssue(returns, error) {
                return makeIssue({
                    data: returns,
                    path: ctx.path,
                    errorMaps: [
                        ctx.common.contextualErrorMap,
                        ctx.schemaErrorMap,
                        getErrorMap(),
                        errorMap
                    ].filter((x)=>!!x),
                    issueData: {
                        code: ZodIssueCode.invalid_return_type,
                        returnTypeError: error
                    }
                });
            }
            const params = {
                errorMap: ctx.common.contextualErrorMap
            };
            const fn = ctx.data;
            if (this._def.returns instanceof ZodPromise) {
                const me = this;
                return OK(async function(...args) {
                    const error = new ZodError([]);
                    const parsedArgs = await me._def.args.parseAsync(args, params).catch((e)=>{
                        error.addIssue(makeArgsIssue(args, e));
                        throw error;
                    });
                    const result = await Reflect.apply(fn, this, parsedArgs);
                    const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e)=>{
                        error.addIssue(makeReturnsIssue(result, e));
                        throw error;
                    });
                    return parsedReturns;
                });
            } else {
                const me = this;
                return OK(function(...args) {
                    const parsedArgs = me._def.args.safeParse(args, params);
                    if (!parsedArgs.success) {
                        throw new ZodError([
                            makeArgsIssue(args, parsedArgs.error)
                        ]);
                    }
                    const result = Reflect.apply(fn, this, parsedArgs.data);
                    const parsedReturns = me._def.returns.safeParse(result, params);
                    if (!parsedReturns.success) {
                        throw new ZodError([
                            makeReturnsIssue(result, parsedReturns.error)
                        ]);
                    }
                    return parsedReturns.data;
                });
            }
        }
        parameters() {
            return this._def.args;
        }
        returnType() {
            return this._def.returns;
        }
        args(...items) {
            return new ZodFunction({
                ...this._def,
                args: ZodTuple.create(items).rest(ZodUnknown.create())
            });
        }
        returns(returnType) {
            return new ZodFunction({
                ...this._def,
                returns: returnType
            });
        }
        implement(func) {
            const validatedFunc = this.parse(func);
            return validatedFunc;
        }
        strictImplement(func) {
            const validatedFunc = this.parse(func);
            return validatedFunc;
        }
        static create(args, returns, params) {
            return new ZodFunction({
                args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
                returns: returns || ZodUnknown.create(),
                typeName: ZodFirstPartyTypeKind.ZodFunction,
                ...processCreateParams(params)
            });
        }
    }
    class ZodLazy extends ZodType {
        get schema() {
            return this._def.getter();
        }
        _parse(input) {
            const { ctx } = this._processInputParams(input);
            const lazySchema = this._def.getter();
            return lazySchema._parse({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            });
        }
    }
    ZodLazy.create = (getter, params)=>{
        return new ZodLazy({
            getter: getter,
            typeName: ZodFirstPartyTypeKind.ZodLazy,
            ...processCreateParams(params)
        });
    };
    class ZodLiteral extends ZodType {
        _parse(input) {
            if (input.data !== this._def.value) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    received: ctx.data,
                    code: ZodIssueCode.invalid_literal,
                    expected: this._def.value
                });
                return INVALID;
            }
            return {
                status: "valid",
                value: input.data
            };
        }
        get value() {
            return this._def.value;
        }
    }
    ZodLiteral.create = (value, params)=>{
        return new ZodLiteral({
            value: value,
            typeName: ZodFirstPartyTypeKind.ZodLiteral,
            ...processCreateParams(params)
        });
    };
    function createZodEnum(values, params) {
        return new ZodEnum({
            values,
            typeName: ZodFirstPartyTypeKind.ZodEnum,
            ...processCreateParams(params)
        });
    }
    class ZodEnum extends ZodType {
        constructor(){
            super(...arguments);
            _ZodEnum_cache.set(this, void 0);
        }
        _parse(input) {
            if (typeof input.data !== "string") {
                const ctx = this._getOrReturnCtx(input);
                const expectedValues = this._def.values;
                addIssueToContext(ctx, {
                    expected: util.joinValues(expectedValues),
                    received: ctx.parsedType,
                    code: ZodIssueCode.invalid_type
                });
                return INVALID;
            }
            if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
                __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
            }
            if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
                const ctx = this._getOrReturnCtx(input);
                const expectedValues = this._def.values;
                addIssueToContext(ctx, {
                    received: ctx.data,
                    code: ZodIssueCode.invalid_enum_value,
                    options: expectedValues
                });
                return INVALID;
            }
            return OK(input.data);
        }
        get options() {
            return this._def.values;
        }
        get enum() {
            const enumValues = {};
            for (const val of this._def.values){
                enumValues[val] = val;
            }
            return enumValues;
        }
        get Values() {
            const enumValues = {};
            for (const val of this._def.values){
                enumValues[val] = val;
            }
            return enumValues;
        }
        get Enum() {
            const enumValues = {};
            for (const val of this._def.values){
                enumValues[val] = val;
            }
            return enumValues;
        }
        extract(values, newDef = this._def) {
            return ZodEnum.create(values, {
                ...this._def,
                ...newDef
            });
        }
        exclude(values, newDef = this._def) {
            return ZodEnum.create(this.options.filter((opt)=>!values.includes(opt)), {
                ...this._def,
                ...newDef
            });
        }
    }
    _ZodEnum_cache = new WeakMap();
    ZodEnum.create = createZodEnum;
    class ZodNativeEnum extends ZodType {
        constructor(){
            super(...arguments);
            _ZodNativeEnum_cache.set(this, void 0);
        }
        _parse(input) {
            const nativeEnumValues = util.getValidEnumValues(this._def.values);
            const ctx = this._getOrReturnCtx(input);
            if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
                const expectedValues = util.objectValues(nativeEnumValues);
                addIssueToContext(ctx, {
                    expected: util.joinValues(expectedValues),
                    received: ctx.parsedType,
                    code: ZodIssueCode.invalid_type
                });
                return INVALID;
            }
            if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
                __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f");
            }
            if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
                const expectedValues = util.objectValues(nativeEnumValues);
                addIssueToContext(ctx, {
                    received: ctx.data,
                    code: ZodIssueCode.invalid_enum_value,
                    options: expectedValues
                });
                return INVALID;
            }
            return OK(input.data);
        }
        get enum() {
            return this._def.values;
        }
    }
    _ZodNativeEnum_cache = new WeakMap();
    ZodNativeEnum.create = (values, params)=>{
        return new ZodNativeEnum({
            values: values,
            typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
            ...processCreateParams(params)
        });
    };
    class ZodPromise extends ZodType {
        unwrap() {
            return this._def.type;
        }
        _parse(input) {
            const { ctx } = this._processInputParams(input);
            if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.promise,
                    received: ctx.parsedType
                });
                return INVALID;
            }
            const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
            return OK(promisified.then((data)=>{
                return this._def.type.parseAsync(data, {
                    path: ctx.path,
                    errorMap: ctx.common.contextualErrorMap
                });
            }));
        }
    }
    ZodPromise.create = (schema, params)=>{
        return new ZodPromise({
            type: schema,
            typeName: ZodFirstPartyTypeKind.ZodPromise,
            ...processCreateParams(params)
        });
    };
    class ZodEffects extends ZodType {
        innerType() {
            return this._def.schema;
        }
        sourceType() {
            return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
        }
        _parse(input) {
            const { status, ctx } = this._processInputParams(input);
            const effect = this._def.effect || null;
            const checkCtx = {
                addIssue: (arg)=>{
                    addIssueToContext(ctx, arg);
                    if (arg.fatal) {
                        status.abort();
                    } else {
                        status.dirty();
                    }
                },
                get path () {
                    return ctx.path;
                }
            };
            checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
            if (effect.type === "preprocess") {
                const processed = effect.transform(ctx.data, checkCtx);
                if (ctx.common.async) {
                    return Promise.resolve(processed).then(async (processed)=>{
                        if (status.value === "aborted") return INVALID;
                        const result = await this._def.schema._parseAsync({
                            data: processed,
                            path: ctx.path,
                            parent: ctx
                        });
                        if (result.status === "aborted") return INVALID;
                        if (result.status === "dirty") return DIRTY(result.value);
                        if (status.value === "dirty") return DIRTY(result.value);
                        return result;
                    });
                } else {
                    if (status.value === "aborted") return INVALID;
                    const result = this._def.schema._parseSync({
                        data: processed,
                        path: ctx.path,
                        parent: ctx
                    });
                    if (result.status === "aborted") return INVALID;
                    if (result.status === "dirty") return DIRTY(result.value);
                    if (status.value === "dirty") return DIRTY(result.value);
                    return result;
                }
            }
            if (effect.type === "refinement") {
                const executeRefinement = (acc)=>{
                    const result = effect.refinement(acc, checkCtx);
                    if (ctx.common.async) {
                        return Promise.resolve(result);
                    }
                    if (result instanceof Promise) {
                        throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                    }
                    return acc;
                };
                if (ctx.common.async === false) {
                    const inner = this._def.schema._parseSync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: ctx
                    });
                    if (inner.status === "aborted") return INVALID;
                    if (inner.status === "dirty") status.dirty();
                    executeRefinement(inner.value);
                    return {
                        status: status.value,
                        value: inner.value
                    };
                } else {
                    return this._def.schema._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: ctx
                    }).then((inner)=>{
                        if (inner.status === "aborted") return INVALID;
                        if (inner.status === "dirty") status.dirty();
                        return executeRefinement(inner.value).then(()=>{
                            return {
                                status: status.value,
                                value: inner.value
                            };
                        });
                    });
                }
            }
            if (effect.type === "transform") {
                if (ctx.common.async === false) {
                    const base = this._def.schema._parseSync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: ctx
                    });
                    if (!isValid(base)) return base;
                    const result = effect.transform(base.value, checkCtx);
                    if (result instanceof Promise) {
                        throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
                    }
                    return {
                        status: status.value,
                        value: result
                    };
                } else {
                    return this._def.schema._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: ctx
                    }).then((base)=>{
                        if (!isValid(base)) return base;
                        return Promise.resolve(effect.transform(base.value, checkCtx)).then((result)=>({
                                status: status.value,
                                value: result
                            }));
                    });
                }
            }
            util.assertNever(effect);
        }
    }
    ZodEffects.create = (schema, effect, params)=>{
        return new ZodEffects({
            schema,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect,
            ...processCreateParams(params)
        });
    };
    ZodEffects.createWithPreprocess = (preprocess, schema, params)=>{
        return new ZodEffects({
            schema,
            effect: {
                type: "preprocess",
                transform: preprocess
            },
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            ...processCreateParams(params)
        });
    };
    class ZodOptional extends ZodType {
        _parse(input) {
            const parsedType = this._getType(input);
            if (parsedType === ZodParsedType.undefined) {
                return OK(undefined);
            }
            return this._def.innerType._parse(input);
        }
        unwrap() {
            return this._def.innerType;
        }
    }
    ZodOptional.create = (type, params)=>{
        return new ZodOptional({
            innerType: type,
            typeName: ZodFirstPartyTypeKind.ZodOptional,
            ...processCreateParams(params)
        });
    };
    class ZodNullable extends ZodType {
        _parse(input) {
            const parsedType = this._getType(input);
            if (parsedType === ZodParsedType.null) {
                return OK(null);
            }
            return this._def.innerType._parse(input);
        }
        unwrap() {
            return this._def.innerType;
        }
    }
    ZodNullable.create = (type, params)=>{
        return new ZodNullable({
            innerType: type,
            typeName: ZodFirstPartyTypeKind.ZodNullable,
            ...processCreateParams(params)
        });
    };
    class ZodDefault extends ZodType {
        _parse(input) {
            const { ctx } = this._processInputParams(input);
            let data = ctx.data;
            if (ctx.parsedType === ZodParsedType.undefined) {
                data = this._def.defaultValue();
            }
            return this._def.innerType._parse({
                data,
                path: ctx.path,
                parent: ctx
            });
        }
        removeDefault() {
            return this._def.innerType;
        }
    }
    ZodDefault.create = (type, params)=>{
        return new ZodDefault({
            innerType: type,
            typeName: ZodFirstPartyTypeKind.ZodDefault,
            defaultValue: typeof params.default === "function" ? params.default : ()=>params.default,
            ...processCreateParams(params)
        });
    };
    class ZodCatch extends ZodType {
        _parse(input) {
            const { ctx } = this._processInputParams(input);
            const newCtx = {
                ...ctx,
                common: {
                    ...ctx.common,
                    issues: []
                }
            };
            const result = this._def.innerType._parse({
                data: newCtx.data,
                path: newCtx.path,
                parent: {
                    ...newCtx
                }
            });
            if (isAsync(result)) {
                return result.then((result)=>{
                    return {
                        status: "valid",
                        value: result.status === "valid" ? result.value : this._def.catchValue({
                            get error () {
                                return new ZodError(newCtx.common.issues);
                            },
                            input: newCtx.data
                        })
                    };
                });
            } else {
                return {
                    status: "valid",
                    value: result.status === "valid" ? result.value : this._def.catchValue({
                        get error () {
                            return new ZodError(newCtx.common.issues);
                        },
                        input: newCtx.data
                    })
                };
            }
        }
        removeCatch() {
            return this._def.innerType;
        }
    }
    ZodCatch.create = (type, params)=>{
        return new ZodCatch({
            innerType: type,
            typeName: ZodFirstPartyTypeKind.ZodCatch,
            catchValue: typeof params.catch === "function" ? params.catch : ()=>params.catch,
            ...processCreateParams(params)
        });
    };
    class ZodNaN extends ZodType {
        _parse(input) {
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.nan) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.nan,
                    received: ctx.parsedType
                });
                return INVALID;
            }
            return {
                status: "valid",
                value: input.data
            };
        }
    }
    ZodNaN.create = (params)=>{
        return new ZodNaN({
            typeName: ZodFirstPartyTypeKind.ZodNaN,
            ...processCreateParams(params)
        });
    };
    const BRAND = Symbol("zod_brand");
    class ZodBranded extends ZodType {
        _parse(input) {
            const { ctx } = this._processInputParams(input);
            const data = ctx.data;
            return this._def.type._parse({
                data,
                path: ctx.path,
                parent: ctx
            });
        }
        unwrap() {
            return this._def.type;
        }
    }
    class ZodPipeline extends ZodType {
        _parse(input) {
            const { status, ctx } = this._processInputParams(input);
            if (ctx.common.async) {
                const handleAsync = async ()=>{
                    const inResult = await this._def.in._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: ctx
                    });
                    if (inResult.status === "aborted") return INVALID;
                    if (inResult.status === "dirty") {
                        status.dirty();
                        return DIRTY(inResult.value);
                    } else {
                        return this._def.out._parseAsync({
                            data: inResult.value,
                            path: ctx.path,
                            parent: ctx
                        });
                    }
                };
                return handleAsync();
            } else {
                const inResult = this._def.in._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                });
                if (inResult.status === "aborted") return INVALID;
                if (inResult.status === "dirty") {
                    status.dirty();
                    return {
                        status: "dirty",
                        value: inResult.value
                    };
                } else {
                    return this._def.out._parseSync({
                        data: inResult.value,
                        path: ctx.path,
                        parent: ctx
                    });
                }
            }
        }
        static create(a, b) {
            return new ZodPipeline({
                in: a,
                out: b,
                typeName: ZodFirstPartyTypeKind.ZodPipeline
            });
        }
    }
    class ZodReadonly extends ZodType {
        _parse(input) {
            const result = this._def.innerType._parse(input);
            const freeze = (data)=>{
                if (isValid(data)) {
                    data.value = Object.freeze(data.value);
                }
                return data;
            };
            return isAsync(result) ? result.then((data)=>freeze(data)) : freeze(result);
        }
        unwrap() {
            return this._def.innerType;
        }
    }
    ZodReadonly.create = (type, params)=>{
        return new ZodReadonly({
            innerType: type,
            typeName: ZodFirstPartyTypeKind.ZodReadonly,
            ...processCreateParams(params)
        });
    };
    function custom(check, params = {}, fatal) {
        if (check) return ZodAny.create().superRefine((data, ctx)=>{
            var _a, _b;
            if (!check(data)) {
                const p = typeof params === "function" ? params(data) : typeof params === "string" ? {
                    message: params
                } : params;
                const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
                const p2 = typeof p === "string" ? {
                    message: p
                } : p;
                ctx.addIssue({
                    code: "custom",
                    ...p2,
                    fatal: _fatal
                });
            }
        });
        return ZodAny.create();
    }
    const late = {
        object: ZodObject.lazycreate
    };
    var ZodFirstPartyTypeKind;
    (function(ZodFirstPartyTypeKind) {
        ZodFirstPartyTypeKind["ZodString"] = "ZodString";
        ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
        ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
        ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
        ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
        ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
        ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
        ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
        ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
        ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
        ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
        ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
        ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
        ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
        ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
        ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
        ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
        ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
        ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
        ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
        ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
        ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
        ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
        ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
        ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
        ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
        ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
        ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
        ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
        ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
        ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
        ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
        ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
        ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
        ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
        ZodFirstPartyTypeKind["ZodReadonly"] = "ZodReadonly";
    })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
    const instanceOfType = (cls, params = {
        message: `Input not instance of ${cls.name}`
    })=>custom((data)=>data instanceof cls, params);
    const stringType = ZodString.create;
    const numberType = ZodNumber.create;
    const nanType = ZodNaN.create;
    const bigIntType = ZodBigInt.create;
    const booleanType = ZodBoolean.create;
    const dateType = ZodDate.create;
    const symbolType = ZodSymbol.create;
    const undefinedType = ZodUndefined.create;
    const nullType = ZodNull.create;
    const anyType = ZodAny.create;
    const unknownType = ZodUnknown.create;
    const neverType = ZodNever.create;
    const voidType = ZodVoid.create;
    const arrayType = ZodArray.create;
    const objectType = ZodObject.create;
    const strictObjectType = ZodObject.strictCreate;
    const unionType = ZodUnion.create;
    const discriminatedUnionType = ZodDiscriminatedUnion.create;
    const intersectionType = ZodIntersection.create;
    const tupleType = ZodTuple.create;
    const recordType = ZodRecord.create;
    const mapType = ZodMap.create;
    const setType = ZodSet.create;
    const functionType = ZodFunction.create;
    const lazyType = ZodLazy.create;
    const literalType = ZodLiteral.create;
    const enumType = ZodEnum.create;
    const nativeEnumType = ZodNativeEnum.create;
    const promiseType = ZodPromise.create;
    const effectsType = ZodEffects.create;
    const optionalType = ZodOptional.create;
    const nullableType = ZodNullable.create;
    const preprocessType = ZodEffects.createWithPreprocess;
    const pipelineType = ZodPipeline.create;
    const ostring = ()=>stringType().optional();
    const onumber = ()=>numberType().optional();
    const oboolean = ()=>booleanType().optional();
    const coerce = {
        string: (arg)=>ZodString.create({
                ...arg,
                coerce: true
            }),
        number: (arg)=>ZodNumber.create({
                ...arg,
                coerce: true
            }),
        boolean: (arg)=>ZodBoolean.create({
                ...arg,
                coerce: true
            }),
        bigint: (arg)=>ZodBigInt.create({
                ...arg,
                coerce: true
            }),
        date: (arg)=>ZodDate.create({
                ...arg,
                coerce: true
            })
    };
    const NEVER = INVALID;
    var z = Object.freeze({
        __proto__: null,
        defaultErrorMap: errorMap,
        setErrorMap: setErrorMap,
        getErrorMap: getErrorMap,
        makeIssue: makeIssue,
        EMPTY_PATH: EMPTY_PATH,
        addIssueToContext: addIssueToContext,
        ParseStatus: ParseStatus,
        INVALID: INVALID,
        DIRTY: DIRTY,
        OK: OK,
        isAborted: isAborted,
        isDirty: isDirty,
        isValid: isValid,
        isAsync: isAsync,
        get util () {
            return util;
        },
        get objectUtil () {
            return objectUtil;
        },
        ZodParsedType: ZodParsedType,
        getParsedType: getParsedType,
        ZodType: ZodType,
        datetimeRegex: datetimeRegex,
        ZodString: ZodString,
        ZodNumber: ZodNumber,
        ZodBigInt: ZodBigInt,
        ZodBoolean: ZodBoolean,
        ZodDate: ZodDate,
        ZodSymbol: ZodSymbol,
        ZodUndefined: ZodUndefined,
        ZodNull: ZodNull,
        ZodAny: ZodAny,
        ZodUnknown: ZodUnknown,
        ZodNever: ZodNever,
        ZodVoid: ZodVoid,
        ZodArray: ZodArray,
        ZodObject: ZodObject,
        ZodUnion: ZodUnion,
        ZodDiscriminatedUnion: ZodDiscriminatedUnion,
        ZodIntersection: ZodIntersection,
        ZodTuple: ZodTuple,
        ZodRecord: ZodRecord,
        ZodMap: ZodMap,
        ZodSet: ZodSet,
        ZodFunction: ZodFunction,
        ZodLazy: ZodLazy,
        ZodLiteral: ZodLiteral,
        ZodEnum: ZodEnum,
        ZodNativeEnum: ZodNativeEnum,
        ZodPromise: ZodPromise,
        ZodEffects: ZodEffects,
        ZodTransformer: ZodEffects,
        ZodOptional: ZodOptional,
        ZodNullable: ZodNullable,
        ZodDefault: ZodDefault,
        ZodCatch: ZodCatch,
        ZodNaN: ZodNaN,
        BRAND: BRAND,
        ZodBranded: ZodBranded,
        ZodPipeline: ZodPipeline,
        ZodReadonly: ZodReadonly,
        custom: custom,
        Schema: ZodType,
        ZodSchema: ZodType,
        late: late,
        get ZodFirstPartyTypeKind () {
            return ZodFirstPartyTypeKind;
        },
        coerce: coerce,
        any: anyType,
        array: arrayType,
        bigint: bigIntType,
        boolean: booleanType,
        date: dateType,
        discriminatedUnion: discriminatedUnionType,
        effect: effectsType,
        'enum': enumType,
        'function': functionType,
        'instanceof': instanceOfType,
        intersection: intersectionType,
        lazy: lazyType,
        literal: literalType,
        map: mapType,
        nan: nanType,
        nativeEnum: nativeEnumType,
        never: neverType,
        'null': nullType,
        nullable: nullableType,
        number: numberType,
        object: objectType,
        oboolean: oboolean,
        onumber: onumber,
        optional: optionalType,
        ostring: ostring,
        pipeline: pipelineType,
        preprocess: preprocessType,
        promise: promiseType,
        record: recordType,
        set: setType,
        strictObject: strictObjectType,
        string: stringType,
        symbol: symbolType,
        transformer: effectsType,
        tuple: tupleType,
        'undefined': undefinedType,
        union: unionType,
        unknown: unknownType,
        'void': voidType,
        NEVER: NEVER,
        ZodIssueCode: ZodIssueCode,
        quotelessJson: quotelessJson,
        ZodError: ZodError
    });
}
,
"3263d6bf":function  (module, exports, farmRequire, farmDynamicRequire) {
    const fs = global.nodeRequire('fs', true);
    const path = global.nodeRequire('path', true);
    const os = global.nodeRequire('os', true);
    const crypto = global.nodeRequire('crypto', true);
    const packageJson = farmRequire("5ae26e1f", true);
    const version = packageJson.version;
    const LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    function parse(src) {
        const obj = {};
        let lines = src.toString();
        lines = lines.replace(/\r\n?/mg, '\n');
        let match;
        while((match = LINE.exec(lines)) != null){
            const key = match[1];
            let value = match[2] || '';
            value = value.trim();
            const maybeQuote = value[0];
            value = value.replace(/^(['"`])([\s\S]*)\1$/mg, '$2');
            if (maybeQuote === '"') {
                value = value.replace(/\\n/g, '\n');
                value = value.replace(/\\r/g, '\r');
            }
            obj[key] = value;
        }
        return obj;
    }
    function _parseVault(options) {
        const vaultPath = _vaultPath(options);
        const result = DotenvModule.configDotenv({
            path: vaultPath
        });
        if (!result.parsed) {
            const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
            err.code = 'MISSING_DATA';
            throw err;
        }
        const keys = _dotenvKey(options).split(',');
        const length = keys.length;
        let decrypted;
        for(let i = 0; i < length; i++){
            try {
                const key = keys[i].trim();
                const attrs = _instructions(result, key);
                decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
                break;
            } catch (error) {
                if (i + 1 >= length) {
                    throw error;
                }
            }
        }
        return DotenvModule.parse(decrypted);
    }
    function _log(message) {
        console.log(`[dotenv@${version}][INFO] ${message}`);
    }
    function _warn(message) {
        console.log(`[dotenv@${version}][WARN] ${message}`);
    }
    function _debug(message) {
        console.log(`[dotenv@${version}][DEBUG] ${message}`);
    }
    function _dotenvKey(options) {
        if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
            return options.DOTENV_KEY;
        }
        if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
            return process.env.DOTENV_KEY;
        }
        return '';
    }
    function _instructions(result, dotenvKey) {
        let uri;
        try {
            uri = new URL(dotenvKey);
        } catch (error) {
            if (error.code === 'ERR_INVALID_URL') {
                const err = new Error('INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development');
                err.code = 'INVALID_DOTENV_KEY';
                throw err;
            }
            throw error;
        }
        const key = uri.password;
        if (!key) {
            const err = new Error('INVALID_DOTENV_KEY: Missing key part');
            err.code = 'INVALID_DOTENV_KEY';
            throw err;
        }
        const environment = uri.searchParams.get('environment');
        if (!environment) {
            const err = new Error('INVALID_DOTENV_KEY: Missing environment part');
            err.code = 'INVALID_DOTENV_KEY';
            throw err;
        }
        const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
        const ciphertext = result.parsed[environmentKey];
        if (!ciphertext) {
            const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
            err.code = 'NOT_FOUND_DOTENV_ENVIRONMENT';
            throw err;
        }
        return {
            ciphertext,
            key
        };
    }
    function _vaultPath(options) {
        let possibleVaultPath = null;
        if (options && options.path && options.path.length > 0) {
            if (Array.isArray(options.path)) {
                for (const filepath of options.path){
                    if (fs.existsSync(filepath)) {
                        possibleVaultPath = filepath.endsWith('.vault') ? filepath : `${filepath}.vault`;
                    }
                }
            } else {
                possibleVaultPath = options.path.endsWith('.vault') ? options.path : `${options.path}.vault`;
            }
        } else {
            possibleVaultPath = path.resolve(process.cwd(), '.env.vault');
        }
        if (fs.existsSync(possibleVaultPath)) {
            return possibleVaultPath;
        }
        return null;
    }
    function _resolveHome(envPath) {
        return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath;
    }
    function _configVault(options) {
        _log('Loading env from encrypted .env.vault');
        const parsed = DotenvModule._parseVault(options);
        let processEnv = process.env;
        if (options && options.processEnv != null) {
            processEnv = options.processEnv;
        }
        DotenvModule.populate(processEnv, parsed, options);
        return {
            parsed
        };
    }
    function configDotenv(options) {
        const dotenvPath = path.resolve(process.cwd(), '.env');
        let encoding = 'utf8';
        const debug = Boolean(options && options.debug);
        if (options && options.encoding) {
            encoding = options.encoding;
        } else {
            if (debug) {
                _debug('No encoding is specified. UTF-8 is used by default');
            }
        }
        let optionPaths = [
            dotenvPath
        ];
        if (options && options.path) {
            if (!Array.isArray(options.path)) {
                optionPaths = [
                    _resolveHome(options.path)
                ];
            } else {
                optionPaths = [];
                for (const filepath of options.path){
                    optionPaths.push(_resolveHome(filepath));
                }
            }
        }
        let lastError;
        const parsedAll = {};
        for (const path of optionPaths){
            try {
                const parsed = DotenvModule.parse(fs.readFileSync(path, {
                    encoding
                }));
                DotenvModule.populate(parsedAll, parsed, options);
            } catch (e) {
                if (debug) {
                    _debug(`Failed to load ${path} ${e.message}`);
                }
                lastError = e;
            }
        }
        let processEnv = process.env;
        if (options && options.processEnv != null) {
            processEnv = options.processEnv;
        }
        DotenvModule.populate(processEnv, parsedAll, options);
        if (lastError) {
            return {
                parsed: parsedAll,
                error: lastError
            };
        } else {
            return {
                parsed: parsedAll
            };
        }
    }
    function config(options) {
        if (_dotenvKey(options).length === 0) {
            return DotenvModule.configDotenv(options);
        }
        const vaultPath = _vaultPath(options);
        if (!vaultPath) {
            _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
            return DotenvModule.configDotenv(options);
        }
        return DotenvModule._configVault(options);
    }
    function decrypt(encrypted, keyStr) {
        const key = Buffer.from(keyStr.slice(-64), 'hex');
        let ciphertext = Buffer.from(encrypted, 'base64');
        const nonce = ciphertext.subarray(0, 12);
        const authTag = ciphertext.subarray(-16);
        ciphertext = ciphertext.subarray(12, -16);
        try {
            const aesgcm = crypto.createDecipheriv('aes-256-gcm', key, nonce);
            aesgcm.setAuthTag(authTag);
            return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
        } catch (error) {
            const isRange = error instanceof RangeError;
            const invalidKeyLength = error.message === 'Invalid key length';
            const decryptionFailed = error.message === 'Unsupported state or unable to authenticate data';
            if (isRange || invalidKeyLength) {
                const err = new Error('INVALID_DOTENV_KEY: It must be 64 characters long (or more)');
                err.code = 'INVALID_DOTENV_KEY';
                throw err;
            } else if (decryptionFailed) {
                const err = new Error('DECRYPTION_FAILED: Please check your DOTENV_KEY');
                err.code = 'DECRYPTION_FAILED';
                throw err;
            } else {
                throw error;
            }
        }
    }
    function populate(processEnv, parsed, options = {}) {
        const debug = Boolean(options && options.debug);
        const override = Boolean(options && options.override);
        if (typeof parsed !== 'object') {
            const err = new Error('OBJECT_REQUIRED: Please check the processEnv argument being passed to populate');
            err.code = 'OBJECT_REQUIRED';
            throw err;
        }
        for (const key of Object.keys(parsed)){
            if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
                if (override === true) {
                    processEnv[key] = parsed[key];
                }
                if (debug) {
                    if (override === true) {
                        _debug(`"${key}" is already defined and WAS overwritten`);
                    } else {
                        _debug(`"${key}" is already defined and was NOT overwritten`);
                    }
                }
            } else {
                processEnv[key] = parsed[key];
            }
        }
    }
    const DotenvModule = {
        configDotenv,
        _configVault,
        _parseVault,
        config,
        decrypt,
        parse,
        populate
    };
    module.exports.configDotenv = DotenvModule.configDotenv;
    module.exports._configVault = DotenvModule._configVault;
    module.exports._parseVault = DotenvModule._parseVault;
    module.exports.config = DotenvModule.config;
    module.exports.decrypt = DotenvModule.decrypt;
    module.exports.parse = DotenvModule.parse;
    module.exports.populate = DotenvModule.populate;
    module.exports = DotenvModule;
}
,
"33d70b5a":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "handleInputSync", ()=>handleInputSync);
    module.o(exports, "handleInput", ()=>handleInput);
    module.o(exports, "makeAllStream", ()=>makeAllStream);
    module.o(exports, "getSpawnedResult", ()=>getSpawnedResult);
    var _f_node_fs = farmRequire('node:fs');
    var _f_is_stream = farmRequire("e7253e09");
    var _f_get_stream = module.i(farmRequire("4ac23bc0"));
    var _f_merge_stream = module.i(farmRequire("4cf295d9"));
    const validateInputOptions = (input)=>{
        if (input !== undefined) {
            throw new TypeError('The `input` and `inputFile` options cannot be both set.');
        }
    };
    const getInputSync = ({ input, inputFile })=>{
        if (typeof inputFile !== 'string') {
            return input;
        }
        validateInputOptions(input);
        return _f_node_fs.readFileSync(inputFile);
    };
    var handleInputSync = (options)=>{
        const input = getInputSync(options);
        if (_f_is_stream.isStream(input)) {
            throw new TypeError('The `input` option cannot be a stream in sync mode');
        }
        return input;
    };
    const getInput = ({ input, inputFile })=>{
        if (typeof inputFile !== 'string') {
            return input;
        }
        validateInputOptions(input);
        return _f_node_fs.createReadStream(inputFile);
    };
    var handleInput = (spawned, options)=>{
        const input = getInput(options);
        if (input === undefined) {
            return;
        }
        if (_f_is_stream.isStream(input)) {
            input.pipe(spawned.stdin);
        } else {
            spawned.stdin.end(input);
        }
    };
    var makeAllStream = (spawned, { all })=>{
        if (!all || !spawned.stdout && !spawned.stderr) {
            return;
        }
        const mixed = module.f(_f_merge_stream)();
        if (spawned.stdout) {
            mixed.add(spawned.stdout);
        }
        if (spawned.stderr) {
            mixed.add(spawned.stderr);
        }
        return mixed;
    };
    const getBufferedData = async (stream, streamPromise)=>{
        if (!stream || streamPromise === undefined) {
            return;
        }
        stream.destroy();
        try {
            return await streamPromise;
        } catch (error) {
            return error.bufferedData;
        }
    };
    const getStreamPromise = (stream, { encoding, buffer, maxBuffer })=>{
        if (!stream || !buffer) {
            return;
        }
        if (encoding) {
            return module.f(_f_get_stream)(stream, {
                encoding,
                maxBuffer
            });
        }
        return module.f(_f_get_stream).buffer(stream, {
            maxBuffer
        });
    };
    var getSpawnedResult = async ({ stdout, stderr, all }, { encoding, buffer, maxBuffer }, processDone)=>{
        const stdoutPromise = getStreamPromise(stdout, {
            encoding,
            buffer,
            maxBuffer
        });
        const stderrPromise = getStreamPromise(stderr, {
            encoding,
            buffer,
            maxBuffer
        });
        const allPromise = getStreamPromise(all, {
            encoding,
            buffer,
            maxBuffer: maxBuffer * 2
        });
        try {
            return await Promise.all([
                processDone,
                stdoutPromise,
                stderrPromise,
                allPromise
            ]);
        } catch (error) {
            return Promise.all([
                {
                    error,
                    signal: error.signal,
                    timedOut: error.timedOut
                },
                getBufferedData(stdout, stdoutPromise),
                getBufferedData(stderr, stderrPromise),
                getBufferedData(all, allPromise)
            ]);
        }
    };
}
,
"342cb9f2":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const fsScandir = farmRequire("001be097", true);
    const common = farmRequire("625d23a2", true);
    const reader_1 = farmRequire("3f56675d", true);
    class SyncReader extends reader_1.default {
        constructor(){
            super(...arguments);
            this._scandir = fsScandir.scandirSync;
            this._storage = [];
            this._queue = new Set();
        }
        read() {
            this._pushToQueue(this._root, this._settings.basePath);
            this._handleQueue();
            return this._storage;
        }
        _pushToQueue(directory, base) {
            this._queue.add({
                directory,
                base
            });
        }
        _handleQueue() {
            for (const item of this._queue.values()){
                this._handleDirectory(item.directory, item.base);
            }
        }
        _handleDirectory(directory, base) {
            try {
                const entries = this._scandir(directory, this._settings.fsScandirSettings);
                for (const entry of entries){
                    this._handleEntry(entry, base);
                }
            } catch (error) {
                this._handleError(error);
            }
        }
        _handleError(error) {
            if (!common.isFatalError(this._settings, error)) {
                return;
            }
            throw error;
        }
        _handleEntry(entry, base) {
            const fullpath = entry.path;
            if (base !== undefined) {
                entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
            }
            if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
                this._pushToStorage(entry);
            }
            if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
                this._pushToQueue(fullpath, base === undefined ? undefined : entry.path);
            }
        }
        _pushToStorage(entry) {
            this._storage.push(entry);
        }
    }
    exports.default = SyncReader;
}
,
"3466e00c":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "FileWatcher", ()=>FileWatcher);
    farmRequire('node:module');
    var _f_index = farmRequire("bf50199b");
    var _f_index1 = farmRequire("bd075d6a");
    var _f_index2 = farmRequire("65ad6846");
    var _f_node_fs = farmRequire('node:fs');
    var _f_create_watcher = farmRequire("a041fd99");
    class FileWatcher {
        serverOrCompiler;
        options;
        _logger;
        _root;
        _watcher;
        _close;
        _watchedFiles;
        constructor(serverOrCompiler, options, _logger){
            this.serverOrCompiler = serverOrCompiler;
            this.options = options;
            this._logger = _logger;
            this._close = false;
            this._watchedFiles = new Set();
            this._root = options.root;
        }
        getInternalWatcher() {
            return this._watcher;
        }
        filterWatchFile(file, root) {
            const suffix = process.platform === 'win32' ? '\\' : '/';
            return !file.startsWith(`${root}${suffix}`) && !file.includes(`node_modules${suffix}`) && !file.includes('\0') && _f_node_fs.existsSync(file);
        }
        getExtraWatchedFiles() {
            const compiler = this.getCompilerFromServerOrCompiler(this.serverOrCompiler);
            return [
                ...compiler.resolvedModulePaths(this._root),
                ...compiler.resolvedWatchPaths()
            ].filter((file)=>this.filterWatchFile(file, this._root));
        }
        watchExtraFiles() {
            const files = this.getExtraWatchedFiles();
            for (const file of files){
                if (!this._watchedFiles.has(file)) {
                    this._watcher.add(file);
                    this._watchedFiles.add(file);
                }
            }
        }
        async watch() {
            const compiler = this.getCompilerFromServerOrCompiler(this.serverOrCompiler);
            const handlePathChange = async (path)=>{
                if (this._close) {
                    return;
                }
                try {
                    if (this.serverOrCompiler instanceof _f_index1.Server) {
                        await this.serverOrCompiler.hmrEngine.hmrUpdate(path);
                    }
                    if (this.serverOrCompiler instanceof _f_index.Compiler && this.serverOrCompiler.hasModule(path)) {
                        _f_index2.compilerHandler(async ()=>{
                            const result = await compiler.update([
                                path
                            ], true);
                            handleUpdateFinish(result);
                            compiler.writeResourcesToDisk();
                        }, this.options, this._logger, {
                            clear: true
                        });
                    }
                } catch (error) {
                    this._logger.error(error);
                }
            };
            const watchedFiles = this.getExtraWatchedFiles();
            const files = [
                this.options.root,
                ...watchedFiles
            ];
            this._watchedFiles = new Set(files);
            this._watcher = _f_create_watcher.createWatcher(this.options, files);
            this._watcher.on('change', (path)=>{
                if (this._close) return;
                handlePathChange(path);
            });
            const handleUpdateFinish = (updateResult)=>{
                const added = [
                    ...updateResult.added,
                    ...updateResult.extraWatchResult.add
                ].map((addedModule)=>{
                    const resolvedPath = compiler.transformModulePath(this._root, addedModule);
                    return resolvedPath;
                });
                const filteredAdded = added.filter((file)=>this.filterWatchFile(file, this._root));
                if (filteredAdded.length > 0) {
                    this._watcher.add(filteredAdded);
                }
            };
            if (this.serverOrCompiler instanceof _f_index1.Server) {
                this.serverOrCompiler.hmrEngine?.onUpdateFinish(handleUpdateFinish);
            }
        }
        getCompilerFromServerOrCompiler(serverOrCompiler) {
            return serverOrCompiler instanceof _f_index1.Server ? serverOrCompiler.getCompiler() : serverOrCompiler;
        }
        close() {
            this._close = true;
            this._watcher = null;
            this.serverOrCompiler = null;
        }
    }
}
,
"350f644e":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "verboseDefault", ()=>verboseDefault);
    module.o(exports, "logCommand", ()=>logCommand);
    var _f_node_util = farmRequire('node:util');
    var _f_node_process = module.i(farmRequire('node:process'));
    var verboseDefault = _f_node_util.debuglog('execa').enabled;
    const padField = (field, padding)=>String(field).padStart(padding, '0');
    const getTimestamp = ()=>{
        const date = new Date();
        return `${padField(date.getHours(), 2)}:${padField(date.getMinutes(), 2)}:${padField(date.getSeconds(), 2)}.${padField(date.getMilliseconds(), 3)}`;
    };
    var logCommand = (escapedCommand, { verbose })=>{
        if (!verbose) {
            return;
        }
        module.f(_f_node_process).stderr.write(`[${getTimestamp()}] ${escapedCommand}\n`);
    };
}
,
"357260bd":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "joinPath", ()=>joinPath);
    const identifierRegex = /[$_\p{ID_Start}][$\u200c\u200d\p{ID_Continue}]*/u;
    function joinPath(path) {
        if (path.length === 1) {
            return path[0].toString();
        }
        return path.reduce((acc, item)=>{
            if (typeof item === 'number') {
                return acc + '[' + item.toString() + ']';
            }
            if (item.includes('"')) {
                return acc + '["' + escapeQuotes(item) + '"]';
            }
            if (!identifierRegex.test(item)) {
                return acc + '["' + item + '"]';
            }
            const separator = acc.length === 0 ? '' : '.';
            return acc + separator + item;
        }, '');
    }
    function escapeQuotes(str) {
        return str.replace(/"/g, '\\"');
    }
}
,
"372df827":/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    module.exports = vary;
    module.exports.append = append;
    var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
    function append(header, field) {
        if (typeof header !== 'string') {
            throw new TypeError('header argument is required');
        }
        if (!field) {
            throw new TypeError('field argument is required');
        }
        var fields = !Array.isArray(field) ? parse(String(field)) : field;
        for(var j = 0; j < fields.length; j++){
            if (!FIELD_NAME_REGEXP.test(fields[j])) {
                throw new TypeError('field argument contains an invalid header name');
            }
        }
        if (header === '*') {
            return header;
        }
        var val = header;
        var vals = parse(header.toLowerCase());
        if (fields.indexOf('*') !== -1 || vals.indexOf('*') !== -1) {
            return '*';
        }
        for(var i = 0; i < fields.length; i++){
            var fld = fields[i].toLowerCase();
            if (vals.indexOf(fld) === -1) {
                vals.push(fld);
                val = val ? val + ', ' + fields[i] : fields[i];
            }
        }
        return val;
    }
    function parse(header) {
        var end = 0;
        var list = [];
        var start = 0;
        for(var i = 0, len = header.length; i < len; i++){
            switch(header.charCodeAt(i)){
                case 0x20:
                    if (start === end) {
                        start = end = i + 1;
                    }
                    break;
                case 0x2c:
                    list.push(header.substring(start, end));
                    start = end = i + 1;
                    break;
                default:
                    end = i + 1;
                    break;
            }
        }
        list.push(header.substring(start, end));
        return list;
    }
    function vary(res, field) {
        if (!res || !res.getHeader || !res.setHeader) {
            throw new TypeError('res argument is required');
        }
        var val = res.getHeader('Vary') || '';
        var header = Array.isArray(val) ? val.join(', ') : String(val);
        if (val = append(header, field)) {
            res.setHeader('Vary', val);
        }
    }
}
,
"37c97648":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const os = global.nodeRequire('os', true);
    const onExit = farmRequire("fb66eeb6", true);
    const DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5;
    const spawnedKill = (kill, signal = 'SIGTERM', options = {})=>{
        const killResult = kill(signal);
        setKillTimeout(kill, signal, options, killResult);
        return killResult;
    };
    const setKillTimeout = (kill, signal, options, killResult)=>{
        if (!shouldForceKill(signal, options, killResult)) {
            return;
        }
        const timeout = getForceKillAfterTimeout(options);
        const t = setTimeout(()=>{
            kill('SIGKILL');
        }, timeout);
        if (t.unref) {
            t.unref();
        }
    };
    const shouldForceKill = (signal, { forceKillAfterTimeout }, killResult)=>{
        return isSigterm(signal) && forceKillAfterTimeout !== false && killResult;
    };
    const isSigterm = (signal)=>{
        return signal === os.constants.signals.SIGTERM || typeof signal === 'string' && signal.toUpperCase() === 'SIGTERM';
    };
    const getForceKillAfterTimeout = ({ forceKillAfterTimeout = true })=>{
        if (forceKillAfterTimeout === true) {
            return DEFAULT_FORCE_KILL_TIMEOUT;
        }
        if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {
            throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
        }
        return forceKillAfterTimeout;
    };
    const spawnedCancel = (spawned, context)=>{
        const killResult = spawned.kill();
        if (killResult) {
            context.isCanceled = true;
        }
    };
    const timeoutKill = (spawned, signal, reject)=>{
        spawned.kill(signal);
        reject(Object.assign(new Error('Timed out'), {
            timedOut: true,
            signal
        }));
    };
    const setupTimeout = (spawned, { timeout, killSignal = 'SIGTERM' }, spawnedPromise)=>{
        if (timeout === 0 || timeout === undefined) {
            return spawnedPromise;
        }
        let timeoutId;
        const timeoutPromise = new Promise((resolve, reject)=>{
            timeoutId = setTimeout(()=>{
                timeoutKill(spawned, killSignal, reject);
            }, timeout);
        });
        const safeSpawnedPromise = spawnedPromise.finally(()=>{
            clearTimeout(timeoutId);
        });
        return Promise.race([
            timeoutPromise,
            safeSpawnedPromise
        ]);
    };
    const validateTimeout = ({ timeout })=>{
        if (timeout !== undefined && (!Number.isFinite(timeout) || timeout < 0)) {
            throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
        }
    };
    const setExitHandler = async (spawned, { cleanup, detached }, timedPromise)=>{
        if (!cleanup || detached) {
            return timedPromise;
        }
        const removeExitHandler = onExit(()=>{
            spawned.kill();
        });
        return timedPromise.finally(()=>{
            removeExitHandler();
        });
    };
    module.exports = {
        spawnedKill,
        spawnedCancel,
        setupTimeout,
        validateTimeout,
        setExitHandler
    };
}
,
"39f91206":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "parseUserConfig", ()=>parseUserConfig);
    var _f_http = module.i(farmRequire('http'));
    var _f_zod = farmRequire("3226da43");
    var _f_zod_validation_error = farmRequire("b82d8e6c");
    const stringRewriteSchema = _f_zod.z.record(_f_zod.z.string(), _f_zod.z.string());
    const functionRewriteSchema = _f_zod.z.union([
        _f_zod.z.function().args(_f_zod.z.string(), _f_zod.z.any()).returns(_f_zod.z.string()),
        _f_zod.z.function().args(_f_zod.z.string(), _f_zod.z.any()).returns(_f_zod.z.promise(_f_zod.z.string()))
    ]);
    const pathFilterSchema = _f_zod.z.union([
        _f_zod.z.string(),
        _f_zod.z.array(_f_zod.z.string()),
        _f_zod.z.function().args(_f_zod.z.string(), _f_zod.z.instanceof(module.f(_f_http).IncomingMessage)).returns(_f_zod.z.boolean())
    ]);
    const pathRewriteSchema = _f_zod.z.union([
        stringRewriteSchema,
        functionRewriteSchema
    ]);
    const compilationConfigSchema = _f_zod.z.object({
        root: _f_zod.z.string().optional(),
        input: _f_zod.z.record(_f_zod.z.string()).optional(),
        output: _f_zod.z.object({
            entryFilename: _f_zod.z.string().optional(),
            filename: _f_zod.z.string().optional(),
            path: _f_zod.z.string().optional(),
            publicPath: _f_zod.z.string().optional(),
            assetsFilename: _f_zod.z.string().optional(),
            targetEnv: _f_zod.z.enum([
                'browser',
                'node',
                'node-legacy',
                'node-next',
                'node16',
                'browser-legacy',
                'browser-esnext',
                'browser-es2015',
                'browser-es2017',
                'library',
                'library-browser',
                'library-node'
            ]).optional(),
            format: _f_zod.z.enum([
                'cjs',
                'esm'
            ]).optional(),
            clean: _f_zod.z.boolean().optional(),
            asciiOnly: _f_zod.z.boolean().optional()
        }).strict().optional(),
        resolve: _f_zod.z.object({
            extensions: _f_zod.z.array(_f_zod.z.string()).optional(),
            alias: _f_zod.z.record(_f_zod.z.string()).optional(),
            mainFields: _f_zod.z.array(_f_zod.z.string()).optional(),
            conditions: _f_zod.z.array(_f_zod.z.string()).optional(),
            symlinks: _f_zod.z.boolean().optional(),
            strictExports: _f_zod.z.boolean().optional(),
            autoExternalFailedResolve: _f_zod.z.boolean().optional(),
            dedupe: _f_zod.z.array(_f_zod.z.string()).optional()
        }).strict().optional(),
        define: _f_zod.z.record(_f_zod.z.any()).optional(),
        external: _f_zod.z.array(_f_zod.z.string().or(_f_zod.z.record(_f_zod.z.string(), _f_zod.z.string()))).optional(),
        externalNodeBuiltins: _f_zod.z.union([
            _f_zod.z.boolean(),
            _f_zod.z.array(_f_zod.z.string())
        ]).optional(),
        mode: _f_zod.z.string().optional(),
        watch: _f_zod.z.union([
            _f_zod.z.boolean(),
            _f_zod.z.object({
                ignored: _f_zod.z.array(_f_zod.z.string()).optional(),
                watchOptions: _f_zod.z.object({
                    awaitWriteFinish: _f_zod.z.number().positive().int().optional()
                }).optional()
            })
        ]).optional(),
        coreLibPath: _f_zod.z.string().optional(),
        runtime: _f_zod.z.object({
            path: _f_zod.z.string().optional(),
            plugins: _f_zod.z.array(_f_zod.z.string()).optional(),
            swcHelpersPath: _f_zod.z.string().optional(),
            isolate: _f_zod.z.boolean().optional()
        }).strict().optional(),
        assets: _f_zod.z.object({
            include: _f_zod.z.array(_f_zod.z.string()).optional(),
            publicDir: _f_zod.z.string().optional(),
            mode: _f_zod.z.enum([
                'browser',
                'node'
            ]).optional()
        }).strict().optional(),
        script: _f_zod.z.object({
            target: _f_zod.z.enum([
                'es3',
                'es5',
                'es2015',
                'es2016',
                'es2017',
                'es2018',
                'es2019',
                'es2020',
                'es2021',
                'es2022',
                'esnext'
            ]).optional(),
            parser: _f_zod.z.object({
                esConfig: _f_zod.z.object({
                    jsx: _f_zod.z.boolean().optional(),
                    fnBind: _f_zod.z.boolean(),
                    decorators: _f_zod.z.boolean(),
                    decoratorsBeforeExport: _f_zod.z.boolean(),
                    exportDefaultFrom: _f_zod.z.boolean(),
                    importAssertions: _f_zod.z.boolean(),
                    privateInObject: _f_zod.z.boolean(),
                    allowSuperOutsideMethod: _f_zod.z.boolean(),
                    allowReturnOutsideFunction: _f_zod.z.boolean()
                }).strict().optional(),
                tsConfig: _f_zod.z.object({
                    tsx: _f_zod.z.boolean().optional(),
                    decorators: _f_zod.z.boolean().optional(),
                    dts: _f_zod.z.boolean().optional(),
                    noEarlyErrors: _f_zod.z.boolean().optional()
                }).strict().optional()
            }).optional(),
            decorators: _f_zod.z.object({
                legacyDecorator: _f_zod.z.boolean().optional(),
                decoratorMetadata: _f_zod.z.boolean().optional(),
                decoratorVersion: _f_zod.z.union([
                    _f_zod.z.literal('2021-12'),
                    _f_zod.z.literal('2022-03')
                ]).optional(),
                includes: _f_zod.z.array(_f_zod.z.string()).optional(),
                excludes: _f_zod.z.array(_f_zod.z.string()).optional()
            }).optional(),
            plugins: _f_zod.z.array(_f_zod.z.any()).optional(),
            nativeTopLevelAwait: _f_zod.z.boolean().optional(),
            importNotUsedAsValues: _f_zod.z.union([
                _f_zod.z.literal('remove'),
                _f_zod.z.literal('preserve'),
                _f_zod.z.object({
                    preserve: _f_zod.z.array(_f_zod.z.string()).optional()
                })
            ]).optional()
        }).strict().optional(),
        sourcemap: _f_zod.z.union([
            _f_zod.z.boolean(),
            _f_zod.z.literal('all'),
            _f_zod.z.literal('inline'),
            _f_zod.z.literal('all-inline')
        ]).optional(),
        partialBundling: _f_zod.z.object({
            targetConcurrentRequests: _f_zod.z.number().positive().int().optional(),
            targetMinSize: _f_zod.z.number().nonnegative().int().optional(),
            targetMaxSize: _f_zod.z.number().nonnegative().int().optional(),
            groups: _f_zod.z.array(_f_zod.z.object({
                name: _f_zod.z.string(),
                test: _f_zod.z.array(_f_zod.z.string()),
                groupType: _f_zod.z.enum([
                    'mutable',
                    'immutable'
                ]).optional(),
                resourceType: _f_zod.z.enum([
                    'all',
                    'initial',
                    'async'
                ]).optional()
            })).optional(),
            enforceResources: _f_zod.z.array(_f_zod.z.object({
                name: _f_zod.z.string(),
                test: _f_zod.z.array(_f_zod.z.string())
            }).strict()).optional(),
            enforceTargetConcurrentRequests: _f_zod.z.boolean().optional(),
            enforceTargetMinSize: _f_zod.z.boolean().optional(),
            immutableModules: _f_zod.z.array(_f_zod.z.string()).optional(),
            immutableModulesWeight: _f_zod.z.number().optional()
        }).strict().optional(),
        lazyCompilation: _f_zod.z.boolean().optional(),
        treeShaking: _f_zod.z.boolean().optional(),
        minify: _f_zod.z.union([
            _f_zod.z.boolean(),
            _f_zod.z.object({
                compress: _f_zod.z.union([
                    _f_zod.z.any(),
                    _f_zod.z.boolean()
                ]).optional(),
                mangle: _f_zod.z.union([
                    _f_zod.z.any(),
                    _f_zod.z.boolean()
                ]).optional(),
                exclude: _f_zod.z.array(_f_zod.z.string()).optional(),
                include: _f_zod.z.array(_f_zod.z.string()).optional(),
                mode: _f_zod.z.union([
                    _f_zod.z.literal('minify-module'),
                    _f_zod.z.literal('minify-resource-pot')
                ]).optional(),
                moduleDecls: _f_zod.z.boolean().optional()
            })
        ]).optional(),
        record: _f_zod.z.boolean().optional(),
        progress: _f_zod.z.boolean().optional(),
        presetEnv: _f_zod.z.union([
            _f_zod.z.boolean(),
            _f_zod.z.object({
                include: _f_zod.z.array(_f_zod.z.string()).optional(),
                exclude: _f_zod.z.array(_f_zod.z.string()).optional(),
                options: _f_zod.z.any().optional(),
                assumptions: _f_zod.z.any().optional()
            })
        ]).optional(),
        css: _f_zod.z.object({
            modules: _f_zod.z.union([
                _f_zod.z.null(),
                _f_zod.z.object({
                    indentName: _f_zod.z.string().optional(),
                    localsConversion: _f_zod.z.string().optional(),
                    paths: _f_zod.z.array(_f_zod.z.string()).optional()
                })
            ]).optional(),
            prefixer: _f_zod.z.union([
                _f_zod.z.null(),
                _f_zod.z.object({
                    targets: _f_zod.z.string().or(_f_zod.z.record(_f_zod.z.string())).or(_f_zod.z.array(_f_zod.z.string())).optional()
                })
            ]).optional()
        }).optional(),
        html: _f_zod.z.object({
            base: _f_zod.z.string().optional()
        }).optional(),
        persistentCache: _f_zod.z.union([
            _f_zod.z.boolean(),
            _f_zod.z.object({
                namespace: _f_zod.z.string().optional(),
                cacheDir: _f_zod.z.string().optional(),
                buildDependencies: _f_zod.z.array(_f_zod.z.string()).optional(),
                moduleCacheKeyStrategy: _f_zod.z.object({
                    timestamp: _f_zod.z.boolean().optional(),
                    hash: _f_zod.z.boolean().optional()
                }).optional(),
                envs: _f_zod.z.record(_f_zod.z.string(), _f_zod.z.string()).optional(),
                globalBuiltinCacheKeyStrategy: _f_zod.z.object({
                    env: _f_zod.z.boolean().optional(),
                    define: _f_zod.z.boolean().optional(),
                    buildDependencies: _f_zod.z.boolean().optional(),
                    lockfile: _f_zod.z.boolean().optional(),
                    packageJson: _f_zod.z.boolean().optional()
                }).optional()
            }).optional()
        ]),
        comments: _f_zod.z.union([
            _f_zod.z.boolean(),
            _f_zod.z.literal('license')
        ]).optional(),
        custom: _f_zod.z.record(_f_zod.z.string(), _f_zod.z.string()).optional()
    }).strict();
    const FarmConfigSchema = _f_zod.z.object({
        root: _f_zod.z.string().optional(),
        clearScreen: _f_zod.z.boolean().optional(),
        configPath: _f_zod.z.string().optional(),
        envDir: _f_zod.z.string().optional(),
        envPrefix: _f_zod.z.union([
            _f_zod.z.string(),
            _f_zod.z.array(_f_zod.z.string())
        ]).optional(),
        publicDir: _f_zod.z.string().optional(),
        plugins: _f_zod.z.array(_f_zod.z.any()).optional(),
        vitePlugins: _f_zod.z.array(_f_zod.z.any()).optional(),
        compilation: compilationConfigSchema.optional(),
        mode: _f_zod.z.string().optional(),
        server: _f_zod.z.object({
            headers: _f_zod.z.record(_f_zod.z.string()).optional(),
            port: _f_zod.z.number().positive().int().optional(),
            host: _f_zod.z.union([
                _f_zod.z.string().regex(/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/),
                _f_zod.z.literal('localhost'),
                _f_zod.z.boolean()
            ]).optional(),
            open: _f_zod.z.boolean().optional(),
            https: _f_zod.z.custom(),
            cors: _f_zod.z.boolean().optional(),
            spa: _f_zod.z.boolean().optional(),
            proxy: _f_zod.z.record(_f_zod.z.object({
                target: _f_zod.z.string(),
                changeOrigin: _f_zod.z.boolean().optional(),
                agent: _f_zod.z.any().optional(),
                secure: _f_zod.z.boolean().optional(),
                logs: _f_zod.z.any().optional(),
                pathRewrite: pathRewriteSchema.optional(),
                pathFilter: pathFilterSchema.optional(),
                headers: _f_zod.z.record(_f_zod.z.string()).optional(),
                on: _f_zod.z.object({
                    proxyReq: _f_zod.z.function().args(_f_zod.z.instanceof(Object), _f_zod.z.instanceof(Object), _f_zod.z.instanceof(Object)).returns(_f_zod.z.void()).optional(),
                    proxyRes: _f_zod.z.function().args(_f_zod.z.instanceof(Object), _f_zod.z.instanceof(Object), _f_zod.z.instanceof(Object)).returns(_f_zod.z.void()).optional(),
                    error: _f_zod.z.function().args(_f_zod.z.instanceof(Error), _f_zod.z.instanceof(Object), _f_zod.z.instanceof(Object)).returns(_f_zod.z.void()).optional()
                }).optional()
            }).passthrough()).optional(),
            strictPort: _f_zod.z.boolean().optional(),
            hmr: _f_zod.z.union([
                _f_zod.z.boolean(),
                _f_zod.z.object({
                    protocol: _f_zod.z.string().optional(),
                    host: _f_zod.z.union([
                        _f_zod.z.string().min(1),
                        _f_zod.z.boolean()
                    ]).optional(),
                    port: _f_zod.z.number().positive().int().optional(),
                    path: _f_zod.z.string().optional(),
                    watchOptions: _f_zod.z.object({
                        awaitWriteFinish: _f_zod.z.number().positive().int().optional()
                    }).optional(),
                    overlay: _f_zod.z.boolean().optional()
                }).strict()
            ]).optional(),
            middlewares: _f_zod.z.array(_f_zod.z.any()).optional(),
            writeToDisk: _f_zod.z.boolean().optional()
        }).strict().optional()
    }).strict();
    function parseUserConfig(config) {
        try {
            const parsed = FarmConfigSchema.parse(config);
            return parsed;
        } catch (err) {
            const validationError = _f_zod_validation_error.fromZodError(err);
            throw new Error(`${validationError.toString()}. \n Please check your configuration file or command line configuration.`);
        }
    }
}
,
"3a7d7323":/*!
 * Caron dimonio, con occhi di bragia
 * loro accennando, tutte le raccoglie;
 * batte col remo qualunque sadagia 
 *
 * Charon the demon, with the eyes of glede,
 * Beckoning to them, collects them all together,
 * Beats with his oar whoever lags behind
 *          
 *          Dante - The Divine Comedy (Canto III)
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    module.exports = farmRequire("f8f16f68", true);
}
,
"3b82e8e5":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "handleVitePlugins", ()=>handleVitePlugins);
    module.o(exports, "processVitePlugin", ()=>processVitePlugin);
    module.o(exports, "convertPlugin", ()=>convertPlugin);
    var _f_index = farmRequire("953dfae2");
    var _f_merge = module.i(farmRequire("c074a41a"));
    var _f_index1 = farmRequire("ee2469d1");
    var _f_css = farmRequire("cfe047c9");
    var _f_default_load = farmRequire("1e5e7e95");
    var _f_utils = farmRequire("e60815f7");
    var _f_vite_plugin_adapter = farmRequire("9f146555");
    async function handleVitePlugins(vitePlugins, userConfig, logger, mode) {
        const jsPlugins = [];
        const filtersUnion = new Set();
        if (vitePlugins.length) {
            userConfig = module.f(_f_merge)({}, userConfig, {
                compilation: userConfig.compilation,
                server: _f_index.normalizeDevServerConfig(userConfig.server, userConfig.compilation?.mode ?? mode)
            });
        }
        const flatVitePlugins = await _f_index1.resolveAsyncPlugins(vitePlugins);
        for (const vitePluginObj of flatVitePlugins){
            let vitePlugin = vitePluginObj, filters = _f_utils.DEFAULT_FILTERS;
            if (typeof vitePluginObj === 'function') {
                const { vitePlugin: plugin, filters: f } = vitePluginObj();
                vitePlugin = plugin;
                filters = f;
            }
            filters?.forEach((filter)=>filtersUnion.add(filter));
            processVitePlugin(vitePlugin, userConfig, filters, jsPlugins, logger, mode);
        }
        if (vitePlugins.length) {
            jsPlugins.push(_f_default_load.defaultLoadPlugin({
                filtersUnion,
                logger,
                userConfig
            }));
            jsPlugins.unshift(_f_css.cssPluginWrap({
                filtersUnion
            }));
            jsPlugins.push(_f_css.cssPluginUnwrap({
                filtersUnion
            }));
        }
        return jsPlugins;
    }
    function processVitePlugin(vitePlugin, userConfig, filters, jsPlugins, logger, mode) {
        const processPlugin = (plugin)=>{
            const vitePluginAdapter = new _f_vite_plugin_adapter.VitePluginAdapter(plugin, userConfig, filters, logger, mode);
            convertPlugin(vitePluginAdapter);
            jsPlugins.push(vitePluginAdapter);
        };
        if (Array.isArray(vitePlugin)) {
            vitePlugin.forEach((plugin)=>processPlugin(plugin));
        } else {
            processPlugin(vitePlugin);
        }
    }
    function convertPlugin(plugin) {
        if (plugin.transform && !plugin.transform.filters?.moduleTypes && !plugin.transform.filters?.resolvedPaths) {
            throw new Error(`transform hook of plugin ${plugin.name} must have at least one filter(like moduleTypes or resolvedPaths)`);
        }
        if (plugin.transform) {
            if (!plugin.transform.filters.moduleTypes) {
                plugin.transform.filters.moduleTypes = [];
            } else if (!plugin.transform.filters.resolvedPaths) {
                plugin.transform.filters.resolvedPaths = [];
            }
        }
        if (plugin.processModule) {
            plugin.processModule.filters ??= {};
            plugin.processModule.filters.moduleTypes ??= [];
            plugin.processModule.filters.resolvedPaths ??= [];
        }
        if (plugin.renderResourcePot) {
            plugin.renderResourcePot.filters ??= {};
            if (!plugin.renderResourcePot?.filters?.moduleIds && !plugin.renderResourcePot?.filters?.resourcePotTypes) {
                throw new Error(`renderResourcePot hook of plugin ${plugin.name} must have at least one filter(like moduleIds or resourcePotTypes)`);
            }
            if (!plugin.renderResourcePot.filters?.resourcePotTypes) {
                plugin.renderResourcePot.filters.resourcePotTypes = [];
            } else if (!plugin.renderResourcePot.filters?.moduleIds) {
                plugin.renderResourcePot.filters.moduleIds = [];
            }
        }
        if (plugin.augmentResourceHash) {
            plugin.augmentResourceHash.filters ??= {};
            if (!plugin.augmentResourceHash?.filters?.moduleIds && !plugin.augmentResourceHash?.filters?.resourcePotTypes) {
                throw new Error(`augmentResourceHash hook of plugin ${plugin.name} must have at least one filter(like moduleIds or resourcePotTypes)`);
            }
            if (!plugin.augmentResourceHash.filters?.resourcePotTypes) {
                plugin.augmentResourceHash.filters.resourcePotTypes = [];
            } else if (!plugin.augmentResourceHash.filters?.moduleIds) {
                plugin.augmentResourceHash.filters.moduleIds = [];
            }
        }
        if (plugin.resolve?.filters?.importers?.length) {
            plugin.resolve.filters.importers = plugin.resolve.filters.importers.map(_f_utils.normalizeFilterPath);
        }
        if (plugin.load?.filters?.resolvedPaths?.length) {
            plugin.load.filters.resolvedPaths = plugin.load.filters.resolvedPaths.map(_f_utils.normalizeFilterPath);
        }
        if (plugin.transform?.filters?.resolvedPaths?.length) {
            plugin.transform.filters.resolvedPaths = plugin.transform.filters.resolvedPaths.map(_f_utils.normalizeFilterPath);
        }
        if (plugin.augmentResourceHash?.filters?.moduleIds) {
            plugin.augmentResourceHash.filters.moduleIds = plugin.augmentResourceHash.filters.moduleIds.map(_f_utils.normalizeFilterPath);
        }
        if (plugin.renderResourcePot?.filters?.moduleIds) {
            plugin.renderResourcePot.filters.moduleIds = plugin.renderResourcePot.filters.moduleIds.map(_f_utils.normalizeFilterPath);
        }
    }
}
,
"3c1571d9":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;
    const fs = global.nodeRequire("fs", true);
    exports.FILE_SYSTEM_ADAPTER = {
        lstat: fs.lstat,
        stat: fs.stat,
        lstatSync: fs.lstatSync,
        statSync: fs.statSync
    };
    function createFileSystemAdapter(fsMethods) {
        if (fsMethods === undefined) {
            return exports.FILE_SYSTEM_ADAPTER;
        }
        return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports.createFileSystemAdapter = createFileSystemAdapter;
}
,
"3ebd0c9e":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const jsonFile = farmRequire("1464d5a7", true);
    module.exports = {
        readJson: jsonFile.readFile,
        readJsonSync: jsonFile.readFileSync,
        writeJson: jsonFile.writeFile,
        writeJsonSync: jsonFile.writeFileSync
    };
}
,
"3ee4e850":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    try {
        module.exports = farmRequire("b6e736ca")(__dirname);
    } catch (e) {
        module.exports = farmRequire("76e61d33", true);
    }
}
,
"3f56675d":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const common = farmRequire("625d23a2", true);
    class Reader {
        constructor(_root, _settings){
            this._root = _root;
            this._settings = _settings;
            this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
        }
    }
    exports.default = Reader;
}
,
"3fc2054c":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    var _f_rustPluginResolver = farmRequire("7d77fe06");
    module._(exports, "rustPluginResolver", _f_rustPluginResolver);
}
,
"408b3b5b":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.merge = void 0;
    const merge2 = farmRequire("959fb2d0", true);
    function merge(streams) {
        const mergedStream = merge2(streams);
        streams.forEach((stream)=>{
            stream.once('error', (error)=>mergedStream.emit('error', error));
        });
        mergedStream.once('close', ()=>propagateCloseEventToSources(streams));
        mergedStream.once('end', ()=>propagateCloseEventToSources(streams));
        return mergedStream;
    }
    exports.merge = merge;
    function propagateCloseEventToSources(streams) {
        streams.forEach((stream)=>stream.emit('close'));
    }
}
,
"40c7ffaa":function  (module, exports, farmRequire, farmDynamicRequire) {
    exports = module.exports = typeof Object.keys === 'function' ? Object.keys : shim;
    exports.shim = shim;
    function shim(obj) {
        var keys = [];
        for(var key in obj)keys.push(key);
        return keys;
    }
}
,
"410b6735":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.Settings = exports.walkStream = exports.walkSync = exports.walk = void 0;
    const async_1 = farmRequire("6cc7e919", true);
    const stream_1 = farmRequire("5f500fe0", true);
    const sync_1 = farmRequire("1c12c622", true);
    const settings_1 = farmRequire("cea679ec", true);
    exports.Settings = settings_1.default;
    function walk(directory, optionsOrSettingsOrCallback, callback) {
        if (typeof optionsOrSettingsOrCallback === 'function') {
            new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
            return;
        }
        new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
    }
    exports.walk = walk;
    function walkSync(directory, optionsOrSettings) {
        const settings = getSettings(optionsOrSettings);
        const provider = new sync_1.default(directory, settings);
        return provider.read();
    }
    exports.walkSync = walkSync;
    function walkStream(directory, optionsOrSettings) {
        const settings = getSettings(optionsOrSettings);
        const provider = new stream_1.default(directory, settings);
        return provider.read();
    }
    exports.walkStream = walkStream;
    function getSettings(settingsOrOptions = {}) {
        if (settingsOrOptions instanceof settings_1.default) {
            return settingsOrOptions;
        }
        return new settings_1.default(settingsOrOptions);
    }
}
,
"4249400c":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.convertPatternGroupToTask = exports.convertPatternGroupsToTasks = exports.groupPatternsByBaseDirectory = exports.getNegativePatternsAsPositive = exports.getPositivePatterns = exports.convertPatternsToTasks = exports.generate = void 0;
    const utils = farmRequire("781fd2fa", true);
    function generate(input, settings) {
        const patterns = processPatterns(input, settings);
        const ignore = processPatterns(settings.ignore, settings);
        const positivePatterns = getPositivePatterns(patterns);
        const negativePatterns = getNegativePatternsAsPositive(patterns, ignore);
        const staticPatterns = positivePatterns.filter((pattern)=>utils.pattern.isStaticPattern(pattern, settings));
        const dynamicPatterns = positivePatterns.filter((pattern)=>utils.pattern.isDynamicPattern(pattern, settings));
        const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, false);
        const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, true);
        return staticTasks.concat(dynamicTasks);
    }
    exports.generate = generate;
    function processPatterns(input, settings) {
        let patterns = input;
        if (settings.braceExpansion) {
            patterns = utils.pattern.expandPatternsWithBraceExpansion(patterns);
        }
        if (settings.baseNameMatch) {
            patterns = patterns.map((pattern)=>pattern.includes('/') ? pattern : `**/${pattern}`);
        }
        return patterns.map((pattern)=>utils.pattern.removeDuplicateSlashes(pattern));
    }
    function convertPatternsToTasks(positive, negative, dynamic) {
        const tasks = [];
        const patternsOutsideCurrentDirectory = utils.pattern.getPatternsOutsideCurrentDirectory(positive);
        const patternsInsideCurrentDirectory = utils.pattern.getPatternsInsideCurrentDirectory(positive);
        const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);
        const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
        tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));
        if ('.' in insideCurrentDirectoryGroup) {
            tasks.push(convertPatternGroupToTask('.', patternsInsideCurrentDirectory, negative, dynamic));
        } else {
            tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));
        }
        return tasks;
    }
    exports.convertPatternsToTasks = convertPatternsToTasks;
    function getPositivePatterns(patterns) {
        return utils.pattern.getPositivePatterns(patterns);
    }
    exports.getPositivePatterns = getPositivePatterns;
    function getNegativePatternsAsPositive(patterns, ignore) {
        const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);
        const positive = negative.map(utils.pattern.convertToPositivePattern);
        return positive;
    }
    exports.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
    function groupPatternsByBaseDirectory(patterns) {
        const group = {};
        return patterns.reduce((collection, pattern)=>{
            const base = utils.pattern.getBaseDirectory(pattern);
            if (base in collection) {
                collection[base].push(pattern);
            } else {
                collection[base] = [
                    pattern
                ];
            }
            return collection;
        }, group);
    }
    exports.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
    function convertPatternGroupsToTasks(positive, negative, dynamic) {
        return Object.keys(positive).map((base)=>{
            return convertPatternGroupToTask(base, positive[base], negative, dynamic);
        });
    }
    exports.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
    function convertPatternGroupToTask(base, positive, negative, dynamic) {
        return {
            dynamic,
            positive,
            negative,
            base,
            patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))
        };
    }
    exports.convertPatternGroupToTask = convertPatternGroupToTask;
}
,
"4278e518":/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const util = global.nodeRequire('util', true);
    const toRegexRange = farmRequire("b7669e10", true);
    const isObject = (val)=>val !== null && typeof val === 'object' && !Array.isArray(val);
    const transform = (toNumber)=>{
        return (value)=>toNumber === true ? Number(value) : String(value);
    };
    const isValidValue = (value)=>{
        return typeof value === 'number' || typeof value === 'string' && value !== '';
    };
    const isNumber = (num)=>Number.isInteger(+num);
    const zeros = (input)=>{
        let value = `${input}`;
        let index = -1;
        if (value[0] === '-') value = value.slice(1);
        if (value === '0') return false;
        while(value[++index] === '0');
        return index > 0;
    };
    const stringify = (start, end, options)=>{
        if (typeof start === 'string' || typeof end === 'string') {
            return true;
        }
        return options.stringify === true;
    };
    const pad = (input, maxLength, toNumber)=>{
        if (maxLength > 0) {
            let dash = input[0] === '-' ? '-' : '';
            if (dash) input = input.slice(1);
            input = dash + input.padStart(dash ? maxLength - 1 : maxLength, '0');
        }
        if (toNumber === false) {
            return String(input);
        }
        return input;
    };
    const toMaxLen = (input, maxLength)=>{
        let negative = input[0] === '-' ? '-' : '';
        if (negative) {
            input = input.slice(1);
            maxLength--;
        }
        while(input.length < maxLength)input = '0' + input;
        return negative ? '-' + input : input;
    };
    const toSequence = (parts, options)=>{
        parts.negatives.sort((a, b)=>a < b ? -1 : a > b ? 1 : 0);
        parts.positives.sort((a, b)=>a < b ? -1 : a > b ? 1 : 0);
        let prefix = options.capture ? '' : '?:';
        let positives = '';
        let negatives = '';
        let result;
        if (parts.positives.length) {
            positives = parts.positives.join('|');
        }
        if (parts.negatives.length) {
            negatives = `-(${prefix}${parts.negatives.join('|')})`;
        }
        if (positives && negatives) {
            result = `${positives}|${negatives}`;
        } else {
            result = positives || negatives;
        }
        if (options.wrap) {
            return `(${prefix}${result})`;
        }
        return result;
    };
    const toRange = (a, b, isNumbers, options)=>{
        if (isNumbers) {
            return toRegexRange(a, b, {
                wrap: false,
                ...options
            });
        }
        let start = String.fromCharCode(a);
        if (a === b) return start;
        let stop = String.fromCharCode(b);
        return `[${start}-${stop}]`;
    };
    const toRegex = (start, end, options)=>{
        if (Array.isArray(start)) {
            let wrap = options.wrap === true;
            let prefix = options.capture ? '' : '?:';
            return wrap ? `(${prefix}${start.join('|')})` : start.join('|');
        }
        return toRegexRange(start, end, options);
    };
    const rangeError = (...args)=>{
        return new RangeError('Invalid range arguments: ' + util.inspect(...args));
    };
    const invalidRange = (start, end, options)=>{
        if (options.strictRanges === true) throw rangeError([
            start,
            end
        ]);
        return [];
    };
    const invalidStep = (step, options)=>{
        if (options.strictRanges === true) {
            throw new TypeError(`Expected step "${step}" to be a number`);
        }
        return [];
    };
    const fillNumbers = (start, end, step = 1, options = {})=>{
        let a = Number(start);
        let b = Number(end);
        if (!Number.isInteger(a) || !Number.isInteger(b)) {
            if (options.strictRanges === true) throw rangeError([
                start,
                end
            ]);
            return [];
        }
        if (a === 0) a = 0;
        if (b === 0) b = 0;
        let descending = a > b;
        let startString = String(start);
        let endString = String(end);
        let stepString = String(step);
        step = Math.max(Math.abs(step), 1);
        let padded = zeros(startString) || zeros(endString) || zeros(stepString);
        let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
        let toNumber = padded === false && stringify(start, end, options) === false;
        let format = options.transform || transform(toNumber);
        if (options.toRegex && step === 1) {
            return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
        }
        let parts = {
            negatives: [],
            positives: []
        };
        let push = (num)=>parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));
        let range = [];
        let index = 0;
        while(descending ? a >= b : a <= b){
            if (options.toRegex === true && step > 1) {
                push(a);
            } else {
                range.push(pad(format(a, index), maxLen, toNumber));
            }
            a = descending ? a - step : a + step;
            index++;
        }
        if (options.toRegex === true) {
            return step > 1 ? toSequence(parts, options) : toRegex(range, null, {
                wrap: false,
                ...options
            });
        }
        return range;
    };
    const fillLetters = (start, end, step = 1, options = {})=>{
        if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
            return invalidRange(start, end, options);
        }
        let format = options.transform || ((val)=>String.fromCharCode(val));
        let a = `${start}`.charCodeAt(0);
        let b = `${end}`.charCodeAt(0);
        let descending = a > b;
        let min = Math.min(a, b);
        let max = Math.max(a, b);
        if (options.toRegex && step === 1) {
            return toRange(min, max, false, options);
        }
        let range = [];
        let index = 0;
        while(descending ? a >= b : a <= b){
            range.push(format(a, index));
            a = descending ? a - step : a + step;
            index++;
        }
        if (options.toRegex === true) {
            return toRegex(range, null, {
                wrap: false,
                options
            });
        }
        return range;
    };
    const fill = (start, end, step, options = {})=>{
        if (end == null && isValidValue(start)) {
            return [
                start
            ];
        }
        if (!isValidValue(start) || !isValidValue(end)) {
            return invalidRange(start, end, options);
        }
        if (typeof step === 'function') {
            return fill(start, end, 1, {
                transform: step
            });
        }
        if (isObject(step)) {
            return fill(start, end, 0, step);
        }
        let opts = {
            ...options
        };
        if (opts.capture === true) opts.wrap = true;
        step = step || opts.step || 1;
        if (!isNumber(step)) {
            if (step != null && !isObject(step)) return invalidStep(step, opts);
            return fill(start, end, 1, step);
        }
        if (isNumber(start) && isNumber(end)) {
            return fillNumbers(start, end, step, opts);
        }
        return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
    };
    module.exports = fill;
}
,
"42b516ab":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const { kForOnEventAttribute, kListener } = farmRequire("75844d1d", true);
    const kCode = Symbol('kCode');
    const kData = Symbol('kData');
    const kError = Symbol('kError');
    const kMessage = Symbol('kMessage');
    const kReason = Symbol('kReason');
    const kTarget = Symbol('kTarget');
    const kType = Symbol('kType');
    const kWasClean = Symbol('kWasClean');
    class Event {
        constructor(type){
            this[kTarget] = null;
            this[kType] = type;
        }
        get target() {
            return this[kTarget];
        }
        get type() {
            return this[kType];
        }
    }
    Object.defineProperty(Event.prototype, 'target', {
        enumerable: true
    });
    Object.defineProperty(Event.prototype, 'type', {
        enumerable: true
    });
    class CloseEvent extends Event {
        constructor(type, options = {}){
            super(type);
            this[kCode] = options.code === undefined ? 0 : options.code;
            this[kReason] = options.reason === undefined ? '' : options.reason;
            this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
        }
        get code() {
            return this[kCode];
        }
        get reason() {
            return this[kReason];
        }
        get wasClean() {
            return this[kWasClean];
        }
    }
    Object.defineProperty(CloseEvent.prototype, 'code', {
        enumerable: true
    });
    Object.defineProperty(CloseEvent.prototype, 'reason', {
        enumerable: true
    });
    Object.defineProperty(CloseEvent.prototype, 'wasClean', {
        enumerable: true
    });
    class ErrorEvent extends Event {
        constructor(type, options = {}){
            super(type);
            this[kError] = options.error === undefined ? null : options.error;
            this[kMessage] = options.message === undefined ? '' : options.message;
        }
        get error() {
            return this[kError];
        }
        get message() {
            return this[kMessage];
        }
    }
    Object.defineProperty(ErrorEvent.prototype, 'error', {
        enumerable: true
    });
    Object.defineProperty(ErrorEvent.prototype, 'message', {
        enumerable: true
    });
    class MessageEvent extends Event {
        constructor(type, options = {}){
            super(type);
            this[kData] = options.data === undefined ? null : options.data;
        }
        get data() {
            return this[kData];
        }
    }
    Object.defineProperty(MessageEvent.prototype, 'data', {
        enumerable: true
    });
    const EventTarget = {
        addEventListener (type, handler, options = {}) {
            for (const listener of this.listeners(type)){
                if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
                    return;
                }
            }
            let wrapper;
            if (type === 'message') {
                wrapper = function onMessage(data, isBinary) {
                    const event = new MessageEvent('message', {
                        data: isBinary ? data : data.toString()
                    });
                    event[kTarget] = this;
                    callListener(handler, this, event);
                };
            } else if (type === 'close') {
                wrapper = function onClose(code, message) {
                    const event = new CloseEvent('close', {
                        code,
                        reason: message.toString(),
                        wasClean: this._closeFrameReceived && this._closeFrameSent
                    });
                    event[kTarget] = this;
                    callListener(handler, this, event);
                };
            } else if (type === 'error') {
                wrapper = function onError(error) {
                    const event = new ErrorEvent('error', {
                        error,
                        message: error.message
                    });
                    event[kTarget] = this;
                    callListener(handler, this, event);
                };
            } else if (type === 'open') {
                wrapper = function onOpen() {
                    const event = new Event('open');
                    event[kTarget] = this;
                    callListener(handler, this, event);
                };
            } else {
                return;
            }
            wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
            wrapper[kListener] = handler;
            if (options.once) {
                this.once(type, wrapper);
            } else {
                this.on(type, wrapper);
            }
        },
        removeEventListener (type, handler) {
            for (const listener of this.listeners(type)){
                if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
                    this.removeListener(type, listener);
                    break;
                }
            }
        }
    };
    module.exports = {
        CloseEvent,
        ErrorEvent,
        Event,
        EventTarget,
        MessageEvent
    };
    function callListener(listener, thisArg, event) {
        if (typeof listener === 'object' && listener.handleEvent) {
            listener.handleEvent.call(listener, event);
        } else {
            listener.call(thisArg, event);
        }
    }
}
,
"447f28ed":/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    var matchHtmlRegExp = /["'&<>]/;
    module.exports = escapeHtml;
    function escapeHtml(string) {
        var str = '' + string;
        var match = matchHtmlRegExp.exec(str);
        if (!match) {
            return str;
        }
        var escape;
        var html = '';
        var index = 0;
        var lastIndex = 0;
        for(index = match.index; index < str.length; index++){
            switch(str.charCodeAt(index)){
                case 34:
                    escape = '&quot;';
                    break;
                case 38:
                    escape = '&amp;';
                    break;
                case 39:
                    escape = '&#39;';
                    break;
                case 60:
                    escape = '&lt;';
                    break;
                case 62:
                    escape = '&gt;';
                    break;
                default:
                    continue;
            }
            if (lastIndex !== index) {
                html += str.substring(lastIndex, index);
            }
            lastIndex = index + 1;
            html += escape;
        }
        return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
    }
}
,
"44b1dcae":function  (module, exports, farmRequire, farmDynamicRequire) {
    var http = global.nodeRequire('http', true), https = global.nodeRequire('https', true), common = farmRequire("eac2581d", true);
    /*!
 * Array of passes.
 *
 * A `pass` is just a function that is executed on `req, socket, options`
 * so that you can easily add new checks while still keeping the base
 * flexible.
 */ module.exports = {
        checkMethodAndHeader: function checkMethodAndHeader(req, socket) {
            if (req.method !== 'GET' || !req.headers.upgrade) {
                socket.destroy();
                return true;
            }
            if (req.headers.upgrade.toLowerCase() !== 'websocket') {
                socket.destroy();
                return true;
            }
        },
        XHeaders: function XHeaders(req, socket, options) {
            if (!options.xfwd) return;
            var values = {
                for: req.connection.remoteAddress || req.socket.remoteAddress,
                port: common.getPort(req),
                proto: common.hasEncryptedConnection(req) ? 'wss' : 'ws'
            };
            [
                'for',
                'port',
                'proto'
            ].forEach(function(header) {
                req.headers['x-forwarded-' + header] = (req.headers['x-forwarded-' + header] || '') + (req.headers['x-forwarded-' + header] ? ',' : '') + values[header];
            });
        },
        stream: function stream(req, socket, options, head, server, clb) {
            var createHttpHeader = function(line, headers) {
                return Object.keys(headers).reduce(function(head, key) {
                    var value = headers[key];
                    if (!Array.isArray(value)) {
                        head.push(key + ': ' + value);
                        return head;
                    }
                    for(var i = 0; i < value.length; i++){
                        head.push(key + ': ' + value[i]);
                    }
                    return head;
                }, [
                    line
                ]).join('\r\n') + '\r\n\r\n';
            };
            common.setupSocket(socket);
            if (head && head.length) socket.unshift(head);
            var proxyReq = (common.isSSL.test(options.target.protocol) ? https : http).request(common.setupOutgoing(options.ssl || {}, options, req));
            if (server) {
                server.emit('proxyReqWs', proxyReq, req, socket, options, head);
            }
            proxyReq.on('error', onOutgoingError);
            proxyReq.on('response', function(res) {
                if (!res.upgrade) {
                    socket.write(createHttpHeader('HTTP/' + res.httpVersion + ' ' + res.statusCode + ' ' + res.statusMessage, res.headers));
                    res.pipe(socket);
                }
            });
            proxyReq.on('upgrade', function(proxyRes, proxySocket, proxyHead) {
                proxySocket.on('error', onOutgoingError);
                proxySocket.on('end', function() {
                    server.emit('close', proxyRes, proxySocket, proxyHead);
                });
                socket.on('error', function() {
                    proxySocket.end();
                });
                common.setupSocket(proxySocket);
                if (proxyHead && proxyHead.length) proxySocket.unshift(proxyHead);
                socket.write(createHttpHeader('HTTP/1.1 101 Switching Protocols', proxyRes.headers));
                proxySocket.pipe(socket).pipe(proxySocket);
                server.emit('open', proxySocket);
                server.emit('proxySocket', proxySocket);
            });
            return proxyReq.end();
            function onOutgoingError(err) {
                if (clb) {
                    clb(err, req, socket);
                } else {
                    server.emit('error', err, req, socket);
                }
                socket.end();
            }
        }
    };
}
,
"44dd1046":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "WebSocket", ()=>module.f(_f_websocket));
    module.o(exports, "WebSocketServer", ()=>module.f(_f_websocket_server));
    farmRequire("83936b24");
    farmRequire("a575bc6d");
    farmRequire("30e626fc");
    var _f_websocket = module.i(farmRequire("e4009425"));
    var _f_websocket_server = module.i(farmRequire("241f157a"));
}
,
"465cd123":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.convertPosixPathToPattern = exports.convertWindowsPathToPattern = exports.convertPathToPattern = exports.escapePosixPath = exports.escapeWindowsPath = exports.escape = exports.removeLeadingDotSegment = exports.makeAbsolute = exports.unixify = void 0;
    const os = global.nodeRequire("os", true);
    const path = global.nodeRequire("path", true);
    const IS_WINDOWS_PLATFORM = os.platform() === 'win32';
    const LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2;
    const POSIX_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\()|\\(?![!()*+?@[\]{|}]))/g;
    const WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()[\]{}]|^!|[!+@](?=\())/g;
    const DOS_DEVICE_PATH_RE = /^\\\\([.?])/;
    const WINDOWS_BACKSLASHES_RE = /\\(?![!()+@[\]{}])/g;
    function unixify(filepath) {
        return filepath.replace(/\\/g, '/');
    }
    exports.unixify = unixify;
    function makeAbsolute(cwd, filepath) {
        return path.resolve(cwd, filepath);
    }
    exports.makeAbsolute = makeAbsolute;
    function removeLeadingDotSegment(entry) {
        if (entry.charAt(0) === '.') {
            const secondCharactery = entry.charAt(1);
            if (secondCharactery === '/' || secondCharactery === '\\') {
                return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
            }
        }
        return entry;
    }
    exports.removeLeadingDotSegment = removeLeadingDotSegment;
    exports.escape = IS_WINDOWS_PLATFORM ? escapeWindowsPath : escapePosixPath;
    function escapeWindowsPath(pattern) {
        return pattern.replace(WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE, '\\$2');
    }
    exports.escapeWindowsPath = escapeWindowsPath;
    function escapePosixPath(pattern) {
        return pattern.replace(POSIX_UNESCAPED_GLOB_SYMBOLS_RE, '\\$2');
    }
    exports.escapePosixPath = escapePosixPath;
    exports.convertPathToPattern = IS_WINDOWS_PLATFORM ? convertWindowsPathToPattern : convertPosixPathToPattern;
    function convertWindowsPathToPattern(filepath) {
        return escapeWindowsPath(filepath).replace(DOS_DEVICE_PATH_RE, '//$1').replace(WINDOWS_BACKSLASHES_RE, '/');
    }
    exports.convertWindowsPathToPattern = convertWindowsPathToPattern;
    function convertPosixPathToPattern(filepath) {
        return escapePosixPath(filepath);
    }
    exports.convertPosixPathToPattern = convertPosixPathToPattern;
}
,
"48aa4d88":/*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    var deprecate = farmRequire("f6eecd34")('http-errors');
    var setPrototypeOf = farmRequire("29f9909f", true);
    var statuses = farmRequire("5be87a60", true);
    var inherits = farmRequire("af1cd816", true);
    var toIdentifier = farmRequire("860853df", true);
    module.exports = createError;
    module.exports.HttpError = createHttpErrorConstructor();
    module.exports.isHttpError = createIsHttpErrorFunction(module.exports.HttpError);
    populateConstructorExports(module.exports, statuses.codes, module.exports.HttpError);
    function codeClass(status) {
        return Number(String(status).charAt(0) + '00');
    }
    function createError() {
        var err;
        var msg;
        var status = 500;
        var props = {};
        for(var i = 0; i < arguments.length; i++){
            var arg = arguments[i];
            if (arg instanceof Error) {
                err = arg;
                status = err.status || err.statusCode || status;
                continue;
            }
            switch(typeof arg){
                case 'string':
                    msg = arg;
                    break;
                case 'number':
                    status = arg;
                    if (i !== 0) {
                        deprecate('non-first-argument status code; replace with createError(' + arg + ', ...)');
                    }
                    break;
                case 'object':
                    props = arg;
                    break;
            }
        }
        if (typeof status === 'number' && (status < 400 || status >= 600)) {
            deprecate('non-error status code; use only 4xx or 5xx status codes');
        }
        if (typeof status !== 'number' || !statuses[status] && (status < 400 || status >= 600)) {
            status = 500;
        }
        var HttpError = createError[status] || createError[codeClass(status)];
        if (!err) {
            err = HttpError ? new HttpError(msg) : new Error(msg || statuses[status]);
            Error.captureStackTrace(err, createError);
        }
        if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
            err.expose = status < 500;
            err.status = err.statusCode = status;
        }
        for(var key in props){
            if (key !== 'status' && key !== 'statusCode') {
                err[key] = props[key];
            }
        }
        return err;
    }
    function createHttpErrorConstructor() {
        function HttpError() {
            throw new TypeError('cannot construct abstract class');
        }
        inherits(HttpError, Error);
        return HttpError;
    }
    function createClientErrorConstructor(HttpError, name, code) {
        var className = toClassName(name);
        function ClientError(message) {
            var msg = message != null ? message : statuses[code];
            var err = new Error(msg);
            Error.captureStackTrace(err, ClientError);
            setPrototypeOf(err, ClientError.prototype);
            Object.defineProperty(err, 'message', {
                enumerable: true,
                configurable: true,
                value: msg,
                writable: true
            });
            Object.defineProperty(err, 'name', {
                enumerable: false,
                configurable: true,
                value: className,
                writable: true
            });
            return err;
        }
        inherits(ClientError, HttpError);
        nameFunc(ClientError, className);
        ClientError.prototype.status = code;
        ClientError.prototype.statusCode = code;
        ClientError.prototype.expose = true;
        return ClientError;
    }
    function createIsHttpErrorFunction(HttpError) {
        return function isHttpError(val) {
            if (!val || typeof val !== 'object') {
                return false;
            }
            if (val instanceof HttpError) {
                return true;
            }
            return val instanceof Error && typeof val.expose === 'boolean' && typeof val.statusCode === 'number' && val.status === val.statusCode;
        };
    }
    function createServerErrorConstructor(HttpError, name, code) {
        var className = toClassName(name);
        function ServerError(message) {
            var msg = message != null ? message : statuses[code];
            var err = new Error(msg);
            Error.captureStackTrace(err, ServerError);
            setPrototypeOf(err, ServerError.prototype);
            Object.defineProperty(err, 'message', {
                enumerable: true,
                configurable: true,
                value: msg,
                writable: true
            });
            Object.defineProperty(err, 'name', {
                enumerable: false,
                configurable: true,
                value: className,
                writable: true
            });
            return err;
        }
        inherits(ServerError, HttpError);
        nameFunc(ServerError, className);
        ServerError.prototype.status = code;
        ServerError.prototype.statusCode = code;
        ServerError.prototype.expose = false;
        return ServerError;
    }
    function nameFunc(func, name) {
        var desc = Object.getOwnPropertyDescriptor(func, 'name');
        if (desc && desc.configurable) {
            desc.value = name;
            Object.defineProperty(func, 'name', desc);
        }
    }
    function populateConstructorExports(exports, codes, HttpError) {
        codes.forEach(function forEachCode(code) {
            var CodeError;
            var name = toIdentifier(statuses[code]);
            switch(codeClass(code)){
                case 400:
                    CodeError = createClientErrorConstructor(HttpError, name, code);
                    break;
                case 500:
                    CodeError = createServerErrorConstructor(HttpError, name, code);
                    break;
            }
            if (CodeError) {
                exports[code] = CodeError;
                exports[name] = CodeError;
            }
        });
        exports["I'mateapot"] = deprecate.function(exports.ImATeapot, '"I\'mateapot"; use "ImATeapot" instead');
    }
    function toClassName(name) {
        return name.substr(-5) !== 'Error' ? name + 'Error' : name;
    }
}
,
"48dceba4":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const path = global.nodeRequire('path', true);
    const win32 = process.platform === 'win32';
    const { REGEX_BACKSLASH, REGEX_REMOVE_BACKSLASH, REGEX_SPECIAL_CHARS, REGEX_SPECIAL_CHARS_GLOBAL } = farmRequire("685edf14", true);
    exports.isObject = (val)=>val !== null && typeof val === 'object' && !Array.isArray(val);
    exports.hasRegexChars = (str)=>REGEX_SPECIAL_CHARS.test(str);
    exports.isRegexChar = (str)=>str.length === 1 && exports.hasRegexChars(str);
    exports.escapeRegex = (str)=>str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1');
    exports.toPosixSlashes = (str)=>str.replace(REGEX_BACKSLASH, '/');
    exports.removeBackslashes = (str)=>{
        return str.replace(REGEX_REMOVE_BACKSLASH, (match)=>{
            return match === '\\' ? '' : match;
        });
    };
    exports.supportsLookbehinds = ()=>{
        const segs = process.version.slice(1).split('.').map(Number);
        if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
            return true;
        }
        return false;
    };
    exports.isWindows = (options)=>{
        if (options && typeof options.windows === 'boolean') {
            return options.windows;
        }
        return win32 === true || path.sep === '\\';
    };
    exports.escapeLast = (input, char, lastIdx)=>{
        const idx = input.lastIndexOf(char, lastIdx);
        if (idx === -1) return input;
        if (input[idx - 1] === '\\') return exports.escapeLast(input, char, idx - 1);
        return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports.removePrefix = (input, state = {})=>{
        let output = input;
        if (output.startsWith('./')) {
            output = output.slice(2);
            state.prefix = './';
        }
        return output;
    };
    exports.wrapOutput = (input, state = {}, options = {})=>{
        const prepend = options.contains ? '' : '^';
        const append = options.contains ? '' : '$';
        let output = `${prepend}(?:${input})${append}`;
        if (state.negated === true) {
            output = `(?:^(?!${output}).*$)`;
        }
        return output;
    };
}
,
"491ca098":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "defineFarmConfig", ()=>defineFarmConfig);
    module.o(exports, "resolveConfig", ()=>resolveConfig);
    module.o(exports, "normalizeUserCompilationConfig", ()=>normalizeUserCompilationConfig);
    module.o(exports, "DEFAULT_HMR_OPTIONS", ()=>DEFAULT_HMR_OPTIONS);
    module.o(exports, "DEFAULT_DEV_SERVER_OPTIONS", ()=>DEFAULT_DEV_SERVER_OPTIONS);
    module.o(exports, "DEFAULT_COMPILATION_OPTIONS", ()=>DEFAULT_COMPILATION_OPTIONS);
    module.o(exports, "normalizeDevServerConfig", ()=>normalizeDevServerConfig);
    module.o(exports, "normalizePublicDir", ()=>normalizePublicDir);
    module.o(exports, "checkClearScreen", ()=>checkClearScreen);
    module.o(exports, "resolveMergedUserConfig", ()=>resolveMergedUserConfig);
    module.o(exports, "loadConfigFile", ()=>loadConfigFile);
    module.o(exports, "getConfigFilePath", ()=>getConfigFilePath);
    module.o(exports, "resolvePlugins", ()=>resolvePlugins);
    var _f_node_crypto = module.i(farmRequire('node:crypto'));
    var _f_node_fs = module.i(farmRequire('node:fs'));
    var _f_node_module = module.i(farmRequire('node:module'));
    var _f_node_path = module.w(farmRequire('node:path'));
    var _f_node_url = farmRequire('node:url');
    var _f_index = farmRequire("1594525d");
    var _f_index1 = farmRequire("ee2469d1");
    var _f_index2 = farmRequire("bd075d6a");
    var _f_index3 = farmRequire("65ad6846");
    var _f_trace_dependencies = farmRequire("16544049");
    var _f__global = farmRequire("93658e5a");
    var _f_env = farmRequire("83b19369");
    var _f_normalize_output = farmRequire("ca85d3ee");
    var _f_normalize_persistent_cache = farmRequire("ff96d815");
    var _f_schema = farmRequire("39f91206");
    var _f_external_adapter = farmRequire("871cfe23");
    var _f_error = farmRequire("eedce71a");
    var _f_merge = module.i(farmRequire("c074a41a"));
    var _f_constants = farmRequire("97f6a66c");
    var _f_mergeConfig = farmRequire("aea2ea19");
    var _f_normalize_asset = farmRequire("e3384cb5");
    var _f_normalize_css = farmRequire("fc3f5f8e");
    var _f_normalize_external = farmRequire("1a581683");
    var _f_normalize_resolve = farmRequire("303b4a27");
    var _f_types = farmRequire("ed98161c");
    module._e(exports, _f_types);
    function defineFarmConfig(config) {
        return config;
    }
    async function getDefaultConfig(config, inlineOptions, mode, logger) {
        logger = logger ?? new _f_index3.Logger();
        const resolvedUserConfig = await resolveMergedUserConfig(config, undefined, inlineOptions.mode ?? mode, logger);
        resolvedUserConfig.server = normalizeDevServerConfig(inlineOptions.server, mode);
        resolvedUserConfig.compilation = await normalizeUserCompilationConfig(resolvedUserConfig, config, logger, mode, true);
        resolvedUserConfig.root = resolvedUserConfig.compilation.root;
        resolvedUserConfig.jsPlugins = [];
        resolvedUserConfig.rustPlugins = [];
        return resolvedUserConfig;
    }
    async function handleServerPortConflict(resolvedUserConfig, logger, mode) {
        try {
            mode !== 'production' && await _f_index2.Server.resolvePortConflict(resolvedUserConfig.server, logger);
        } catch  {}
    }
    async function resolveConfig(inlineOptions = {}, mode, logger, isHandleServerPortConflict = true) {
        checkClearScreen(inlineOptions);
        logger = logger ?? new _f_index3.Logger();
        inlineOptions.mode = inlineOptions.mode ?? mode;
        let { configPath } = inlineOptions;
        let rawConfig = _f_mergeConfig.mergeFarmCliConfig(inlineOptions, {});
        if (configPath) {
            if (!module.f(_f_node_path).isAbsolute(configPath)) {
                throw new Error('configPath must be an absolute path');
            }
            const loadedUserConfig = await loadConfigFile(configPath, inlineOptions, mode, logger);
            if (loadedUserConfig) {
                configPath = loadedUserConfig.configFilePath;
                rawConfig = _f_mergeConfig.mergeConfig(rawConfig, loadedUserConfig.config);
            }
            rawConfig.compilation.mode = loadedUserConfig?.config?.compilation?.mode ?? mode;
        } else {
            _f_mergeConfig.mergeConfig(rawConfig, await getDefaultConfig(rawConfig, inlineOptions, mode, logger));
        }
        const { config: userConfig, configFilePath } = {
            configFilePath: configPath,
            config: rawConfig
        };
        const { jsPlugins, vitePlugins, rustPlugins, vitePluginAdapters } = await resolvePlugins(userConfig, logger, mode);
        const sortFarmJsPlugins = _f_index1.getSortedPlugins([
            ...jsPlugins,
            ...vitePluginAdapters,
            _f_external_adapter.externalAdapter()
        ]);
        const config = await _f_index1.resolveConfigHook(userConfig, sortFarmJsPlugins);
        const mergedUserConfig = _f_mergeConfig.mergeFarmCliConfig(inlineOptions, config);
        const resolvedUserConfig = await resolveMergedUserConfig(mergedUserConfig, configFilePath, inlineOptions.mode ?? mode, logger);
        resolvedUserConfig.server = normalizeDevServerConfig(resolvedUserConfig.server, mode);
        if (isHandleServerPortConflict) {
            await handleServerPortConflict(resolvedUserConfig, logger, mode);
        }
        resolvedUserConfig.compilation = await normalizeUserCompilationConfig(resolvedUserConfig, mergedUserConfig, logger, mode);
        resolvedUserConfig.root = _f_index3.normalizeBasePath(resolvedUserConfig.compilation.root);
        resolvedUserConfig.jsPlugins = sortFarmJsPlugins;
        resolvedUserConfig.rustPlugins = rustPlugins;
        if (vitePlugins.length) {
            resolvedUserConfig.compilation.resolve.alias = _f_index3.getAliasEntries(resolvedUserConfig.compilation.resolve.alias);
        }
        await _f_index1.resolveConfigResolvedHook(resolvedUserConfig, sortFarmJsPlugins);
        if (resolvedUserConfig.compilation?.resolve?.alias && vitePlugins.length) {
            resolvedUserConfig.compilation.resolve.alias = _f_index3.transformAliasWithVite(resolvedUserConfig.compilation.resolve.alias);
        }
        return resolvedUserConfig;
    }
    async function normalizeUserCompilationConfig(resolvedUserConfig, userConfig, logger, mode = 'development', isDefault = false) {
        const { compilation, root = process.cwd(), clearScreen } = resolvedUserConfig;
        const resolvedRootPath = _f_index3.normalizePath(root);
        resolvedUserConfig.root = resolvedRootPath;
        if (!userConfig.compilation) {
            userConfig.compilation = {};
        }
        const inputIndexConfig = !isDefault ? checkCompilationInputValue(userConfig, logger) : {};
        const resolvedCompilation = module.f(_f_merge)({}, DEFAULT_COMPILATION_OPTIONS, {
            input: inputIndexConfig,
            root: resolvedRootPath
        }, {
            clearScreen
        }, compilation);
        const isProduction = mode === 'production';
        const isDevelopment = mode === 'development';
        resolvedCompilation.mode = resolvedCompilation.mode ?? mode;
        resolvedCompilation.coreLibPath = _f_index.bindingPath;
        _f_normalize_output.normalizeOutput(resolvedCompilation, isProduction, logger);
        _f_normalize_external.normalizeExternal(userConfig, resolvedCompilation);
        if (!resolvedCompilation.assets?.publicDir) {
            if (!resolvedCompilation.assets) {
                resolvedCompilation.assets = {};
            }
            const userPublicDir = resolvedUserConfig.publicDir ? resolvedUserConfig.publicDir : _f_node_path.join(resolvedCompilation.root, 'public');
            if (_f_node_path.isAbsolute(userPublicDir)) {
                resolvedCompilation.assets.publicDir = userPublicDir;
            } else {
                resolvedCompilation.assets.publicDir = _f_node_path.join(resolvedCompilation.root, userPublicDir);
            }
        }
        resolvedCompilation.define = Object.assign({
            ['FARM' + '_PROCESS_ENV']: resolvedUserConfig.env,
            "node": JSON.stringify(resolvedCompilation.output?.targetEnv)
        }, resolvedCompilation?.define, resolvedCompilation.output?.targetEnv === 'node' ? {} : Object.keys(resolvedUserConfig.env || {}).reduce((env, key)=>{
            env[`$__farm_regex:(global(This)?\\.)?process\\.env\\.${key}`] = JSON.stringify(resolvedUserConfig.env[key]);
            return env;
        }, {}));
        const require = module.f(_f_node_module).createRequire(module.meta.url);
        const hmrClientPluginPath = require.resolve('@farmfe/runtime-plugin-hmr');
        const ImportMetaPluginPath = require.resolve('@farmfe/runtime-plugin-import-meta');
        if (!resolvedCompilation.runtime) {
            resolvedCompilation.runtime = {
                path: require.resolve('@farmfe/runtime'),
                plugins: []
            };
        }
        if (!resolvedCompilation.runtime.path) {
            resolvedCompilation.runtime.path = require.resolve('@farmfe/runtime');
        }
        if (!resolvedCompilation.runtime.swcHelpersPath) {
            resolvedCompilation.runtime.swcHelpersPath = module.f(_f_node_path).dirname(require.resolve('@swc/helpers/package.json'));
        }
        if (!resolvedCompilation.runtime.plugins) {
            resolvedCompilation.runtime.plugins = [];
        } else {
            resolvedCompilation.runtime.plugins = resolvedCompilation.runtime.plugins.map((plugin)=>{
                if (!module.f(_f_node_path).isAbsolute(plugin)) {
                    if (!plugin.startsWith('.')) {
                        return require.resolve(plugin);
                    } else {
                        return module.f(_f_node_path).resolve(resolvedRootPath, plugin);
                    }
                }
                return plugin;
            });
        }
        if (!resolvedCompilation.runtime.namespace) {
            const packageJsonPath = module.f(_f_node_path).resolve(resolvedRootPath, 'package.json');
            const packageJsonExists = module.f(_f_node_fs).existsSync(packageJsonPath);
            const namespaceName = packageJsonExists ? JSON.parse(module.f(_f_node_fs).readFileSync(packageJsonPath, {
                encoding: 'utf-8'
            }))?.name ?? _f_constants.FARM_DEFAULT_NAMESPACE : _f_constants.FARM_DEFAULT_NAMESPACE;
            resolvedCompilation.runtime.namespace = module.f(_f_node_crypto).createHash('md5').update(namespaceName).digest('hex');
        }
        if (isProduction) {
            resolvedCompilation.lazyCompilation = false;
        } else if (resolvedCompilation.lazyCompilation === undefined) {
            if (isDevelopment) {
                resolvedCompilation.lazyCompilation = true;
            } else {
                resolvedCompilation.lazyCompilation = false;
            }
        }
        if (resolvedCompilation.mode === undefined) {
            resolvedCompilation.mode = mode;
        }
        _f_env.setProcessEnv(resolvedCompilation.mode);
        if (resolvedCompilation.output.targetEnv !== 'node' && _f_index3.isArray(resolvedCompilation.runtime.plugins) && resolvedUserConfig.server?.hmr && !resolvedCompilation.runtime.plugins.includes(hmrClientPluginPath)) {
            const publicPath = _f_normalize_output.getValidPublicPath(resolvedCompilation.output.publicPath);
            const serverOptions = resolvedUserConfig.server;
            const defineHmrPath = _f_index3.normalizeBasePath(module.f(_f_node_path).join(publicPath, resolvedUserConfig.server.hmr.path));
            resolvedCompilation.runtime.plugins.push(hmrClientPluginPath);
            resolvedCompilation.define.FARM_HMR_PORT = String((serverOptions.hmr.port || undefined) ?? serverOptions.port ?? DEFAULT_DEV_SERVER_OPTIONS.port);
            resolvedCompilation.define.FARM_HMR_HOST = JSON.stringify(resolvedUserConfig.server.hmr.host);
            resolvedCompilation.define.FARM_HMR_PROTOCOL = JSON.stringify(resolvedUserConfig.server.hmr.protocol);
            resolvedCompilation.define.FARM_HMR_PATH = JSON.stringify(defineHmrPath);
        }
        if (_f_index3.isArray(resolvedCompilation.runtime.plugins) && !resolvedCompilation.runtime.plugins.includes(ImportMetaPluginPath)) {
            resolvedCompilation.runtime.plugins.push(ImportMetaPluginPath);
        }
        if (compilation?.input && Object.keys(compilation.input).length > 0) {
            const input = {};
            for (const [key, value] of Object.entries(compilation.input)){
                if (!value && (value ?? true)) continue;
                if (!module.f(_f_node_path).isAbsolute(value) && !value.startsWith('./')) {
                    input[key] = `./${value}`;
                } else {
                    input[key] = value;
                }
            }
            resolvedCompilation.input = input;
        }
        if (resolvedCompilation.treeShaking === undefined) {
            if (isProduction) {
                resolvedCompilation.treeShaking = true;
            } else {
                resolvedCompilation.treeShaking = false;
            }
        }
        if (resolvedCompilation.script?.plugins?.length) {
            logger.info(`Swc plugins are configured, note that Farm uses ${_f_index3.colors.yellow('swc_core v0.96')}, please make sure the plugin is ${_f_index3.colors.green('compatible')} with swc_core ${_f_index3.colors.yellow('swc_core v0.96')}. Otherwise, it may exit unexpectedly.`);
        }
        if (resolvedCompilation.treeShaking && resolvedCompilation.lazyCompilation) {
            logger.error('treeShaking option is not supported in lazyCompilation mode, lazyCompilation will be disabled.');
            resolvedCompilation.lazyCompilation = false;
        }
        if (resolvedCompilation.minify === undefined) {
            if (isProduction) {
                resolvedCompilation.minify = true;
            } else {
                resolvedCompilation.minify = false;
            }
        }
        if (resolvedCompilation.presetEnv === undefined) {
            if (isProduction) {
                resolvedCompilation.presetEnv = true;
            } else {
                resolvedCompilation.presetEnv = false;
            }
        }
        resolvedCompilation.custom = {
            ...resolvedCompilation.custom || {},
            [_f_constants.CUSTOM_KEYS.runtime_isolate]: `${!!resolvedCompilation.runtime.isolate}`
        };
        if (resolvedCompilation.script?.decorators !== undefined) if (resolvedCompilation.script.parser === undefined) {
            resolvedCompilation.script.parser = {
                esConfig: {
                    decorators: true
                },
                tsConfig: {
                    decorators: true
                }
            };
        } else {
            if (resolvedCompilation.script.parser.esConfig !== undefined) resolvedCompilation.script.parser.esConfig.decorators = true;
            else resolvedCompilation.script.parser.esConfig = {
                decorators: true
            };
            if (resolvedCompilation.script.parser.tsConfig !== undefined) resolvedCompilation.script.parser.tsConfig.decorators = true;
            else userConfig.compilation.script.parser.tsConfig = {
                decorators: true
            };
        }
        await _f_normalize_persistent_cache.normalizePersistentCache(resolvedCompilation, resolvedUserConfig, logger);
        _f_normalize_resolve.normalizeResolve(userConfig, resolvedCompilation);
        _f_normalize_css.normalizeCss(userConfig, resolvedCompilation);
        _f_normalize_asset.normalizeAsset(userConfig, resolvedCompilation);
        return resolvedCompilation;
    }
    var DEFAULT_HMR_OPTIONS = {
        host: true,
        port: (process.env.FARM_DEFAULT_HMR_PORT && Number(process.env.FARM_DEFAULT_HMR_PORT)) ?? undefined,
        path: '/__hmr',
        overlay: true,
        protocol: '',
        watchOptions: {}
    };
    var DEFAULT_DEV_SERVER_OPTIONS = {
        headers: {},
        port: process.env.FARM_DEFAULT_SERVER_PORT && Number(process.env.FARM_DEFAULT_SERVER_PORT) || 9000,
        https: undefined,
        protocol: 'http',
        hostname: {
            name: 'localhost',
            host: undefined
        },
        allowedHosts: [],
        host: true,
        proxy: {},
        hmr: DEFAULT_HMR_OPTIONS,
        open: false,
        strictPort: false,
        cors: false,
        spa: true,
        middlewares: [],
        writeToDisk: false
    };
    var DEFAULT_COMPILATION_OPTIONS = {
        output: {
            path: './dist'
        },
        sourcemap: true,
        resolve: {
            extensions: [
                'tsx',
                'mts',
                'cts',
                'ts',
                'jsx',
                'mjs',
                'js',
                'cjs',
                'json',
                'html',
                'css',
                'mts',
                'cts'
            ]
        }
    };
    function tryAsFileRead(value) {
        if (typeof value === 'string' && module.f(_f_node_fs).existsSync(value)) {
            return module.f(_f_node_fs).readFileSync(module.f(_f_node_path).resolve(value.toString()));
        }
        return value;
    }
    function normalizeDevServerConfig(options, mode) {
        const { host, port, hmr: hmrConfig, https } = options || {};
        const isProductionMode = mode === 'production';
        const hmr = isProductionMode || hmrConfig === false ? false : module.f(_f_merge)({}, DEFAULT_HMR_OPTIONS, {
            host: host ?? DEFAULT_DEV_SERVER_OPTIONS.host,
            port: port ?? DEFAULT_DEV_SERVER_OPTIONS.port
        }, hmrConfig === true ? {} : hmrConfig);
        return module.f(_f_merge)({}, DEFAULT_DEV_SERVER_OPTIONS, options, {
            hmr,
            https: https ? {
                ...https,
                ca: tryAsFileRead(options.https.ca),
                cert: tryAsFileRead(options.https.cert),
                key: tryAsFileRead(options.https.key),
                pfx: tryAsFileRead(options.https.pfx)
            } : undefined
        });
    }
    const formatFromExt = {
        cjs: 'cjs',
        mjs: 'esm',
        cts: 'cjs',
        mts: 'esm',
        js: 'esm'
    };
    const formatToExt = {
        cjs: 'cjs',
        esm: 'mjs'
    };
    async function readConfigFile(inlineOptions, configFilePath, logger, mode = 'development') {
        if (module.f(_f_node_fs).existsSync(configFilePath)) {
            !_f__global.__FARM_GLOBAL__.__FARM_RESTART_DEV_SERVER__ && logger.info(`Using config file at ${_f_index3.bold(_f_index3.green(configFilePath))}`);
            const format = process.env.FARM_CONFIG_FORMAT ? process.env.FARM_CONFIG_FORMAT === 'cjs' ? 'cjs' : 'esm' : formatFromExt[module.f(_f_node_path).extname(configFilePath).slice(1)] ?? 'esm';
            const Compiler = (await farmDynamicRequire("bf50199b")).Compiler;
            const outputPath = module.f(_f_node_path).join(module.f(_f_node_path).dirname(configFilePath), 'node_modules', '.farm');
            const fileName = `farm.config.bundle-${Date.now()}-${Math.random().toString(16).split('.').join('')}.${formatToExt[format]}`;
            const tsDefaultUserConfig = {
                root: inlineOptions.root,
                compilation: {
                    input: {
                        [fileName]: configFilePath
                    },
                    output: {
                        entryFilename: '[entryName]',
                        path: outputPath,
                        format,
                        targetEnv: 'library-node'
                    },
                    external: [
                        ...process.env.FARM_CONFIG_FULL_BUNDLE ? [] : [
                            '!^(\\./|\\.\\./|[A-Za-z]:\\\\|/).*'
                        ],
                        '^@farmfe/core$'
                    ],
                    partialBundling: {
                        enforceResources: [
                            {
                                name: fileName,
                                test: [
                                    '.+'
                                ]
                            }
                        ]
                    },
                    watch: false,
                    sourcemap: false,
                    treeShaking: false,
                    minify: false,
                    presetEnv: false,
                    lazyCompilation: false,
                    persistentCache: false,
                    progress: false
                }
            };
            const tsDefaultResolvedUserConfig = await resolveMergedUserConfig(tsDefaultUserConfig, undefined, mode, logger);
            const normalizedConfig = await normalizeUserCompilationConfig(tsDefaultResolvedUserConfig, tsDefaultUserConfig, logger, mode);
            const replaceDirnamePlugin = await farmDynamicRequire("1f8eda05").then((mod)=>mod.default);
            const compiler = new Compiler({
                config: normalizedConfig,
                jsPlugins: [],
                rustPlugins: [
                    [
                        replaceDirnamePlugin,
                        '{}'
                    ]
                ]
            }, logger);
            const FARM_PROFILE = process.env.FARM_PROFILE;
            if (FARM_PROFILE) {
                process.env.FARM_PROFILE = '';
            }
            await compiler.compile();
            if (FARM_PROFILE) {
                process.env.FARM_PROFILE = FARM_PROFILE;
            }
            compiler.writeResourcesToDisk();
            const filePath = _f_index3.isWindows ? _f_node_url.pathToFileURL(module.f(_f_node_path).join(outputPath, fileName)) : module.f(_f_node_path).join(outputPath, fileName);
            const userConfig = (await import(filePath)).default;
            try {
                module.f(_f_node_fs).unlink(filePath, ()=>void 0);
                const isEmpty = module.f(_f_node_fs).readdirSync(outputPath).length === 0;
                if (isEmpty) {
                    module.f(_f_node_fs).rmSync(outputPath);
                }
            } catch  {}
            const configEnv = {
                mode: inlineOptions.mode ?? process.env.NODE_ENV
            };
            const config = await (typeof userConfig === 'function' ? userConfig(configEnv) : userConfig);
            if (!config.root) {
                config.root = inlineOptions.root;
            }
            if (!_f_index3.isObject(config)) {
                throw new Error(`config must export or return an object.`);
            }
            return config;
        }
    }
    function normalizePublicDir(root, userPublicDir) {
        const publicDir = userPublicDir ?? 'public';
        const absPublicDirPath = module.f(_f_node_path).isAbsolute(publicDir) ? publicDir : module.f(_f_node_path).join(root, publicDir);
        return absPublicDirPath;
    }
    function checkClearScreen(inlineConfig) {
        if (inlineConfig?.clearScreen && !_f__global.__FARM_GLOBAL__.__FARM_RESTART_DEV_SERVER__) {
            _f_index3.clearScreen();
        }
    }
    async function resolveMergedUserConfig(mergedUserConfig, configFilePath, mode, logger = new _f_index3.Logger()) {
        const resolvedUserConfig = {
            ...mergedUserConfig,
            compilation: {
                ...mergedUserConfig.compilation,
                external: []
            }
        };
        resolvedUserConfig.envMode = mode;
        if (configFilePath) {
            const dependencies = await _f_trace_dependencies.traceDependencies(configFilePath, logger);
            dependencies.sort();
            resolvedUserConfig.configFileDependencies = dependencies;
            resolvedUserConfig.configFilePath = configFilePath;
        }
        const resolvedRootPath = resolvedUserConfig.root ?? process.cwd();
        const resolvedEnvPath = resolvedUserConfig.envDir ? resolvedUserConfig.envDir : resolvedRootPath;
        const userEnv = _f_env.loadEnv(resolvedUserConfig.envMode ?? mode, resolvedEnvPath, resolvedUserConfig.envPrefix);
        const existsEnvFiles = _f_env.getExistsEnvFiles(resolvedUserConfig.envMode ?? mode, resolvedEnvPath);
        resolvedUserConfig.envFiles = [
            ...Array.isArray(resolvedUserConfig.envFiles) ? resolvedUserConfig.envFiles : [],
            ...existsEnvFiles
        ];
        resolvedUserConfig.env = {
            ...userEnv,
            NODE_ENV: mergedUserConfig.compilation.mode ?? mode,
            mode: mode
        };
        return resolvedUserConfig;
    }
    async function loadConfigFile(configPath, inlineOptions, mode = 'development', logger = new _f_index3.Logger()) {
        try {
            const configFilePath = await getConfigFilePath(configPath);
            if (configFilePath) {
                const config = await readConfigFile(inlineOptions, configFilePath, logger, mode);
                return {
                    config: config && _f_schema.parseUserConfig(config),
                    configFilePath: configFilePath
                };
            }
        } catch (error) {
            const errorMessage = _f_error.convertErrorMessage(error);
            const stackTrace = error.code === 'GenericFailure' ? '' : `\n${error.stack}`;
            if (inlineOptions.mode === 'production') {
                logger.error(`Failed to load config file: ${errorMessage} \n${stackTrace}`, {
                    exit: true
                });
            }
            const potentialSolution = 'Potential solutions: \n1. Try set `FARM_CONFIG_FORMAT=cjs`(default to esm)\n2. Try set `FARM_CONFIG_FULL_BUNDLE=1`';
            throw new Error(`Failed to load farm config file: ${errorMessage}. \n ${potentialSolution} \n ${error.stack}`);
        }
    }
    function checkCompilationInputValue(userConfig, logger) {
        const { compilation } = userConfig;
        const targetEnv = compilation?.output?.targetEnv;
        const isTargetNode = _f_index3.isNodeEnv(targetEnv);
        const defaultHtmlPath = './index.html';
        let inputIndexConfig = {
            index: ''
        };
        let errorMessage = '';
        if (!_f_index3.isEmptyObject(compilation?.input)) {
            inputIndexConfig = compilation?.input;
        } else {
            if (isTargetNode) {
                const entryFiles = [
                    './index.js',
                    './index.ts'
                ];
                for (const entryFile of entryFiles){
                    try {
                        if (module.f(_f_node_fs).statSync(module.f(_f_node_path).resolve(userConfig?.root, entryFile))) {
                            inputIndexConfig = {
                                index: entryFile
                            };
                            break;
                        }
                    } catch (error) {
                        errorMessage = error.stack;
                    }
                }
            } else {
                try {
                    if (module.f(_f_node_fs).statSync(module.f(_f_node_path).resolve(userConfig?.root, defaultHtmlPath))) {
                        inputIndexConfig = {
                            index: defaultHtmlPath
                        };
                    }
                } catch (error) {
                    errorMessage = error.stack;
                }
            }
            if (!inputIndexConfig.index) {
                logger.error(`Build failed due to errors: Can not resolve ${isTargetNode ? 'index.js or index.ts' : 'index.html'}  from ${userConfig.root}. \n${errorMessage}`, {
                    exit: true
                });
            }
        }
        return inputIndexConfig;
    }
    async function getConfigFilePath(configPath) {
        if (module.f(_f_node_fs).statSync(configPath).isDirectory()) {
            for (const name of _f_constants.DEFAULT_CONFIG_NAMES){
                const resolvedPath = module.f(_f_node_path).join(configPath, name);
                const isFile = module.f(_f_node_fs).existsSync(resolvedPath) && module.f(_f_node_fs).statSync(resolvedPath).isFile();
                if (isFile) {
                    return resolvedPath;
                }
            }
        } else if (module.f(_f_node_fs).statSync(configPath).isFile()) {
            return configPath;
        }
        return undefined;
    }
    async function resolvePlugins(userConfig, logger, mode) {
        const { jsPlugins, rustPlugins } = await _f_index1.resolveFarmPlugins(userConfig);
        const rawJsPlugins = (await _f_index1.resolveAsyncPlugins(jsPlugins || [])).filter(Boolean);
        let vitePluginAdapters = [];
        const vitePlugins = (userConfig?.vitePlugins ?? []).filter(Boolean);
        if (vitePlugins.length) {
            vitePluginAdapters = await _f_index1.handleVitePlugins(vitePlugins, userConfig, logger, mode);
        }
        return {
            jsPlugins: rawJsPlugins,
            vitePlugins,
            rustPlugins,
            vitePluginAdapters
        };
    }
}
,
"49576d3a":function  (module, exports, farmRequire, farmDynamicRequire) {
    module.exports = isexe;
    isexe.sync = sync;
    var fs = global.nodeRequire('fs', true);
    function checkPathExt(path, options) {
        var pathext = options.pathExt !== undefined ? options.pathExt : process.env.PATHEXT;
        if (!pathext) {
            return true;
        }
        pathext = pathext.split(';');
        if (pathext.indexOf('') !== -1) {
            return true;
        }
        for(var i = 0; i < pathext.length; i++){
            var p = pathext[i].toLowerCase();
            if (p && path.substr(-p.length).toLowerCase() === p) {
                return true;
            }
        }
        return false;
    }
    function checkStat(stat, path, options) {
        if (!stat.isSymbolicLink() && !stat.isFile()) {
            return false;
        }
        return checkPathExt(path, options);
    }
    function isexe(path, options, cb) {
        fs.stat(path, function(er, stat) {
            cb(er, er ? false : checkStat(stat, path, options));
        });
    }
    function sync(path, options) {
        return checkStat(fs.statSync(path), path, options);
    }
}
,
"49b4df4f":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "cssUrlRE", ()=>cssUrlRE);
    module.o(exports, "cssDataUriRE", ()=>cssDataUriRE);
    module.o(exports, "importCssRE", ()=>importCssRE);
    module.o(exports, "rebaseUrls", ()=>rebaseUrls);
    module.o(exports, "externalRE", ()=>externalRE);
    module.o(exports, "isExternalUrl", ()=>isExternalUrl);
    module.o(exports, "dataUrlRE", ()=>dataUrlRE);
    module.o(exports, "isDataUrl", ()=>isDataUrl);
    var _f_node_path = module.i(farmRequire('node:path'));
    var _f_fs_extra = module.i(farmRequire("77e37188"));
    var _f_share = farmRequire("bc6cc539");
    const nonEscapedDoubleQuoteRe = /(?<!\\)(")/g;
    var cssUrlRE = /(?<=^|[^\w\-\u0080-\uffff])url\((\s*('[^']+'|"[^"]+")\s*|[^'")]+)\)/;
    var cssDataUriRE = /(?<=^|[^\w\-\u0080-\uffff])data-uri\((\s*('[^']+'|"[^"]+")\s*|[^'")]+)\)/;
    var importCssRE = /@import ('[^']+\.css'|"[^"]+\.css"|[^'")]+\.css)/;
    const functionCallRE = /^[A-Z_][\w-]*\(/i;
    async function rebaseUrls(file, rootFile, variablePrefix, resolver) {
        file = module.f(_f_node_path).resolve(file);
        const fileDir = module.f(_f_node_path).dirname(file);
        const rootDir = module.f(_f_node_path).dirname(rootFile);
        if (fileDir === rootDir) {
            return {
                file
            };
        }
        const content = await module.f(_f_fs_extra).readFile(file, 'utf-8');
        const hasUrls = cssUrlRE.test(content);
        const hasDataUris = cssDataUriRE.test(content);
        const hasImportCss = importCssRE.test(content);
        if (!hasUrls && !hasDataUris && !hasImportCss) {
            return {
                file
            };
        }
        let rebased;
        const rebaseFn = async (url)=>{
            if (url[0] === '/') return url;
            if (url.startsWith(variablePrefix)) return url;
            const absolute = await resolver(url, file) || module.f(_f_node_path).resolve(fileDir, url);
            const relative = module.f(_f_node_path).relative(rootDir, absolute);
            return _f_share.normalizeBasePath(relative);
        };
        if (hasImportCss) {
            rebased = await rewriteImportCss(content, rebaseFn);
        }
        if (hasUrls) {
            rebased = await rewriteCssUrls(rebased || content, rebaseFn);
        }
        if (hasDataUris) {
            rebased = await rewriteCssDataUris(rebased || content, rebaseFn);
        }
        return {
            file,
            contents: rebased
        };
    }
    function rewriteImportCss(css, replacer) {
        return asyncReplace(css, importCssRE, async (match)=>{
            const [matched, rawUrl] = match;
            return await doImportCSSReplace(rawUrl, matched, replacer);
        });
    }
    function rewriteCssUrls(css, replacer) {
        return asyncReplace(css, cssUrlRE, async (match)=>{
            const [matched, rawUrl] = match;
            return await doUrlReplace(rawUrl.trim(), matched, replacer);
        });
    }
    function rewriteCssDataUris(css, replacer) {
        return asyncReplace(css, cssDataUriRE, async (match)=>{
            const [matched, rawUrl] = match;
            return await doUrlReplace(rawUrl.trim(), matched, replacer, 'data-uri');
        });
    }
    function skipUrlReplacer(rawUrl) {
        return isExternalUrl(rawUrl) || isDataUrl(rawUrl) || rawUrl[0] === '#' || functionCallRE.test(rawUrl);
    }
    async function doUrlReplace(rawUrl, matched, replacer, funcName = 'url') {
        let wrap = '';
        const first = rawUrl[0];
        if (first === `"` || first === `'`) {
            wrap = first;
            rawUrl = rawUrl.slice(1, -1);
        }
        if (skipUrlReplacer(rawUrl)) {
            return matched;
        }
        let newUrl = await replacer(rawUrl);
        if (wrap === '' && newUrl !== encodeURI(newUrl)) {
            wrap = '"';
        }
        if (wrap === "'" && newUrl.includes("'")) {
            wrap = '"';
        }
        if (wrap === '"' && newUrl.includes('"')) {
            newUrl = newUrl.replace(nonEscapedDoubleQuoteRe, '\\"');
        }
        return `${funcName}(${wrap}${newUrl}${wrap})`;
    }
    async function doImportCSSReplace(rawUrl, matched, replacer) {
        let wrap = '';
        const first = rawUrl[0];
        if (first === `"` || first === `'`) {
            wrap = first;
            rawUrl = rawUrl.slice(1, -1);
        }
        if (isExternalUrl(rawUrl) || isDataUrl(rawUrl) || rawUrl[0] === '#') {
            return matched;
        }
        return `@import ${wrap}${await replacer(rawUrl)}${wrap}`;
    }
    async function asyncReplace(input, re, replacer) {
        let match;
        let remaining = input;
        let rewritten = '';
        while(match = re.exec(remaining)){
            rewritten += remaining.slice(0, match.index);
            rewritten += await replacer(match);
            remaining = remaining.slice(match.index + match[0].length);
        }
        rewritten += remaining;
        return rewritten;
    }
    var externalRE = /^(https?:)?\/\//;
    var isExternalUrl = (url)=>externalRE.test(url);
    var dataUrlRE = /^\s*data:/i;
    var isDataUrl = (url)=>dataUrlRE.test(url);
}
,
"49dab30c":function  (module, exports, farmRequire, farmDynamicRequire) {
    var httpNative = global.nodeRequire('http', true), httpsNative = global.nodeRequire('https', true), web_o = farmRequire("0d2d0a9a", true), common = farmRequire("eac2581d", true), followRedirects = farmRequire("8984add7", true);
    web_o = Object.keys(web_o).map(function(pass) {
        return web_o[pass];
    });
    var nativeAgents = {
        http: httpNative,
        https: httpsNative
    };
    /*!
 * Array of passes.
 *
 * A `pass` is just a function that is executed on `req, res, options`
 * so that you can easily add new checks while still keeping the base
 * flexible.
 */ module.exports = {
        deleteLength: function deleteLength(req, res, options) {
            if ((req.method === 'DELETE' || req.method === 'OPTIONS') && !req.headers['content-length']) {
                req.headers['content-length'] = '0';
                delete req.headers['transfer-encoding'];
            }
        },
        timeout: function timeout(req, res, options) {
            if (options.timeout) {
                req.socket.setTimeout(options.timeout);
            }
        },
        XHeaders: function XHeaders(req, res, options) {
            if (!options.xfwd) return;
            var encrypted = req.isSpdy || common.hasEncryptedConnection(req);
            var values = {
                for: req.connection.remoteAddress || req.socket.remoteAddress,
                port: common.getPort(req),
                proto: encrypted ? 'https' : 'http'
            };
            [
                'for',
                'port',
                'proto'
            ].forEach(function(header) {
                req.headers['x-forwarded-' + header] = (req.headers['x-forwarded-' + header] || '') + (req.headers['x-forwarded-' + header] ? ',' : '') + values[header];
            });
            req.headers['x-forwarded-host'] = req.headers['x-forwarded-host'] || req.headers['host'] || '';
        },
        stream: function stream(req, res, options, _, server, clb) {
            server.emit('start', req, res, options.target || options.forward);
            var agents = options.followRedirects ? followRedirects : nativeAgents;
            var http = agents.http;
            var https = agents.https;
            if (options.forward) {
                var forwardReq = (options.forward.protocol === 'https:' ? https : http).request(common.setupOutgoing(options.ssl || {}, options, req, 'forward'));
                var forwardError = createErrorHandler(forwardReq, options.forward);
                req.on('error', forwardError);
                forwardReq.on('error', forwardError);
                (options.buffer || req).pipe(forwardReq);
                if (!options.target) {
                    return res.end();
                }
            }
            var proxyReq = (options.target.protocol === 'https:' ? https : http).request(common.setupOutgoing(options.ssl || {}, options, req));
            proxyReq.on('socket', function(socket) {
                if (server && !proxyReq.getHeader('expect')) {
                    server.emit('proxyReq', proxyReq, req, res, options);
                }
            });
            if (options.proxyTimeout) {
                proxyReq.setTimeout(options.proxyTimeout, function() {
                    proxyReq.abort();
                });
            }
            req.on('aborted', function() {
                proxyReq.abort();
            });
            var proxyError = createErrorHandler(proxyReq, options.target);
            req.on('error', proxyError);
            proxyReq.on('error', proxyError);
            function createErrorHandler(proxyReq, url) {
                return function proxyError(err) {
                    if (req.socket.destroyed && err.code === 'ECONNRESET') {
                        server.emit('econnreset', err, req, res, url);
                        return proxyReq.abort();
                    }
                    if (clb) {
                        clb(err, req, res, url);
                    } else {
                        server.emit('error', err, req, res, url);
                    }
                };
            }
            (options.buffer || req).pipe(proxyReq);
            proxyReq.on('response', function(proxyRes) {
                if (server) {
                    server.emit('proxyRes', proxyRes, req, res);
                }
                if (!res.headersSent && !options.selfHandleResponse) {
                    for(var i = 0; i < web_o.length; i++){
                        if (web_o[i](req, res, proxyRes, options)) {
                            break;
                        }
                    }
                }
                if (!res.finished) {
                    proxyRes.on('end', function() {
                        if (server) server.emit('end', req, res, proxyRes);
                    });
                    if (!options.selfHandleResponse) proxyRes.pipe(res);
                } else {
                    if (server) server.emit('end', req, res, proxyRes);
                }
            });
        }
    };
}
,
"4a5b9174":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const u = farmRequire("712c2dd4", true).fromCallback;
    module.exports = {
        move: u(farmRequire("1514df7a")),
        moveSync: farmRequire("c834c407", true)
    };
}
,
"4ac23bc0":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const { constants: BufferConstants } = global.nodeRequire('buffer', true);
    const stream = global.nodeRequire('stream', true);
    const { promisify } = global.nodeRequire('util', true);
    const bufferStream = farmRequire("8c96cd12", true);
    const streamPipelinePromisified = promisify(stream.pipeline);
    class MaxBufferError extends Error {
        constructor(){
            super('maxBuffer exceeded');
            this.name = 'MaxBufferError';
        }
    }
    async function getStream(inputStream, options) {
        if (!inputStream) {
            throw new Error('Expected a stream');
        }
        options = {
            maxBuffer: Infinity,
            ...options
        };
        const { maxBuffer } = options;
        const stream = bufferStream(options);
        await new Promise((resolve, reject)=>{
            const rejectPromise = (error)=>{
                if (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
                    error.bufferedData = stream.getBufferedValue();
                }
                reject(error);
            };
            (async ()=>{
                try {
                    await streamPipelinePromisified(inputStream, stream);
                    resolve();
                } catch (error) {
                    rejectPromise(error);
                }
            })();
            stream.on('data', ()=>{
                if (stream.getBufferedLength() > maxBuffer) {
                    rejectPromise(new MaxBufferError());
                }
            });
        });
        return stream.getBufferedValue();
    }
    module.exports = getStream;
    module.exports.buffer = (stream, options)=>getStream(stream, {
            ...options,
            encoding: 'buffer'
        });
    module.exports.array = (stream, options)=>getStream(stream, {
            ...options,
            array: true
        });
    module.exports.MaxBufferError = MaxBufferError;
}
,
"4af6935d":/*!
 * depd
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    var EventEmitter = global.nodeRequire('events', true).EventEmitter;
    lazyProperty(module.exports, 'callSiteToString', function callSiteToString() {
        var limit = Error.stackTraceLimit;
        var obj = {};
        var prep = Error.prepareStackTrace;
        function prepareObjectStackTrace(obj, stack) {
            return stack;
        }
        Error.prepareStackTrace = prepareObjectStackTrace;
        Error.stackTraceLimit = 2;
        Error.captureStackTrace(obj);
        var stack = obj.stack.slice();
        Error.prepareStackTrace = prep;
        Error.stackTraceLimit = limit;
        return stack[0].toString ? toString : farmRequire("e4d98328", true);
    });
    lazyProperty(module.exports, 'eventListenerCount', function eventListenerCount() {
        return EventEmitter.listenerCount || farmRequire("89dda374", true);
    });
    function lazyProperty(obj, prop, getter) {
        function get() {
            var val = getter();
            Object.defineProperty(obj, prop, {
                configurable: true,
                enumerable: true,
                value: val
            });
            return val;
        }
        Object.defineProperty(obj, prop, {
            configurable: true,
            enumerable: true,
            get: get
        });
    }
    function toString(obj) {
        return obj.toString();
    }
}
,
"4bbd2bcd":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "useProxy", ()=>useProxy);
    module.o(exports, "proxy", ()=>proxy);
    var _f_http_proxy_middleware = farmRequire("d8312835");
    function useProxy(options, devSeverContext, logger) {
        const proxyOption = options['proxy'];
        for (const path of Object.keys(proxyOption)){
            let opts = proxyOption[path];
            if (typeof opts === 'string') {
                opts = {
                    target: opts,
                    changeOrigin: true
                };
            }
            const proxyMiddleware = _f_http_proxy_middleware.createProxyMiddleware(opts);
            const server = devSeverContext.server;
            const hmrOptions = options.hmr;
            if (server) {
                server.on('upgrade', (req, socket, head)=>{
                    if (req.url === hmrOptions.path) return;
                    for(const path in options.proxy){
                        const opts = proxyOption[path];
                        if (opts.ws || opts.target?.toString().startsWith('ws:') || opts.target?.toString().startsWith('wss:')) {
                            const proxy = _f_http_proxy_middleware.createProxyMiddleware(opts);
                            if (opts.pathRewrite) {
                                const fromPath = Object.keys(opts.pathRewrite)[0];
                                const toPath = opts.pathRewrite[fromPath];
                                req.url = rewritePath(req.url, fromPath, toPath);
                            }
                            proxy.upgrade(req, socket, head);
                            return;
                        }
                    }
                });
            }
            const errorHandlerMiddleware = async (ctx, next)=>{
                try {
                    await new Promise((resolve, reject)=>{
                        proxyMiddleware(ctx.req, ctx.res, (err)=>{
                            if (err) {
                                reject(err);
                            } else {
                                resolve();
                            }
                        });
                    });
                    await next();
                } catch (err) {
                    logger.error(`Error in proxy for path ${path}: \n ${err.stack}`);
                }
            };
            try {
                if (path.length > 0) {
                    const pathRegex = new RegExp(path);
                    const app = devSeverContext.app();
                    app.use((ctx, next)=>{
                        if (pathRegex.test(ctx.path)) {
                            return errorHandlerMiddleware(ctx, next);
                        }
                        return next();
                    });
                }
            } catch (err) {
                logger.error(`Error setting proxy for path ${path}: \n ${err.stack}`);
            }
        }
    }
    function proxy(devSeverContext) {
        const { config, logger } = devSeverContext;
        if (!config.proxy) {
            return;
        }
        useProxy(config, devSeverContext, logger);
    }
    function rewritePath(path, fromPath, toPath) {
        if (fromPath instanceof RegExp) {
            return path.replace(fromPath, toPath);
        } else {
            return path.replace(new RegExp(fromPath), toPath);
        }
    }
}
,
"4cd3082d":function  (module, exports, farmRequire, farmDynamicRequire) {
    const vary = farmRequire("372df827", true);
    module.exports = function(options) {
        const defaults = {
            allowMethods: 'GET,HEAD,PUT,POST,DELETE,PATCH',
            secureContext: false
        };
        options = {
            ...defaults,
            ...options
        };
        if (Array.isArray(options.exposeHeaders)) {
            options.exposeHeaders = options.exposeHeaders.join(',');
        }
        if (Array.isArray(options.allowMethods)) {
            options.allowMethods = options.allowMethods.join(',');
        }
        if (Array.isArray(options.allowHeaders)) {
            options.allowHeaders = options.allowHeaders.join(',');
        }
        if (options.maxAge) {
            options.maxAge = String(options.maxAge);
        }
        options.keepHeadersOnError = options.keepHeadersOnError === undefined || !!options.keepHeadersOnError;
        return async function cors(ctx, next) {
            const requestOrigin = ctx.get('Origin');
            ctx.vary('Origin');
            let origin;
            if (typeof options.origin === 'function') {
                origin = await options.origin(ctx);
                if (!origin) {
                    return await next();
                }
            } else {
                origin = options.origin || '*';
            }
            let credentials;
            if (typeof options.credentials === 'function') {
                credentials = await options.credentials(ctx);
            } else {
                credentials = !!options.credentials;
            }
            if (credentials && origin === '*') {
                origin = requestOrigin;
            }
            const headersSet = {};
            function set(key, value) {
                ctx.set(key, value);
                headersSet[key] = value;
            }
            if (ctx.method !== 'OPTIONS') {
                set('Access-Control-Allow-Origin', origin);
                if (credentials === true) {
                    set('Access-Control-Allow-Credentials', 'true');
                }
                if (options.exposeHeaders) {
                    set('Access-Control-Expose-Headers', options.exposeHeaders);
                }
                if (options.secureContext) {
                    set('Cross-Origin-Opener-Policy', 'same-origin');
                    set('Cross-Origin-Embedder-Policy', 'require-corp');
                }
                if (!options.keepHeadersOnError) {
                    return await next();
                }
                try {
                    return await next();
                } catch (err) {
                    const errHeadersSet = err.headers || {};
                    const varyWithOrigin = vary.append(errHeadersSet.vary || errHeadersSet.Vary || '', 'Origin');
                    delete errHeadersSet.Vary;
                    err.headers = {
                        ...errHeadersSet,
                        ...headersSet,
                        ...{
                            vary: varyWithOrigin
                        }
                    };
                    throw err;
                }
            } else {
                if (!ctx.get('Access-Control-Request-Method')) {
                    return await next();
                }
                ctx.set('Access-Control-Allow-Origin', origin);
                if (credentials === true) {
                    ctx.set('Access-Control-Allow-Credentials', 'true');
                }
                if (options.maxAge) {
                    ctx.set('Access-Control-Max-Age', options.maxAge);
                }
                if (options.privateNetworkAccess && ctx.get('Access-Control-Request-Private-Network')) {
                    ctx.set('Access-Control-Allow-Private-Network', 'true');
                }
                if (options.allowMethods) {
                    ctx.set('Access-Control-Allow-Methods', options.allowMethods);
                }
                if (options.secureContext) {
                    set('Cross-Origin-Opener-Policy', 'same-origin');
                    set('Cross-Origin-Embedder-Policy', 'require-corp');
                }
                let allowHeaders = options.allowHeaders;
                if (!allowHeaders) {
                    allowHeaders = ctx.get('Access-Control-Request-Headers');
                }
                if (allowHeaders) {
                    ctx.set('Access-Control-Allow-Headers', allowHeaders);
                }
                ctx.status = 204;
            }
        };
    };
}
,
"4cf295d9":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const { PassThrough } = global.nodeRequire('stream', true);
    module.exports = function() {
        var sources = [];
        var output = new PassThrough({
            objectMode: true
        });
        output.setMaxListeners(0);
        output.add = add;
        output.isEmpty = isEmpty;
        output.on('unpipe', remove);
        Array.prototype.slice.call(arguments).forEach(add);
        return output;
        function add(source) {
            if (Array.isArray(source)) {
                source.forEach(add);
                return this;
            }
            sources.push(source);
            source.once('end', remove.bind(null, source));
            source.once('error', output.emit.bind(output, 'error'));
            source.pipe(output, {
                end: false
            });
            return this;
        }
        function isEmpty() {
            return sources.length == 0;
        }
        function remove(source) {
            sources = sources.filter(function(it) {
                return it !== source;
            });
            if (!sources.length && output.readable) {
                output.end();
            }
        }
    };
}
,
"4e3d037a":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    module.exports = preferredEncodings;
    module.exports.preferredEncodings = preferredEncodings;
    var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
    function parseAcceptEncoding(accept) {
        var accepts = accept.split(',');
        var hasIdentity = false;
        var minQuality = 1;
        for(var i = 0, j = 0; i < accepts.length; i++){
            var encoding = parseEncoding(accepts[i].trim(), i);
            if (encoding) {
                accepts[j++] = encoding;
                hasIdentity = hasIdentity || specify('identity', encoding);
                minQuality = Math.min(minQuality, encoding.q || 1);
            }
        }
        if (!hasIdentity) {
            accepts[j++] = {
                encoding: 'identity',
                q: minQuality,
                i: i
            };
        }
        accepts.length = j;
        return accepts;
    }
    function parseEncoding(str, i) {
        var match = simpleEncodingRegExp.exec(str);
        if (!match) return null;
        var encoding = match[1];
        var q = 1;
        if (match[2]) {
            var params = match[2].split(';');
            for(var j = 0; j < params.length; j++){
                var p = params[j].trim().split('=');
                if (p[0] === 'q') {
                    q = parseFloat(p[1]);
                    break;
                }
            }
        }
        return {
            encoding: encoding,
            q: q,
            i: i
        };
    }
    function getEncodingPriority(encoding, accepted, index) {
        var priority = {
            o: -1,
            q: 0,
            s: 0
        };
        for(var i = 0; i < accepted.length; i++){
            var spec = specify(encoding, accepted[i], index);
            if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
                priority = spec;
            }
        }
        return priority;
    }
    function specify(encoding, spec, index) {
        var s = 0;
        if (spec.encoding.toLowerCase() === encoding.toLowerCase()) {
            s |= 1;
        } else if (spec.encoding !== '*') {
            return null;
        }
        return {
            i: index,
            o: spec.i,
            q: spec.q,
            s: s
        };
    }
    ;
    function preferredEncodings(accept, provided) {
        var accepts = parseAcceptEncoding(accept || '');
        if (!provided) {
            return accepts.filter(isQuality).sort(compareSpecs).map(getFullEncoding);
        }
        var priorities = provided.map(function getPriority(type, index) {
            return getEncodingPriority(type, accepts, index);
        });
        return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {
            return provided[priorities.indexOf(priority)];
        });
    }
    function compareSpecs(a, b) {
        return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }
    function getFullEncoding(spec) {
        return spec.encoding;
    }
    function isQuality(spec) {
        return spec.q > 0;
    }
}
,
"4f7348f5":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    module.exports = preferredMediaTypes;
    module.exports.preferredMediaTypes = preferredMediaTypes;
    var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
    function parseAccept(accept) {
        var accepts = splitMediaTypes(accept);
        for(var i = 0, j = 0; i < accepts.length; i++){
            var mediaType = parseMediaType(accepts[i].trim(), i);
            if (mediaType) {
                accepts[j++] = mediaType;
            }
        }
        accepts.length = j;
        return accepts;
    }
    function parseMediaType(str, i) {
        var match = simpleMediaTypeRegExp.exec(str);
        if (!match) return null;
        var params = Object.create(null);
        var q = 1;
        var subtype = match[2];
        var type = match[1];
        if (match[3]) {
            var kvps = splitParameters(match[3]).map(splitKeyValuePair);
            for(var j = 0; j < kvps.length; j++){
                var pair = kvps[j];
                var key = pair[0].toLowerCase();
                var val = pair[1];
                var value = val && val[0] === '"' && val[val.length - 1] === '"' ? val.substr(1, val.length - 2) : val;
                if (key === 'q') {
                    q = parseFloat(value);
                    break;
                }
                params[key] = value;
            }
        }
        return {
            type: type,
            subtype: subtype,
            params: params,
            q: q,
            i: i
        };
    }
    function getMediaTypePriority(type, accepted, index) {
        var priority = {
            o: -1,
            q: 0,
            s: 0
        };
        for(var i = 0; i < accepted.length; i++){
            var spec = specify(type, accepted[i], index);
            if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
                priority = spec;
            }
        }
        return priority;
    }
    function specify(type, spec, index) {
        var p = parseMediaType(type);
        var s = 0;
        if (!p) {
            return null;
        }
        if (spec.type.toLowerCase() == p.type.toLowerCase()) {
            s |= 4;
        } else if (spec.type != '*') {
            return null;
        }
        if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
            s |= 2;
        } else if (spec.subtype != '*') {
            return null;
        }
        var keys = Object.keys(spec.params);
        if (keys.length > 0) {
            if (keys.every(function(k) {
                return spec.params[k] == '*' || (spec.params[k] || '').toLowerCase() == (p.params[k] || '').toLowerCase();
            })) {
                s |= 1;
            } else {
                return null;
            }
        }
        return {
            i: index,
            o: spec.i,
            q: spec.q,
            s: s
        };
    }
    function preferredMediaTypes(accept, provided) {
        var accepts = parseAccept(accept === undefined ? '*/*' : accept || '');
        if (!provided) {
            return accepts.filter(isQuality).sort(compareSpecs).map(getFullType);
        }
        var priorities = provided.map(function getPriority(type, index) {
            return getMediaTypePriority(type, accepts, index);
        });
        return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
            return provided[priorities.indexOf(priority)];
        });
    }
    function compareSpecs(a, b) {
        return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }
    function getFullType(spec) {
        return spec.type + '/' + spec.subtype;
    }
    function isQuality(spec) {
        return spec.q > 0;
    }
    function quoteCount(string) {
        var count = 0;
        var index = 0;
        while((index = string.indexOf('"', index)) !== -1){
            count++;
            index++;
        }
        return count;
    }
    function splitKeyValuePair(str) {
        var index = str.indexOf('=');
        var key;
        var val;
        if (index === -1) {
            key = str;
        } else {
            key = str.substr(0, index);
            val = str.substr(index + 1);
        }
        return [
            key,
            val
        ];
    }
    function splitMediaTypes(accept) {
        var accepts = accept.split(',');
        for(var i = 1, j = 0; i < accepts.length; i++){
            if (quoteCount(accepts[j]) % 2 == 0) {
                accepts[++j] = accepts[i];
            } else {
                accepts[j] += ',' + accepts[i];
            }
        }
        accepts.length = j + 1;
        return accepts;
    }
    function splitParameters(str) {
        var parameters = str.split(';');
        for(var i = 1, j = 0; i < parameters.length; i++){
            if (quoteCount(parameters[j]) % 2 == 0) {
                parameters[++j] = parameters[i];
            } else {
                parameters[j] += ';' + parameters[i];
            }
        }
        parameters.length = j + 1;
        for(var i = 0; i < parameters.length; i++){
            parameters[i] = parameters[i].trim();
        }
        return parameters;
    }
}
,
"4ffdf2a8":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const fs = farmRequire("ffc819a8", true);
    const u = farmRequire("712c2dd4", true).fromCallback;
    function remove(path, callback) {
        fs.rm(path, {
            recursive: true,
            force: true
        }, callback);
    }
    function removeSync(path) {
        fs.rmSync(path, {
            recursive: true,
            force: true
        });
    }
    module.exports = {
        remove: u(remove),
        removeSync
    };
}
,
"50d83445":function  (module, exports, farmRequire, farmDynamicRequire) {
    if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
        module.exports = farmRequire("e01aad99", true);
    } else {
        module.exports = farmRequire("86b15c4b", true);
    }
}
,
"510e1346":function  (module, exports, farmRequire, farmDynamicRequire) {
    try {
        var util = global.nodeRequire('util', true);
        if (typeof util.inherits !== 'function') throw '';
        module.exports = util.inherits;
    } catch (e) {
        module.exports = farmRequire("c0f10885", true);
    }
}
,
"544e7bac":/*!
 * resolve-path
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2018 Douglas Christopher Wilson
 * MIT Licensed
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    var createError = farmRequire("96c3b423", true);
    var join = global.nodeRequire('path', true).join;
    var normalize = global.nodeRequire('path', true).normalize;
    var pathIsAbsolute = farmRequire("f3a11347", true);
    var resolve = global.nodeRequire('path', true).resolve;
    var sep = global.nodeRequire('path', true).sep;
    module.exports = resolvePath;
    var UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
    function resolvePath(rootPath, relativePath) {
        var path = relativePath;
        var root = rootPath;
        if (arguments.length === 1) {
            path = rootPath;
            root = process.cwd();
        }
        if (root == null) {
            throw new TypeError('argument rootPath is required');
        }
        if (typeof root !== 'string') {
            throw new TypeError('argument rootPath must be a string');
        }
        if (path == null) {
            throw new TypeError('argument relativePath is required');
        }
        if (typeof path !== 'string') {
            throw new TypeError('argument relativePath must be a string');
        }
        if (path.indexOf('\0') !== -1) {
            throw createError(400, 'Malicious Path');
        }
        if (pathIsAbsolute.posix(path) || pathIsAbsolute.win32(path)) {
            throw createError(400, 'Malicious Path');
        }
        if (UP_PATH_REGEXP.test(normalize('.' + sep + path))) {
            throw createError(403);
        }
        return normalize(join(resolve(root), path));
    }
}
,
"54541ffb":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.SIGRTMAX = exports.getRealtimeSignals = void 0;
    const getRealtimeSignals = function() {
        const length = SIGRTMAX - SIGRTMIN + 1;
        return Array.from({
            length
        }, getRealtimeSignal);
    };
    exports.getRealtimeSignals = getRealtimeSignals;
    const getRealtimeSignal = function(value, index) {
        return {
            name: `SIGRT${index + 1}`,
            number: SIGRTMIN + index,
            action: "terminate",
            description: "Application-specific signal (realtime)",
            standard: "posix"
        };
    };
    const SIGRTMIN = 34;
    const SIGRTMAX = 64;
    exports.SIGRTMAX = SIGRTMAX;
}
,
"54ce5140":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const { stringify } = farmRequire("22ca6445", true);
    const { outputFileSync } = farmRequire("f69bc856", true);
    function outputJsonSync(file, data, options) {
        const str = stringify(data, options);
        outputFileSync(file, str, options);
    }
    module.exports = outputJsonSync;
}
,
"5506fbab":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "openBrowser", ()=>openBrowser);
    var _f_node_path = module.i(farmRequire('node:path'));
    var _f_node_url = farmRequire('node:url');
    var _f_child_process = farmRequire('child_process');
    var _f_execa = farmRequire("1bdb2cdd");
    var _f_open = module.i(farmRequire("1c8f4aba"));
    var _f_index = farmRequire("65ad6846");
    const OSX_CHROME = 'google chrome';
    function getBrowserEnv() {
        const value = process.env.BROWSER;
        let action;
        if (!value) {
            action = 1;
        } else if (value.toLowerCase().endsWith('.js')) {
            action = 2;
        } else if (value.toLowerCase() === 'none') {
            action = 0;
        } else {
            action = 1;
        }
        return {
            action,
            value
        };
    }
    function executeNodeScript(scriptPath, url) {
        const extraArgs = process.argv.slice(2);
        const child = _f_execa.execa('node', [
            scriptPath,
            ...extraArgs,
            url
        ], {
            stdio: 'inherit'
        });
        child.on('close', (code)=>{
            if (code !== 0) {
                console.log();
                console.log(_f_index.red('The script specified as BROWSER environment variable failed.'));
                console.log(_f_index.cyan(scriptPath) + ' exited with code ' + code + '.');
                console.log();
                return;
            }
        });
        return true;
    }
    function startBrowserProcess(browser, url) {
        const shouldTryOpenChromeWithAppleScript = process.platform === 'darwin' && (typeof browser !== 'string' || browser === OSX_CHROME);
        const dirname = module.f(_f_node_path).dirname(_f_node_url.fileURLToPath(module.meta.url));
        if (shouldTryOpenChromeWithAppleScript) {
            try {
                _f_child_process.execSync('ps cax | grep "Google Chrome"');
                _f_child_process.execSync('osascript openChrome.applescript "' + encodeURI(url) + '"', {
                    cwd: module.f(_f_node_path).resolve(dirname, '../../bin'),
                    stdio: 'ignore'
                });
                return true;
            } catch  {}
        }
        if (process.platform === 'darwin' && browser === 'open') {
            browser = undefined;
        }
        try {
            const options = browser ? {
                app: {
                    name: browser,
                    arguments: []
                }
            } : {};
            const logger = new _f_index.Logger();
            module.f(_f_open)(url, options).catch((e)=>{
                logger.error(e);
            });
            return true;
        } catch  {
            return false;
        }
    }
    function openBrowser(url) {
        const { action, value } = getBrowserEnv();
        switch(action){
            case 0:
                return false;
            case 2:
                return executeNodeScript(value, url);
            case 1:
                return startBrowserProcess(value, url);
            default:
                throw new Error('Not implemented.');
        }
    }
}
,
"56953f91":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const shebangRegex = farmRequire("ea5249cf", true);
    module.exports = (string = '')=>{
        const match = string.match(shebangRegex);
        if (!match) {
            return null;
        }
        const [path, argument] = match[0].replace(/#! ?/, '').split(' ');
        const binary = path.split('/').pop();
        if (binary === 'env') {
            return argument;
        }
        return argument ? `${binary} ${argument}` : binary;
    };
}
,
"580b8c97":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const u = farmRequire("712c2dd4", true).fromPromise;
    const jsonFile = farmRequire("3ebd0c9e", true);
    jsonFile.outputJson = u(farmRequire("a62bfdde"));
    jsonFile.outputJsonSync = farmRequire("54ce5140", true);
    jsonFile.outputJSON = jsonFile.outputJson;
    jsonFile.outputJSONSync = jsonFile.outputJsonSync;
    jsonFile.writeJSON = jsonFile.writeJson;
    jsonFile.writeJSONSync = jsonFile.writeJsonSync;
    jsonFile.readJSON = jsonFile.readJson;
    jsonFile.readJSONSync = jsonFile.readJsonSync;
    module.exports = jsonFile;
}
,
"587b96f0":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const compressible = farmRequire("20fd6809", true);
    const isJSON = farmRequire("5f8961cb", true);
    const Stream = global.nodeRequire('stream', true);
    const bytes = farmRequire("ee7201d5", true);
    const Encodings = farmRequire("0630d65a", true);
    const NO_TRANSFORM_REGEX = /(?:^|,)\s*?no-transform\s*?(?:,|$)/;
    const emptyBodyStatues = new Set([
        204,
        205,
        304
    ]);
    module.exports = (options = {})=>{
        let { filter = compressible, threshold = 1024, defaultEncoding = 'identity' } = options;
        if (typeof threshold === 'string') threshold = bytes(threshold);
        const preferredEncodings = Encodings.preferredEncodings.filter((encoding)=>options[encoding] !== false && options[encoding] !== null);
        const encodingOptions = {};
        preferredEncodings.forEach((encoding)=>{
            encodingOptions[encoding] = {
                ...Encodings.encodingMethodDefaultOptions[encoding],
                ...options[encoding] || {}
            };
        });
        Object.assign(compressMiddleware, {
            preferredEncodings,
            encodingOptions
        });
        return compressMiddleware;
        async function compressMiddleware(ctx, next) {
            ctx.vary('Accept-Encoding');
            await next();
            let { body } = ctx;
            if (!body || ctx.res.headersSent || !ctx.writable || ctx.compress === false || ctx.request.method === 'HEAD' || emptyBodyStatues.has(+ctx.response.status) || ctx.response.get('Content-Encoding') || !(ctx.compress === true || filter(ctx.response.type)) || NO_TRANSFORM_REGEX.test(ctx.response.get('Cache-Control')) || threshold && ctx.response.length < threshold) return;
            const encodings = new Encodings({
                preferredEncodings
            });
            encodings.parseAcceptEncoding(ctx.request.headers['accept-encoding'] || defaultEncoding);
            const encoding = encodings.getPreferredContentEncoding();
            if (encoding === 'identity') return;
            if (isJSON(body)) body = ctx.body = JSON.stringify(body);
            ctx.set('Content-Encoding', encoding);
            ctx.res.removeHeader('Content-Length');
            const compress = Encodings.encodingMethods[encoding];
            const stream = ctx.body = compress(encodingOptions[encoding]);
            if (body instanceof Stream) return body.pipe(stream);
            stream.end(body);
        }
    };
}
,
"5954bc0f":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
    const fs = global.nodeRequire("fs", true);
    const os = global.nodeRequire("os", true);
    const CPU_COUNT = Math.max(os.cpus().length, 1);
    exports.DEFAULT_FILE_SYSTEM_ADAPTER = {
        lstat: fs.lstat,
        lstatSync: fs.lstatSync,
        stat: fs.stat,
        statSync: fs.statSync,
        readdir: fs.readdir,
        readdirSync: fs.readdirSync
    };
    class Settings {
        constructor(_options = {}){
            this._options = _options;
            this.absolute = this._getValue(this._options.absolute, false);
            this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
            this.braceExpansion = this._getValue(this._options.braceExpansion, true);
            this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
            this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
            this.cwd = this._getValue(this._options.cwd, process.cwd());
            this.deep = this._getValue(this._options.deep, Infinity);
            this.dot = this._getValue(this._options.dot, false);
            this.extglob = this._getValue(this._options.extglob, true);
            this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
            this.fs = this._getFileSystemMethods(this._options.fs);
            this.globstar = this._getValue(this._options.globstar, true);
            this.ignore = this._getValue(this._options.ignore, []);
            this.markDirectories = this._getValue(this._options.markDirectories, false);
            this.objectMode = this._getValue(this._options.objectMode, false);
            this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
            this.onlyFiles = this._getValue(this._options.onlyFiles, true);
            this.stats = this._getValue(this._options.stats, false);
            this.suppressErrors = this._getValue(this._options.suppressErrors, false);
            this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
            this.unique = this._getValue(this._options.unique, true);
            if (this.onlyDirectories) {
                this.onlyFiles = false;
            }
            if (this.stats) {
                this.objectMode = true;
            }
            this.ignore = [].concat(this.ignore);
        }
        _getValue(option, value) {
            return option === undefined ? value : option;
        }
        _getFileSystemMethods(methods = {}) {
            return Object.assign(Object.assign({}, exports.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
        }
    }
    exports.default = Settings;
}
,
"598071d1":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    function reusify(Constructor) {
        var head = new Constructor();
        var tail = head;
        function get() {
            var current = head;
            if (current.next) {
                head = current.next;
            } else {
                head = new Constructor();
                tail = head;
            }
            current.next = null;
            return current;
        }
        function release(obj) {
            tail.next = obj;
            tail = obj;
        }
        return {
            get: get,
            release: release
        };
    }
    module.exports = reusify;
}
,
"5a1b26a7":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "safeJsonParse", ()=>safeJsonParse);
    function safeJsonParse(v, defaultValue) {
        try {
            return JSON.parse(v);
        } catch (error) {
            return defaultValue;
        }
    }
}
,
"5a3e24d0":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const stream_1 = global.nodeRequire("stream", true);
    const fsStat = farmRequire("be5cf725", true);
    const fsWalk = farmRequire("410b6735", true);
    const reader_1 = farmRequire("7af0e906", true);
    class ReaderStream extends reader_1.default {
        constructor(){
            super(...arguments);
            this._walkStream = fsWalk.walkStream;
            this._stat = fsStat.stat;
        }
        dynamic(root, options) {
            return this._walkStream(root, options);
        }
        static(patterns, options) {
            const filepaths = patterns.map(this._getFullEntryPath, this);
            const stream = new stream_1.PassThrough({
                objectMode: true
            });
            stream._write = (index, _enc, done)=>{
                return this._getEntry(filepaths[index], patterns[index], options).then((entry)=>{
                    if (entry !== null && options.entryFilter(entry)) {
                        stream.push(entry);
                    }
                    if (index === filepaths.length - 1) {
                        stream.end();
                    }
                    done();
                }).catch(done);
            };
            for(let i = 0; i < filepaths.length; i++){
                stream.write(i);
            }
            return stream;
        }
        _getEntry(filepath, pattern, options) {
            return this._getStat(filepath).then((stats)=>this._makeEntry(stats, pattern)).catch((error)=>{
                if (options.errorFilter(error)) {
                    return null;
                }
                throw error;
            });
        }
        _getStat(filepath) {
            return new Promise((resolve, reject)=>{
                this._stat(filepath, this._fsStatSettings, (error, stats)=>{
                    return error === null ? resolve(stats) : reject(error);
                });
            });
        }
    }
    exports.default = ReaderStream;
}
,
"5ad07f45":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const fs = global.nodeRequire('fs', true);
    const shebangCommand = farmRequire("56953f91", true);
    function readShebang(command) {
        const size = 150;
        const buffer = Buffer.alloc(size);
        let fd;
        try {
            fd = fs.openSync(command, 'r');
            fs.readSync(fd, buffer, 0, size, 0);
            fs.closeSync(fd);
        } catch (e) {}
        return shebangCommand(buffer.toString());
    }
    module.exports = readShebang;
}
,
"5ae26e1f":function  (module, exports, farmRequire, farmDynamicRequire) {
    module.exports = {
        "name": "dotenv",
        "version": "16.4.5",
        "description": "Loads environment variables from .env file",
        "main": "lib/main.js",
        "types": "lib/main.d.ts",
        "exports": {
            ".": {
                "types": "./lib/main.d.ts",
                "require": "./lib/main.js",
                "default": "./lib/main.js"
            },
            "./config": "./config.js",
            "./config.js": "./config.js",
            "./lib/env-options": "./lib/env-options.js",
            "./lib/env-options.js": "./lib/env-options.js",
            "./lib/cli-options": "./lib/cli-options.js",
            "./lib/cli-options.js": "./lib/cli-options.js",
            "./package.json": "./package.json"
        },
        "scripts": {
            "dts-check": "tsc --project tests/types/tsconfig.json",
            "lint": "standard",
            "lint-readme": "standard-markdown",
            "pretest": "npm run lint && npm run dts-check",
            "test": "tap tests/*.js --100 -Rspec",
            "test:coverage": "tap --coverage-report=lcov",
            "prerelease": "npm test",
            "release": "standard-version"
        },
        "repository": {
            "type": "git",
            "url": "git://github.com/motdotla/dotenv.git"
        },
        "funding": "https://dotenvx.com",
        "keywords": [
            "dotenv",
            "env",
            ".env",
            "environment",
            "variables",
            "config",
            "settings"
        ],
        "readmeFilename": "README.md",
        "license": "BSD-2-Clause",
        "devDependencies": {
            "@definitelytyped/dtslint": "^0.0.133",
            "@types/node": "^18.11.3",
            "decache": "^4.6.1",
            "sinon": "^14.0.1",
            "standard": "^17.0.0",
            "standard-markdown": "^7.1.0",
            "standard-version": "^9.5.0",
            "tap": "^16.3.0",
            "tar": "^6.1.11",
            "typescript": "^4.8.4"
        },
        "engines": {
            "node": ">=12"
        },
        "browser": {
            "fs": false
        }
    };
}
,
"5bde615a":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
            desc = {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            };
        }
        Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    });
    var __exportStar = this && this.__exportStar || function(m, exports1) {
        for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
    };
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    __exportStar(farmRequire("ace053e8", true), exports);
}
,
"5be87a60":/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    var codes = farmRequire("183ad0d4", true);
    module.exports = status;
    status.STATUS_CODES = codes;
    status.codes = populateStatusesMap(status, codes);
    status.redirect = {
        300: true,
        301: true,
        302: true,
        303: true,
        305: true,
        307: true,
        308: true
    };
    status.empty = {
        204: true,
        205: true,
        304: true
    };
    status.retry = {
        502: true,
        503: true,
        504: true
    };
    function populateStatusesMap(statuses, codes) {
        var arr = [];
        Object.keys(codes).forEach(function forEachCode(code) {
            var message = codes[code];
            var status = Number(code);
            statuses[status] = message;
            statuses[message] = status;
            statuses[message.toLowerCase()] = status;
            arr.push(status);
        });
        return arr;
    }
    function status(code) {
        if (typeof code === 'number') {
            if (!status[code]) throw new Error('invalid status code: ' + code);
            return code;
        }
        if (typeof code !== 'string') {
            throw new TypeError('code must be a number or string');
        }
        var n = parseInt(code, 10);
        if (!isNaN(n)) {
            if (!status[n]) throw new Error('invalid status code: ' + n);
            return n;
        }
        n = status[code.toLowerCase()];
        if (!n) throw new Error('invalid status message: "' + code + '"');
        return n;
    }
}
,
"5c283cf2":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const mimeTypes = farmRequire("e0cde53a", true);
    const LRU = farmRequire("05993fde", true);
    const typeLRUCache = new LRU(100);
    module.exports = (type)=>{
        let mimeType = typeLRUCache.get(type);
        if (!mimeType) {
            mimeType = mimeTypes.contentType(type);
            typeLRUCache.set(type, mimeType);
        }
        return mimeType;
    };
}
,
"5cb1eb7b":/*!
 * negotiator
 * Copyright(c) 2012 Federico Romero
 * Copyright(c) 2012-2014 Isaac Z. Schlueter
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    var preferredCharsets = farmRequire("d932692c", true);
    var preferredEncodings = farmRequire("4e3d037a", true);
    var preferredLanguages = farmRequire("b04b95dc", true);
    var preferredMediaTypes = farmRequire("4f7348f5", true);
    module.exports = Negotiator;
    module.exports.Negotiator = Negotiator;
    function Negotiator(request) {
        if (!(this instanceof Negotiator)) {
            return new Negotiator(request);
        }
        this.request = request;
    }
    Negotiator.prototype.charset = function charset(available) {
        var set = this.charsets(available);
        return set && set[0];
    };
    Negotiator.prototype.charsets = function charsets(available) {
        return preferredCharsets(this.request.headers['accept-charset'], available);
    };
    Negotiator.prototype.encoding = function encoding(available) {
        var set = this.encodings(available);
        return set && set[0];
    };
    Negotiator.prototype.encodings = function encodings(available) {
        return preferredEncodings(this.request.headers['accept-encoding'], available);
    };
    Negotiator.prototype.language = function language(available) {
        var set = this.languages(available);
        return set && set[0];
    };
    Negotiator.prototype.languages = function languages(available) {
        return preferredLanguages(this.request.headers['accept-language'], available);
    };
    Negotiator.prototype.mediaType = function mediaType(available) {
        var set = this.mediaTypes(available);
        return set && set[0];
    };
    Negotiator.prototype.mediaTypes = function mediaTypes(available) {
        return preferredMediaTypes(this.request.headers.accept, available);
    };
    Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
    Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
    Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
    Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
    Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
    Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
    Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
    Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;
}
,
"5da88193":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    var _f_cors = farmRequire("0d467a9b");
    module._e(exports, _f_cors);
    var _f_headers = farmRequire("a2d7d647");
    module._e(exports, _f_headers);
    var _f_lazy_compilation = farmRequire("cbf7c3bf");
    module._e(exports, _f_lazy_compilation);
    var _f_proxy = farmRequire("4bbd2bcd");
    module._e(exports, _f_proxy);
    var _f_resources = farmRequire("aa096847");
    module._e(exports, _f_resources);
    var _f_static = farmRequire("eb010733");
    module._e(exports, _f_static);
}
,
"5dd9d74a":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
    const NODE_PROCESS_VERSION_PARTS = process.versions.node.split('.');
    if (NODE_PROCESS_VERSION_PARTS[0] === undefined || NODE_PROCESS_VERSION_PARTS[1] === undefined) {
        throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
    }
    const MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
    const MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
    const SUPPORTED_MAJOR_VERSION = 10;
    const SUPPORTED_MINOR_VERSION = 10;
    const IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
    const IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
    exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
}
,
"5ef97856":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "SIGNALS", ()=>SIGNALS);
    var SIGNALS = [
        {
            name: "SIGHUP",
            number: 1,
            action: "terminate",
            description: "Terminal closed",
            standard: "posix"
        },
        {
            name: "SIGINT",
            number: 2,
            action: "terminate",
            description: "User interruption with CTRL-C",
            standard: "ansi"
        },
        {
            name: "SIGQUIT",
            number: 3,
            action: "core",
            description: "User interruption with CTRL-\\",
            standard: "posix"
        },
        {
            name: "SIGILL",
            number: 4,
            action: "core",
            description: "Invalid machine instruction",
            standard: "ansi"
        },
        {
            name: "SIGTRAP",
            number: 5,
            action: "core",
            description: "Debugger breakpoint",
            standard: "posix"
        },
        {
            name: "SIGABRT",
            number: 6,
            action: "core",
            description: "Aborted",
            standard: "ansi"
        },
        {
            name: "SIGIOT",
            number: 6,
            action: "core",
            description: "Aborted",
            standard: "bsd"
        },
        {
            name: "SIGBUS",
            number: 7,
            action: "core",
            description: "Bus error due to misaligned, non-existing address or paging error",
            standard: "bsd"
        },
        {
            name: "SIGEMT",
            number: 7,
            action: "terminate",
            description: "Command should be emulated but is not implemented",
            standard: "other"
        },
        {
            name: "SIGFPE",
            number: 8,
            action: "core",
            description: "Floating point arithmetic error",
            standard: "ansi"
        },
        {
            name: "SIGKILL",
            number: 9,
            action: "terminate",
            description: "Forced termination",
            standard: "posix",
            forced: true
        },
        {
            name: "SIGUSR1",
            number: 10,
            action: "terminate",
            description: "Application-specific signal",
            standard: "posix"
        },
        {
            name: "SIGSEGV",
            number: 11,
            action: "core",
            description: "Segmentation fault",
            standard: "ansi"
        },
        {
            name: "SIGUSR2",
            number: 12,
            action: "terminate",
            description: "Application-specific signal",
            standard: "posix"
        },
        {
            name: "SIGPIPE",
            number: 13,
            action: "terminate",
            description: "Broken pipe or socket",
            standard: "posix"
        },
        {
            name: "SIGALRM",
            number: 14,
            action: "terminate",
            description: "Timeout or timer",
            standard: "posix"
        },
        {
            name: "SIGTERM",
            number: 15,
            action: "terminate",
            description: "Termination",
            standard: "ansi"
        },
        {
            name: "SIGSTKFLT",
            number: 16,
            action: "terminate",
            description: "Stack is empty or overflowed",
            standard: "other"
        },
        {
            name: "SIGCHLD",
            number: 17,
            action: "ignore",
            description: "Child process terminated, paused or unpaused",
            standard: "posix"
        },
        {
            name: "SIGCLD",
            number: 17,
            action: "ignore",
            description: "Child process terminated, paused or unpaused",
            standard: "other"
        },
        {
            name: "SIGCONT",
            number: 18,
            action: "unpause",
            description: "Unpaused",
            standard: "posix",
            forced: true
        },
        {
            name: "SIGSTOP",
            number: 19,
            action: "pause",
            description: "Paused",
            standard: "posix",
            forced: true
        },
        {
            name: "SIGTSTP",
            number: 20,
            action: "pause",
            description: "Paused using CTRL-Z or \"suspend\"",
            standard: "posix"
        },
        {
            name: "SIGTTIN",
            number: 21,
            action: "pause",
            description: "Background process cannot read terminal input",
            standard: "posix"
        },
        {
            name: "SIGBREAK",
            number: 21,
            action: "terminate",
            description: "User interruption with CTRL-BREAK",
            standard: "other"
        },
        {
            name: "SIGTTOU",
            number: 22,
            action: "pause",
            description: "Background process cannot write to terminal output",
            standard: "posix"
        },
        {
            name: "SIGURG",
            number: 23,
            action: "ignore",
            description: "Socket received out-of-band data",
            standard: "bsd"
        },
        {
            name: "SIGXCPU",
            number: 24,
            action: "core",
            description: "Process timed out",
            standard: "bsd"
        },
        {
            name: "SIGXFSZ",
            number: 25,
            action: "core",
            description: "File too big",
            standard: "bsd"
        },
        {
            name: "SIGVTALRM",
            number: 26,
            action: "terminate",
            description: "Timeout or timer",
            standard: "bsd"
        },
        {
            name: "SIGPROF",
            number: 27,
            action: "terminate",
            description: "Timeout or timer",
            standard: "bsd"
        },
        {
            name: "SIGWINCH",
            number: 28,
            action: "ignore",
            description: "Terminal window size changed",
            standard: "bsd"
        },
        {
            name: "SIGIO",
            number: 29,
            action: "terminate",
            description: "I/O is available",
            standard: "other"
        },
        {
            name: "SIGPOLL",
            number: 29,
            action: "terminate",
            description: "Watched event",
            standard: "other"
        },
        {
            name: "SIGINFO",
            number: 29,
            action: "ignore",
            description: "Request for process information",
            standard: "other"
        },
        {
            name: "SIGPWR",
            number: 30,
            action: "terminate",
            description: "Device running out of power",
            standard: "systemv"
        },
        {
            name: "SIGSYS",
            number: 31,
            action: "core",
            description: "Invalid system call",
            standard: "other"
        },
        {
            name: "SIGUNUSED",
            number: 31,
            action: "terminate",
            description: "Invalid system call",
            standard: "other"
        }
    ];
}
,
"5f500fe0":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const stream_1 = global.nodeRequire("stream", true);
    const async_1 = farmRequire("05c5e7d0", true);
    class StreamProvider {
        constructor(_root, _settings){
            this._root = _root;
            this._settings = _settings;
            this._reader = new async_1.default(this._root, this._settings);
            this._stream = new stream_1.Readable({
                objectMode: true,
                read: ()=>{},
                destroy: ()=>{
                    if (!this._reader.isDestroyed) {
                        this._reader.destroy();
                    }
                }
            });
        }
        read() {
            this._reader.onError((error)=>{
                this._stream.emit('error', error);
            });
            this._reader.onEntry((entry)=>{
                this._stream.push(entry);
            });
            this._reader.onEnd(()=>{
                this._stream.push(null);
            });
            this._reader.read();
            return this._stream;
        }
    }
    exports.default = StreamProvider;
}
,
"5f8961cb":function  (module, exports, farmRequire, farmDynamicRequire) {
    module.exports = isJSON;
    function isJSON(body) {
        if (!body) return false;
        if ('string' == typeof body) return false;
        if ('function' == typeof body.pipe) return false;
        if (Buffer.isBuffer(body)) return false;
        return true;
    }
}
,
"601e56c0":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;
    const fs = global.nodeRequire("fs", true);
    exports.FILE_SYSTEM_ADAPTER = {
        lstat: fs.lstat,
        stat: fs.stat,
        lstatSync: fs.lstatSync,
        statSync: fs.statSync,
        readdir: fs.readdir,
        readdirSync: fs.readdirSync
    };
    function createFileSystemAdapter(fsMethods) {
        if (fsMethods === undefined) {
            return exports.FILE_SYSTEM_ADAPTER;
        }
        return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports.createFileSystemAdapter = createFileSystemAdapter;
}
,
"624c14bf":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.getStatusCode = void 0;
    function getStatusCode(errorCode) {
        let statusCode;
        if (/HPE_INVALID/.test(errorCode)) {
            statusCode = 502;
        } else {
            switch(errorCode){
                case 'ECONNRESET':
                case 'ENOTFOUND':
                case 'ECONNREFUSED':
                case 'ETIMEDOUT':
                    statusCode = 504;
                    break;
                default:
                    statusCode = 500;
                    break;
            }
        }
        return statusCode;
    }
    exports.getStatusCode = getStatusCode;
}
,
"625d23a2":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.joinPathSegments = exports.replacePathSegmentSeparator = exports.isAppliedFilter = exports.isFatalError = void 0;
    function isFatalError(settings, error) {
        if (settings.errorFilter === null) {
            return true;
        }
        return !settings.errorFilter(error);
    }
    exports.isFatalError = isFatalError;
    function isAppliedFilter(filter, value) {
        return filter === null || filter(value);
    }
    exports.isAppliedFilter = isAppliedFilter;
    function replacePathSegmentSeparator(filepath, separator) {
        return filepath.split(/[/\\]/).join(separator);
    }
    exports.replacePathSegmentSeparator = replacePathSegmentSeparator;
    function joinPathSegments(a, b, separator) {
        if (a === '') {
            return b;
        }
        if (a.endsWith(separator)) {
            return a + b;
        }
        return a + separator + b;
    }
    exports.joinPathSegments = joinPathSegments;
}
,
"634664d9":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.getLogger = void 0;
    const noopLogger = {
        info: ()=>{},
        warn: ()=>{},
        error: ()=>{}
    };
    function getLogger(options) {
        return options.logger || noopLogger;
    }
    exports.getLogger = getLogger;
}
,
"650ab9d4":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const contentDisposition = farmRequire("a2a2844e", true);
    const getType = farmRequire("5c283cf2", true);
    const onFinish = farmRequire("d55f25ca", true);
    const escape = farmRequire("447f28ed", true);
    const typeis = farmRequire("7a5f0ee9", true).is;
    const statuses = farmRequire("5be87a60", true);
    const destroy = farmRequire("9de2e012", true);
    const assert = global.nodeRequire('assert', true);
    const extname = global.nodeRequire('path', true).extname;
    const vary = farmRequire("372df827", true);
    const only = farmRequire("d8812774", true);
    const util = global.nodeRequire('util', true);
    const encodeUrl = farmRequire("9eb92b73", true);
    const Stream = global.nodeRequire('stream', true);
    module.exports = {
        get socket () {
            return this.res.socket;
        },
        get header () {
            const { res } = this;
            return typeof res.getHeaders === 'function' ? res.getHeaders() : res._headers || {};
        },
        get headers () {
            return this.header;
        },
        get status () {
            return this.res.statusCode;
        },
        set status (code){
            if (this.headerSent) return;
            assert(Number.isInteger(code), 'status code must be a number');
            assert(code >= 100 && code <= 999, `invalid status code: ${code}`);
            this._explicitStatus = true;
            this.res.statusCode = code;
            if (this.req.httpVersionMajor < 2) this.res.statusMessage = statuses[code];
            if (this.body && statuses.empty[code]) this.body = null;
        },
        get message () {
            return this.res.statusMessage || statuses[this.status];
        },
        set message (msg){
            this.res.statusMessage = msg;
        },
        get body () {
            return this._body;
        },
        set body (val){
            const original = this._body;
            this._body = val;
            if (null == val) {
                if (!statuses.empty[this.status]) this.status = 204;
                if (val === null) this._explicitNullBody = true;
                this.remove('Content-Type');
                this.remove('Content-Length');
                this.remove('Transfer-Encoding');
                return;
            }
            if (!this._explicitStatus) this.status = 200;
            const setType = !this.has('Content-Type');
            if ('string' === typeof val) {
                if (setType) this.type = /^\s*</.test(val) ? 'html' : 'text';
                this.length = Buffer.byteLength(val);
                return;
            }
            if (Buffer.isBuffer(val)) {
                if (setType) this.type = 'bin';
                this.length = val.length;
                return;
            }
            if (val instanceof Stream) {
                onFinish(this.res, destroy.bind(null, val));
                if (original != val) {
                    val.once('error', (err)=>this.ctx.onerror(err));
                    if (null != original) this.remove('Content-Length');
                }
                if (setType) this.type = 'bin';
                return;
            }
            this.remove('Content-Length');
            this.type = 'json';
        },
        set length (n){
            if (!this.has('Transfer-Encoding')) {
                this.set('Content-Length', n);
            }
        },
        get length () {
            if (this.has('Content-Length')) {
                return parseInt(this.get('Content-Length'), 10) || 0;
            }
            const { body } = this;
            if (!body || body instanceof Stream) return undefined;
            if ('string' === typeof body) return Buffer.byteLength(body);
            if (Buffer.isBuffer(body)) return body.length;
            return Buffer.byteLength(JSON.stringify(body));
        },
        get headerSent () {
            return this.res.headersSent;
        },
        vary (field) {
            if (this.headerSent) return;
            vary(this.res, field);
        },
        redirect (url, alt) {
            if ('back' === url) url = this.ctx.get('Referrer') || alt || '/';
            this.set('Location', encodeUrl(url));
            if (!statuses.redirect[this.status]) this.status = 302;
            if (this.ctx.accepts('html')) {
                url = escape(url);
                this.type = 'text/html; charset=utf-8';
                this.body = `Redirecting to <a href="${url}">${url}</a>.`;
                return;
            }
            this.type = 'text/plain; charset=utf-8';
            this.body = `Redirecting to ${url}.`;
        },
        attachment (filename, options) {
            if (filename) this.type = extname(filename);
            this.set('Content-Disposition', contentDisposition(filename, options));
        },
        set type (type){
            type = getType(type);
            if (type) {
                this.set('Content-Type', type);
            } else {
                this.remove('Content-Type');
            }
        },
        set lastModified (val){
            if ('string' === typeof val) val = new Date(val);
            this.set('Last-Modified', val.toUTCString());
        },
        get lastModified () {
            const date = this.get('last-modified');
            if (date) return new Date(date);
        },
        set etag (val){
            if (!/^(W\/)?"/.test(val)) val = `"${val}"`;
            this.set('ETag', val);
        },
        get etag () {
            return this.get('ETag');
        },
        get type () {
            const type1 = this.get('Content-Type');
            if (!type1) return '';
            return type1.split(';', 1)[0];
        },
        is (type1, ...types) {
            return typeis(this.type, type1, ...types);
        },
        get (field) {
            return this.header[field.toLowerCase()] || '';
        },
        has (field) {
            return typeof this.res.hasHeader === 'function' ? this.res.hasHeader(field) : field.toLowerCase() in this.headers;
        },
        set (field, val1) {
            if (this.headerSent) return;
            if (2 === arguments.length) {
                if (Array.isArray(val1)) val1 = val1.map((v)=>typeof v === 'string' ? v : String(v));
                else if (typeof val1 !== 'string') val1 = String(val1);
                this.res.setHeader(field, val1);
            } else {
                for(const key in field){
                    this.set(key, field[key]);
                }
            }
        },
        append (field, val1) {
            const prev = this.get(field);
            if (prev) {
                val1 = Array.isArray(prev) ? prev.concat(val1) : [
                    prev
                ].concat(val1);
            }
            return this.set(field, val1);
        },
        remove (field) {
            if (this.headerSent) return;
            this.res.removeHeader(field);
        },
        get writable () {
            if (this.res.writableEnded || this.res.finished) return false;
            const socket = this.res.socket;
            if (!socket) return true;
            return socket.writable;
        },
        inspect () {
            if (!this.res) return;
            const o = this.toJSON();
            o.body = this.body;
            return o;
        },
        toJSON () {
            return only(this, [
                'status',
                'message',
                'header'
            ]);
        },
        flushHeaders () {
            this.res.flushHeaders();
        }
    };
    if (util.inspect.custom) {
        module.exports[util.inspect.custom] = module.exports.inspect;
    }
}
,
"65ad6846":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    var _f_share = farmRequire("bc6cc539");
    module._e(exports, _f_share);
    var _f_logger = farmRequire("8c2028dc");
    module._e(exports, _f_logger);
    var _f_build = farmRequire("893ee78a");
    module._e(exports, _f_build);
    var _f_file = farmRequire("ac9f1e68");
    module._e(exports, _f_file);
    var _f_color = farmRequire("f19542e0");
    module._e(exports, _f_color);
    var _f_url = farmRequire("189f7617");
    module._e(exports, _f_url);
    var _f_path = farmRequire("e1334335");
    module._e(exports, _f_path);
    var _f_publicDir = farmRequire("02c34790");
    module._e(exports, _f_publicDir);
    var _f_rebase_url = farmRequire("49b4df4f");
    module._e(exports, _f_rebase_url);
    var _f_plugin_utils = farmRequire("6f6d4eaf");
    module._e(exports, _f_plugin_utils);
    var _f_dynamic_resources = farmRequire("115e919a");
    module._e(exports, _f_dynamic_resources);
}
,
"6682f7cd":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const mask = (source, mask, output, offset, length)=>{
        for(var i = 0; i < length; i++){
            output[offset + i] = source[i] ^ mask[i & 3];
        }
    };
    const unmask = (buffer, mask)=>{
        const length = buffer.length;
        for(var i = 0; i < length; i++){
            buffer[i] ^= mask[i & 3];
        }
    };
    module.exports = {
        mask,
        unmask
    };
}
,
"6716d73f":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "ConfigWatcher", ()=>ConfigWatcher);
    var _f_fs = farmRequire('fs');
    var _f_create_watcher = farmRequire("a041fd99");
    class ConfigWatcher {
        resolvedUserConfig;
        watcher;
        _close;
        constructor(resolvedUserConfig){
            this.resolvedUserConfig = resolvedUserConfig;
            this._close = false;
            if (!resolvedUserConfig) {
                throw new Error('Invalid resolvedUserConfig provided to Farm JsConfigWatcher');
            }
        }
        watch(callback) {
            async function handle(file) {
                callback(file);
            }
            const watchedFilesSet = new Set([
                ...this.resolvedUserConfig.envFiles ?? [],
                ...this.resolvedUserConfig.configFileDependencies ?? [],
                ...this.resolvedUserConfig.configFilePath ? [
                    this.resolvedUserConfig.configFilePath
                ] : []
            ]);
            const watchedFiles = Array.from(watchedFilesSet).filter((file)=>file && _f_fs.existsSync(file));
            const chokidarOptions = {
                awaitWriteFinish: process.platform === 'linux' ? undefined : {
                    stabilityThreshold: 10,
                    pollInterval: 80
                }
            };
            this.watcher = _f_create_watcher.createWatcher(this.resolvedUserConfig, watchedFiles, chokidarOptions);
            this.watcher.on('change', (path)=>{
                if (this._close) return;
                if (watchedFiles.includes(path)) {
                    handle([
                        path
                    ]);
                }
            });
            return this;
        }
        close() {
            this._close = true;
            this.watcher = null;
        }
    }
}
,
"673480b1":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.isEnoentCodeError = void 0;
    function isEnoentCodeError(error) {
        return error.code === 'ENOENT';
    }
    exports.isEnoentCodeError = isEnoentCodeError;
}
,
"675a7cc5":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const util = global.nodeRequire('util', true);
    const createError = farmRequire("48aa4d88", true);
    const httpAssert = farmRequire("7139422c", true);
    const delegate = farmRequire("fb482e15", true);
    const statuses = farmRequire("5be87a60", true);
    const Cookies = farmRequire("d1ab6346", true);
    const COOKIES = Symbol('context#cookies');
    const proto = module.exports = {
        inspect () {
            if (this === proto) return this;
            return this.toJSON();
        },
        toJSON () {
            return {
                request: this.request.toJSON(),
                response: this.response.toJSON(),
                app: this.app.toJSON(),
                originalUrl: this.originalUrl,
                req: '<original node req>',
                res: '<original node res>',
                socket: '<original node socket>'
            };
        },
        assert: httpAssert,
        throw (...args) {
            throw createError(...args);
        },
        onerror (err) {
            if (null == err) return;
            const isNativeError = Object.prototype.toString.call(err) === '[object Error]' || err instanceof Error;
            if (!isNativeError) err = new Error(util.format('non-error thrown: %j', err));
            let headerSent = false;
            if (this.headerSent || !this.writable) {
                headerSent = err.headerSent = true;
            }
            this.app.emit('error', err, this);
            if (headerSent) {
                return;
            }
            const { res } = this;
            if (typeof res.getHeaderNames === 'function') {
                res.getHeaderNames().forEach((name)=>res.removeHeader(name));
            } else {
                res._headers = {};
            }
            this.set(err.headers);
            this.type = 'text';
            let statusCode = err.status || err.statusCode;
            if ('ENOENT' === err.code) statusCode = 404;
            if ('number' !== typeof statusCode || !statuses[statusCode]) statusCode = 500;
            const code = statuses[statusCode];
            const msg = err.expose ? err.message : code;
            this.status = err.status = statusCode;
            this.length = Buffer.byteLength(msg);
            res.end(msg);
        },
        get cookies () {
            if (!this[COOKIES]) {
                this[COOKIES] = new Cookies(this.req, this.res, {
                    keys: this.app.keys,
                    secure: this.request.secure
                });
            }
            return this[COOKIES];
        },
        set cookies (_cookies){
            this[COOKIES] = _cookies;
        }
    };
    if (util.inspect.custom) {
        module.exports[util.inspect.custom] = module.exports.inspect;
    }
    delegate(proto, 'response').method('attachment').method('redirect').method('remove').method('vary').method('has').method('set').method('append').method('flushHeaders').access('status').access('message').access('body').access('length').access('type').access('lastModified').access('etag').getter('headerSent').getter('writable');
    delegate(proto, 'request').method('acceptsLanguages').method('acceptsEncodings').method('acceptsCharsets').method('accepts').method('get').method('is').access('querystring').access('idempotent').access('socket').access('search').access('method').access('query').access('path').access('url').access('accept').getter('origin').getter('href').getter('subdomains').getter('protocol').getter('host').getter('hostname').getter('URL').getter('header').getter('headers').getter('secure').getter('stale').getter('fresh').getter('ips').getter('ip');
}
,
"67a8eb72":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "spawnedKill", ()=>spawnedKill);
    module.o(exports, "spawnedCancel", ()=>spawnedCancel);
    module.o(exports, "setupTimeout", ()=>setupTimeout);
    module.o(exports, "validateTimeout", ()=>validateTimeout);
    module.o(exports, "setExitHandler", ()=>setExitHandler);
    var _f_node_os = module.i(farmRequire('node:os'));
    var _f_signal_exit = module.i(farmRequire("fb66eeb6"));
    const DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5;
    var spawnedKill = (kill, signal = 'SIGTERM', options = {})=>{
        const killResult = kill(signal);
        setKillTimeout(kill, signal, options, killResult);
        return killResult;
    };
    const setKillTimeout = (kill, signal, options, killResult)=>{
        if (!shouldForceKill(signal, options, killResult)) {
            return;
        }
        const timeout = getForceKillAfterTimeout(options);
        const t = setTimeout(()=>{
            kill('SIGKILL');
        }, timeout);
        if (t.unref) {
            t.unref();
        }
    };
    const shouldForceKill = (signal, { forceKillAfterTimeout }, killResult)=>isSigterm(signal) && forceKillAfterTimeout !== false && killResult;
    const isSigterm = (signal)=>signal === module.f(_f_node_os).constants.signals.SIGTERM || typeof signal === 'string' && signal.toUpperCase() === 'SIGTERM';
    const getForceKillAfterTimeout = ({ forceKillAfterTimeout = true })=>{
        if (forceKillAfterTimeout === true) {
            return DEFAULT_FORCE_KILL_TIMEOUT;
        }
        if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {
            throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
        }
        return forceKillAfterTimeout;
    };
    var spawnedCancel = (spawned, context)=>{
        const killResult = spawned.kill();
        if (killResult) {
            context.isCanceled = true;
        }
    };
    const timeoutKill = (spawned, signal, reject)=>{
        spawned.kill(signal);
        reject(Object.assign(new Error('Timed out'), {
            timedOut: true,
            signal
        }));
    };
    var setupTimeout = (spawned, { timeout, killSignal = 'SIGTERM' }, spawnedPromise)=>{
        if (timeout === 0 || timeout === undefined) {
            return spawnedPromise;
        }
        let timeoutId;
        const timeoutPromise = new Promise((resolve, reject)=>{
            timeoutId = setTimeout(()=>{
                timeoutKill(spawned, killSignal, reject);
            }, timeout);
        });
        const safeSpawnedPromise = spawnedPromise.finally(()=>{
            clearTimeout(timeoutId);
        });
        return Promise.race([
            timeoutPromise,
            safeSpawnedPromise
        ]);
    };
    var validateTimeout = ({ timeout })=>{
        if (timeout !== undefined && (!Number.isFinite(timeout) || timeout < 0)) {
            throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
        }
    };
    var setExitHandler = async (spawned, { cleanup, detached }, timedPromise)=>{
        if (!cleanup || detached) {
            return timedPromise;
        }
        const removeExitHandler = module.f(_f_signal_exit)(()=>{
            spawned.kill();
        });
        return timedPromise.finally(()=>{
            removeExitHandler();
        });
    };
}
,
"681483b0":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.createDirentFromStats = void 0;
    class DirentFromStats {
        constructor(name, stats){
            this.name = name;
            this.isBlockDevice = stats.isBlockDevice.bind(stats);
            this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
            this.isDirectory = stats.isDirectory.bind(stats);
            this.isFIFO = stats.isFIFO.bind(stats);
            this.isFile = stats.isFile.bind(stats);
            this.isSocket = stats.isSocket.bind(stats);
            this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
        }
    }
    function createDirentFromStats(name, stats) {
        return new DirentFromStats(name, stats);
    }
    exports.createDirentFromStats = createDirentFromStats;
}
,
"685edf14":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const path = global.nodeRequire('path', true);
    const WIN_SLASH = '\\\\/';
    const WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    const DOT_LITERAL = '\\.';
    const PLUS_LITERAL = '\\+';
    const QMARK_LITERAL = '\\?';
    const SLASH_LITERAL = '\\/';
    const ONE_CHAR = '(?=.)';
    const QMARK = '[^/]';
    const END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    const START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    const DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    const NO_DOT = `(?!${DOT_LITERAL})`;
    const NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    const NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    const NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    const QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    const STAR = `${QMARK}*?`;
    const POSIX_CHARS = {
        DOT_LITERAL,
        PLUS_LITERAL,
        QMARK_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        QMARK,
        END_ANCHOR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
    };
    const WINDOWS_CHARS = {
        ...POSIX_CHARS,
        SLASH_LITERAL: `[${WIN_SLASH}]`,
        QMARK: WIN_NO_SLASH,
        STAR: `${WIN_NO_SLASH}*?`,
        DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
        NO_DOT: `(?!${DOT_LITERAL})`,
        NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
        NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
        NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
        QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
        START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
        END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    };
    const POSIX_REGEX_SOURCE = {
        alnum: 'a-zA-Z0-9',
        alpha: 'a-zA-Z',
        ascii: '\\x00-\\x7F',
        blank: ' \\t',
        cntrl: '\\x00-\\x1F\\x7F',
        digit: '0-9',
        graph: '\\x21-\\x7E',
        lower: 'a-z',
        print: '\\x20-\\x7E ',
        punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
        space: ' \\t\\r\\n\\v\\f',
        upper: 'A-Z',
        word: 'A-Za-z0-9_',
        xdigit: 'A-Fa-f0-9'
    };
    module.exports = {
        MAX_LENGTH: 1024 * 64,
        POSIX_REGEX_SOURCE,
        REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
        REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
        REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
        REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
        REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
        REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
        REPLACEMENTS: {
            '***': '*',
            '**/**': '**',
            '**/**/**': '**'
        },
        CHAR_0: 48,
        CHAR_9: 57,
        CHAR_UPPERCASE_A: 65,
        CHAR_LOWERCASE_A: 97,
        CHAR_UPPERCASE_Z: 90,
        CHAR_LOWERCASE_Z: 122,
        CHAR_LEFT_PARENTHESES: 40,
        CHAR_RIGHT_PARENTHESES: 41,
        CHAR_ASTERISK: 42,
        CHAR_AMPERSAND: 38,
        CHAR_AT: 64,
        CHAR_BACKWARD_SLASH: 92,
        CHAR_CARRIAGE_RETURN: 13,
        CHAR_CIRCUMFLEX_ACCENT: 94,
        CHAR_COLON: 58,
        CHAR_COMMA: 44,
        CHAR_DOT: 46,
        CHAR_DOUBLE_QUOTE: 34,
        CHAR_EQUAL: 61,
        CHAR_EXCLAMATION_MARK: 33,
        CHAR_FORM_FEED: 12,
        CHAR_FORWARD_SLASH: 47,
        CHAR_GRAVE_ACCENT: 96,
        CHAR_HASH: 35,
        CHAR_HYPHEN_MINUS: 45,
        CHAR_LEFT_ANGLE_BRACKET: 60,
        CHAR_LEFT_CURLY_BRACE: 123,
        CHAR_LEFT_SQUARE_BRACKET: 91,
        CHAR_LINE_FEED: 10,
        CHAR_NO_BREAK_SPACE: 160,
        CHAR_PERCENT: 37,
        CHAR_PLUS: 43,
        CHAR_QUESTION_MARK: 63,
        CHAR_RIGHT_ANGLE_BRACKET: 62,
        CHAR_RIGHT_CURLY_BRACE: 125,
        CHAR_RIGHT_SQUARE_BRACKET: 93,
        CHAR_SEMICOLON: 59,
        CHAR_SINGLE_QUOTE: 39,
        CHAR_SPACE: 32,
        CHAR_TAB: 9,
        CHAR_UNDERSCORE: 95,
        CHAR_VERTICAL_LINE: 124,
        CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
        SEP: path.sep,
        extglobChars (chars) {
            return {
                '!': {
                    type: 'negate',
                    open: '(?:(?!(?:',
                    close: `))${chars.STAR})`
                },
                '?': {
                    type: 'qmark',
                    open: '(?:',
                    close: ')?'
                },
                '+': {
                    type: 'plus',
                    open: '(?:',
                    close: ')+'
                },
                '*': {
                    type: 'star',
                    open: '(?:',
                    close: ')*'
                },
                '@': {
                    type: 'at',
                    open: '(?:',
                    close: ')'
                }
            };
        },
        globChars (win32) {
            return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
        }
    };
}
,
"69e53775":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const fs = farmRequire("ffc819a8", true);
    function utimesMillis(path, atime, mtime, callback) {
        fs.open(path, 'r+', (err, fd)=>{
            if (err) return callback(err);
            fs.futimes(fd, atime, mtime, (futimesErr)=>{
                fs.close(fd, (closeErr)=>{
                    if (callback) callback(futimesErr || closeErr);
                });
            });
        });
    }
    function utimesMillisSync(path, atime, mtime) {
        const fd = fs.openSync(path, 'r+');
        fs.futimesSync(fd, atime, mtime);
        return fs.closeSync(fd);
    }
    module.exports = {
        utimesMillis,
        utimesMillisSync
    };
}
,
"69f658c7":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "default", ()=>defaultBrowserId);
    var _f_os = module.i(farmRequire('os'));
    var _f_fs = farmRequire('fs');
    var _f_bplist_parser = module.i(farmRequire("27f55093"));
    var _f_untildify = module.i(farmRequire("c658a5ad"));
    const macOsVersion = Number(module.f(_f_os).release().split('.')[0]);
    const filePath = module.f(_f_untildify)(macOsVersion >= 14 ? '~/Library/Preferences/com.apple.LaunchServices/com.apple.launchservices.secure.plist' : '~/Library/Preferences/com.apple.LaunchServices.plist');
    async function defaultBrowserId() {
        if (process.platform !== 'darwin') {
            throw new Error('macOS only');
        }
        let bundleId = 'com.apple.Safari';
        let buffer;
        try {
            buffer = await _f_fs.promises.readFile(filePath);
        } catch (error) {
            if (error.code === 'ENOENT') {
                return bundleId;
            }
            throw error;
        }
        const data = module.f(_f_bplist_parser).parseBuffer(buffer);
        const handlers = data && data[0].LSHandlers;
        if (!handlers || handlers.length === 0) {
            return bundleId;
        }
        for (const handler of handlers){
            if (handler.LSHandlerURLScheme === 'http' && handler.LSHandlerRoleAll) {
                bundleId = handler.LSHandlerRoleAll;
                break;
            }
        }
        return bundleId;
    }
}
,
"6c19eb1c":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "farmContextToViteContext", ()=>farmContextToViteContext);
    var _f_logger = farmRequire("8c2028dc");
    var _f_utils = farmRequire("e60815f7");
    const contextCache = new Map();
    function farmContextToViteContext(farmContext, currentHandlingFile, pluginName, hookName, config, hookContext) {
        const cacheKey = pluginName + hookName + currentHandlingFile;
        if (contextCache.has(cacheKey)) {
            return contextCache.get(cacheKey);
        }
        const logger = new _f_logger.Logger();
        const log = (message)=>{
            if (typeof message === 'function') {
                message = message();
            }
            console.log(message);
        };
        const cacheError = ()=>{
            throw new Error(`Vite plugin ${pluginName} is not compatible with Farm for now. Because cache(called by hook ${pluginName}.${hookName}) is not supported in Farm`);
        };
        const viteContext = {
            addWatchFile: (id)=>{
                if (!currentHandlingFile) {
                    throw new Error(`Vite plugin ${pluginName} is not compatible with Farm for now. Because addWatchFile(called by hook ${pluginName}.${hookName}) can only be called in load hook or transform hook in Farm.`);
                }
                farmContext.addWatchFile(currentHandlingFile, id);
            },
            debug: log,
            emitFile: (params)=>{
                if (params.type === 'asset') {
                    let content = [];
                    if (typeof params.source === 'string') {
                        content = [
                            ...Buffer.from(params.source)
                        ];
                    } else {
                        content = [
                            ...params.source
                        ];
                    }
                    farmContext.emitFile({
                        resolvedPath: currentHandlingFile ?? 'vite-plugin-adapter',
                        name: params.fileName ?? params.name,
                        content,
                        resourceType: 'asset'
                    });
                    return 'vite-plugin-adapter-unsupported-reference-id';
                } else {
                    throw new Error(`Vite plugin ${pluginName} is not compatible with Farm for now. Because emitFile(called by hook ${pluginName}.${hookName}) can only emit asset in Farm.`);
                }
            },
            error: (message)=>{
                let msgObj = message;
                if (typeof msgObj !== 'object') {
                    msgObj = {
                        message: message
                    };
                }
                if (msgObj.code && !msgObj.code.startsWith('PLUGIN_')) {
                    msgObj.pluginCode = 'PLUGIN_ERROR';
                } else {
                    msgObj.code = 'PLUGIN_ERROR';
                }
                msgObj.plugin = pluginName;
                msgObj.id = currentHandlingFile;
                msgObj.hook = hookName;
                farmContext.error(JSON.stringify(msgObj));
                return undefined;
            },
            getFileName: ()=>{
                throw new Error(`Vite plugin ${pluginName} is not compatible with Farm for now. Because getFileName(called by hook ${pluginName}.${hookName}) is not supported in Farm`);
            },
            getModuleIds: ()=>{
                throw new Error(`Vite plugin ${pluginName} is not compatible with Farm for now. Because getModuleIds(called by hook ${pluginName}.${hookName}) is not supported in Farm`);
            },
            getModuleInfo: ()=>{
                throw new Error(`Vite plugin ${pluginName} is not compatible with Farm for now. Because getModuleInfo(called by hook ${pluginName}.${hookName}) is not supported in Farm`);
            },
            getWatchFiles: ()=>{
                return farmContext.getWatchFiles();
            },
            info: log,
            load: (_)=>{
                throw new Error(`Vite plugin ${pluginName} is not compatible with Farm for now. Because load(called by hook ${pluginName}.${hookName}) is not supported in Farm`);
            },
            meta: {
                rollupVersion: '3.29.4',
                watchMode: config.compilation?.mode !== 'production'
            },
            parse: (_)=>{
                throw new Error(`Vite plugin ${pluginName} is not compatible with Farm for now. Because parse(called by hook ${pluginName}.${hookName}) is not supported in Farm`);
            },
            resolve: async (source, importer, options = {})=>{
                if (options.custom?.caller === `${pluginName}.${hookName}`) {
                    return null;
                }
                if (/^[a-zA-Z]:\//.test(importer)) {
                    importer = _f_utils.revertNormalizePath(importer);
                }
                const farmResolveResult = await farmContext.resolve({
                    source,
                    importer,
                    kind: options.isEntry ? 'entry' : 'import'
                }, {
                    meta: hookContext?.meta ?? {},
                    caller: `${pluginName}.${hookName}`
                });
                if (farmResolveResult) {
                    return {
                        id: _f_utils.normalizePath(farmResolveResult.resolvedPath),
                        external: farmResolveResult.external,
                        resolvedBy: 'vite-plugin-adapter-farm-resolve',
                        moduleSideEffects: farmResolveResult.sideEffects,
                        meta: {
                            ...farmResolveResult.meta,
                            caller: `${pluginName}.${hookName}`
                        },
                        assertions: {},
                        syntheticNamedExports: false
                    };
                }
                return null;
            },
            setAssetSource (assetReferenceId, source) {
                this.emitFile({
                    type: 'asset',
                    source,
                    name: assetReferenceId
                });
            },
            warn: (message)=>{
                if (typeof message === 'object') {
                    farmContext.warn(JSON.stringify(message));
                } else if (typeof message === 'function') {
                    farmContext.warn(JSON.stringify(message()));
                } else {
                    farmContext.warn(message);
                }
            },
            cache: {
                set: cacheError,
                get: cacheError,
                delete: cacheError,
                has: cacheError
            },
            moduleIds: new Set()[Symbol.iterator](),
            getCombinedSourcemap () {
                logger.warn('`vite-plugin-adapter`: getCombinedSourcemap is not supported in Farm for now. It will always return undefined.');
                return undefined;
            }
        };
        contextCache.set(cacheKey, viteContext);
        return viteContext;
    }
}
,
"6c899748":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "getSignals", ()=>getSignals);
    var _f_node_os = farmRequire("node:os");
    var _f_core = farmRequire("5ef97856");
    var _f_realtime = farmRequire("abc9f14f");
    var getSignals = ()=>{
        const realtimeSignals = _f_realtime.getRealtimeSignals();
        const signals = [
            ..._f_core.SIGNALS,
            ...realtimeSignals
        ].map(normalizeSignal);
        return signals;
    };
    const normalizeSignal = ({ name, number: defaultNumber, description, action, forced = false, standard })=>{
        const { signals: { [name]: constantSignal } } = _f_node_os.constants;
        const supported = constantSignal !== undefined;
        const number = supported ? constantSignal : defaultNumber;
        return {
            name,
            number,
            description,
            supported,
            action,
            forced,
            standard
        };
    };
}
,
"6cc7e919":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const async_1 = farmRequire("05c5e7d0", true);
    class AsyncProvider {
        constructor(_root, _settings){
            this._root = _root;
            this._settings = _settings;
            this._reader = new async_1.default(this._root, this._settings);
            this._storage = [];
        }
        read(callback) {
            this._reader.onError((error)=>{
                callFailureCallback(callback, error);
            });
            this._reader.onEntry((entry)=>{
                this._storage.push(entry);
            });
            this._reader.onEnd(()=>{
                callSuccessCallback(callback, this._storage);
            });
            this._reader.read();
        }
    }
    exports.default = AsyncProvider;
    function callFailureCallback(callback, error) {
        callback(error);
    }
    function callSuccessCallback(callback, entries) {
        callback(null, entries);
    }
}
,
"6ce4fd89":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "runAppleScriptAsync", ()=>runAppleScriptAsync);
    var _f_execa = module.i(farmRequire("a9709252"));
    async function runAppleScriptAsync(script) {
        if (process.platform !== 'darwin') {
            throw new Error('macOS only');
        }
        const { stdout } = await module.f(_f_execa)('osascript', [
            '-e',
            script
        ]);
        return stdout;
    }
}
,
"6d02a8d3":function  (module, exports, farmRequire, farmDynamicRequire) {
    var slice = Array.prototype.slice;
    module.exports = co['default'] = co.co = co;
    co.wrap = function(fn) {
        createPromise.__generatorFunction__ = fn;
        return createPromise;
        function createPromise() {
            return co.call(this, fn.apply(this, arguments));
        }
    };
    function co(gen) {
        var ctx = this;
        var args = slice.call(arguments, 1);
        return new Promise(function(resolve, reject) {
            if (typeof gen === 'function') gen = gen.apply(ctx, args);
            if (!gen || typeof gen.next !== 'function') return resolve(gen);
            onFulfilled();
            function onFulfilled(res) {
                var ret;
                try {
                    ret = gen.next(res);
                } catch (e) {
                    return reject(e);
                }
                next(ret);
            }
            function onRejected(err) {
                var ret;
                try {
                    ret = gen.throw(err);
                } catch (e) {
                    return reject(e);
                }
                next(ret);
            }
            function next(ret) {
                if (ret.done) return resolve(ret.value);
                var value = toPromise.call(ctx, ret.value);
                if (value && isPromise(value)) return value.then(onFulfilled, onRejected);
                return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, ' + 'but the following object was passed: "' + String(ret.value) + '"'));
            }
        });
    }
    function toPromise(obj) {
        if (!obj) return obj;
        if (isPromise(obj)) return obj;
        if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj);
        if ('function' == typeof obj) return thunkToPromise.call(this, obj);
        if (Array.isArray(obj)) return arrayToPromise.call(this, obj);
        if (isObject(obj)) return objectToPromise.call(this, obj);
        return obj;
    }
    function thunkToPromise(fn) {
        var ctx = this;
        return new Promise(function(resolve, reject) {
            fn.call(ctx, function(err, res) {
                if (err) return reject(err);
                if (arguments.length > 2) res = slice.call(arguments, 1);
                resolve(res);
            });
        });
    }
    function arrayToPromise(obj) {
        return Promise.all(obj.map(toPromise, this));
    }
    function objectToPromise(obj) {
        var results = new obj.constructor();
        var keys = Object.keys(obj);
        var promises = [];
        for(var i = 0; i < keys.length; i++){
            var key = keys[i];
            var promise = toPromise.call(this, obj[key]);
            if (promise && isPromise(promise)) defer(promise, key);
            else results[key] = obj[key];
        }
        return Promise.all(promises).then(function() {
            return results;
        });
        function defer(promise, key) {
            results[key] = undefined;
            promises.push(promise.then(function(res) {
                results[key] = res;
            }));
        }
    }
    function isPromise(obj) {
        return 'function' == typeof obj.then;
    }
    function isGenerator(obj) {
        return 'function' == typeof obj.next && 'function' == typeof obj.throw;
    }
    function isGeneratorFunction(obj) {
        var constructor = obj.constructor;
        if (!constructor) return false;
        if ('GeneratorFunction' === constructor.name || 'GeneratorFunction' === constructor.displayName) return true;
        return isGenerator(constructor.prototype);
    }
    function isObject(val) {
        return Object == val.constructor;
    }
}
,
"6d2efa8f":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    try {
        module.exports = farmRequire("b6e736ca")(__dirname);
    } catch (e) {
        module.exports = farmRequire("6682f7cd", true);
    }
}
,
"6d9407b3":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const os = global.nodeRequire('os', true);
    const tty = global.nodeRequire('tty', true);
    const hasFlag = farmRequire("1b291d05", true);
    const { env } = process;
    let flagForceColor;
    if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false') || hasFlag('color=never')) {
        flagForceColor = 0;
    } else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
        flagForceColor = 1;
    }
    function envForceColor() {
        if ('FORCE_COLOR' in env) {
            if (env.FORCE_COLOR === 'true') {
                return 1;
            }
            if (env.FORCE_COLOR === 'false') {
                return 0;
            }
            return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
        }
    }
    function translateLevel(level) {
        if (level === 0) {
            return false;
        }
        return {
            level,
            hasBasic: true,
            has256: level >= 2,
            has16m: level >= 3
        };
    }
    function supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
        const noFlagForceColor = envForceColor();
        if (noFlagForceColor !== undefined) {
            flagForceColor = noFlagForceColor;
        }
        const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
        if (forceColor === 0) {
            return 0;
        }
        if (sniffFlags) {
            if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
                return 3;
            }
            if (hasFlag('color=256')) {
                return 2;
            }
        }
        if (haveStream && !streamIsTTY && forceColor === undefined) {
            return 0;
        }
        const min = forceColor || 0;
        if (env.TERM === 'dumb') {
            return min;
        }
        if (process.platform === 'win32') {
            const osRelease = os.release().split('.');
            if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
                return Number(osRelease[2]) >= 14931 ? 3 : 2;
            }
            return 1;
        }
        if ('CI' in env) {
            if ([
                'TRAVIS',
                'CIRCLECI',
                'APPVEYOR',
                'GITLAB_CI',
                'GITHUB_ACTIONS',
                'BUILDKITE',
                'DRONE'
            ].some((sign)=>sign in env) || env.CI_NAME === 'codeship') {
                return 1;
            }
            return min;
        }
        if ('TEAMCITY_VERSION' in env) {
            return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
        }
        if (env.COLORTERM === 'truecolor') {
            return 3;
        }
        if ('TERM_PROGRAM' in env) {
            const version = Number.parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);
            switch(env.TERM_PROGRAM){
                case 'iTerm.app':
                    return version >= 3 ? 3 : 2;
                case 'Apple_Terminal':
                    return 2;
            }
        }
        if (/-256(color)?$/i.test(env.TERM)) {
            return 2;
        }
        if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
            return 1;
        }
        if ('COLORTERM' in env) {
            return 1;
        }
        return min;
    }
    function getSupportLevel(stream, options = {}) {
        const level = supportsColor(stream, {
            streamIsTTY: stream && stream.isTTY,
            ...options
        });
        return translateLevel(level);
    }
    module.exports = {
        supportsColor: getSupportLevel,
        stdout: getSupportLevel({
            isTTY: tty.isatty(1)
        }),
        stderr: getSupportLevel({
            isTTY: tty.isatty(2)
        })
    };
}
,
"6e017c36":/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ function  (module, exports, farmRequire, farmDynamicRequire) {
    let promise;
    module.exports = typeof queueMicrotask === 'function' ? queueMicrotask.bind(typeof window !== 'undefined' ? window : global) : (cb)=>(promise || (promise = Promise.resolve())).then(cb).catch((err)=>setTimeout(()=>{
                throw err;
            }, 0));
}
,
"6e9f2004":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const zlib = global.nodeRequire('zlib', true);
    const bufferUtil = farmRequire("2be17525", true);
    const Limiter = farmRequire("000f5984", true);
    const { kStatusCode } = farmRequire("75844d1d", true);
    const FastBuffer = Buffer[Symbol.species];
    const TRAILER = Buffer.from([
        0x00,
        0x00,
        0xff,
        0xff
    ]);
    const kPerMessageDeflate = Symbol('permessage-deflate');
    const kTotalLength = Symbol('total-length');
    const kCallback = Symbol('callback');
    const kBuffers = Symbol('buffers');
    const kError = Symbol('error');
    let zlibLimiter;
    class PerMessageDeflate {
        constructor(options, isServer, maxPayload){
            this._maxPayload = maxPayload | 0;
            this._options = options || {};
            this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;
            this._isServer = !!isServer;
            this._deflate = null;
            this._inflate = null;
            this.params = null;
            if (!zlibLimiter) {
                const concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;
                zlibLimiter = new Limiter(concurrency);
            }
        }
        static get extensionName() {
            return 'permessage-deflate';
        }
        offer() {
            const params = {};
            if (this._options.serverNoContextTakeover) {
                params.server_no_context_takeover = true;
            }
            if (this._options.clientNoContextTakeover) {
                params.client_no_context_takeover = true;
            }
            if (this._options.serverMaxWindowBits) {
                params.server_max_window_bits = this._options.serverMaxWindowBits;
            }
            if (this._options.clientMaxWindowBits) {
                params.client_max_window_bits = this._options.clientMaxWindowBits;
            } else if (this._options.clientMaxWindowBits == null) {
                params.client_max_window_bits = true;
            }
            return params;
        }
        accept(configurations) {
            configurations = this.normalizeParams(configurations);
            this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
            return this.params;
        }
        cleanup() {
            if (this._inflate) {
                this._inflate.close();
                this._inflate = null;
            }
            if (this._deflate) {
                const callback = this._deflate[kCallback];
                this._deflate.close();
                this._deflate = null;
                if (callback) {
                    callback(new Error('The deflate stream was closed while data was being processed'));
                }
            }
        }
        acceptAsServer(offers) {
            const opts = this._options;
            const accepted = offers.find((params)=>{
                if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === 'number' && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === 'number' && !params.client_max_window_bits) {
                    return false;
                }
                return true;
            });
            if (!accepted) {
                throw new Error('None of the extension offers can be accepted');
            }
            if (opts.serverNoContextTakeover) {
                accepted.server_no_context_takeover = true;
            }
            if (opts.clientNoContextTakeover) {
                accepted.client_no_context_takeover = true;
            }
            if (typeof opts.serverMaxWindowBits === 'number') {
                accepted.server_max_window_bits = opts.serverMaxWindowBits;
            }
            if (typeof opts.clientMaxWindowBits === 'number') {
                accepted.client_max_window_bits = opts.clientMaxWindowBits;
            } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
                delete accepted.client_max_window_bits;
            }
            return accepted;
        }
        acceptAsClient(response) {
            const params = response[0];
            if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
                throw new Error('Unexpected parameter "client_no_context_takeover"');
            }
            if (!params.client_max_window_bits) {
                if (typeof this._options.clientMaxWindowBits === 'number') {
                    params.client_max_window_bits = this._options.clientMaxWindowBits;
                }
            } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === 'number' && params.client_max_window_bits > this._options.clientMaxWindowBits) {
                throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
            }
            return params;
        }
        normalizeParams(configurations) {
            configurations.forEach((params)=>{
                Object.keys(params).forEach((key)=>{
                    let value = params[key];
                    if (value.length > 1) {
                        throw new Error(`Parameter "${key}" must have only a single value`);
                    }
                    value = value[0];
                    if (key === 'client_max_window_bits') {
                        if (value !== true) {
                            const num = +value;
                            if (!Number.isInteger(num) || num < 8 || num > 15) {
                                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                            }
                            value = num;
                        } else if (!this._isServer) {
                            throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                        }
                    } else if (key === 'server_max_window_bits') {
                        const num = +value;
                        if (!Number.isInteger(num) || num < 8 || num > 15) {
                            throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                        }
                        value = num;
                    } else if (key === 'client_no_context_takeover' || key === 'server_no_context_takeover') {
                        if (value !== true) {
                            throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                        }
                    } else {
                        throw new Error(`Unknown parameter "${key}"`);
                    }
                    params[key] = value;
                });
            });
            return configurations;
        }
        decompress(data, fin, callback) {
            zlibLimiter.add((done)=>{
                this._decompress(data, fin, (err, result)=>{
                    done();
                    callback(err, result);
                });
            });
        }
        compress(data, fin, callback) {
            zlibLimiter.add((done)=>{
                this._compress(data, fin, (err, result)=>{
                    done();
                    callback(err, result);
                });
            });
        }
        _decompress(data, fin, callback) {
            const endpoint = this._isServer ? 'client' : 'server';
            if (!this._inflate) {
                const key = `${endpoint}_max_window_bits`;
                const windowBits = typeof this.params[key] !== 'number' ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
                this._inflate = zlib.createInflateRaw({
                    ...this._options.zlibInflateOptions,
                    windowBits
                });
                this._inflate[kPerMessageDeflate] = this;
                this._inflate[kTotalLength] = 0;
                this._inflate[kBuffers] = [];
                this._inflate.on('error', inflateOnError);
                this._inflate.on('data', inflateOnData);
            }
            this._inflate[kCallback] = callback;
            this._inflate.write(data);
            if (fin) this._inflate.write(TRAILER);
            this._inflate.flush(()=>{
                const err = this._inflate[kError];
                if (err) {
                    this._inflate.close();
                    this._inflate = null;
                    callback(err);
                    return;
                }
                const data = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
                if (this._inflate._readableState.endEmitted) {
                    this._inflate.close();
                    this._inflate = null;
                } else {
                    this._inflate[kTotalLength] = 0;
                    this._inflate[kBuffers] = [];
                    if (fin && this.params[`${endpoint}_no_context_takeover`]) {
                        this._inflate.reset();
                    }
                }
                callback(null, data);
            });
        }
        _compress(data, fin, callback) {
            const endpoint = this._isServer ? 'server' : 'client';
            if (!this._deflate) {
                const key = `${endpoint}_max_window_bits`;
                const windowBits = typeof this.params[key] !== 'number' ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
                this._deflate = zlib.createDeflateRaw({
                    ...this._options.zlibDeflateOptions,
                    windowBits
                });
                this._deflate[kTotalLength] = 0;
                this._deflate[kBuffers] = [];
                this._deflate.on('data', deflateOnData);
            }
            this._deflate[kCallback] = callback;
            this._deflate.write(data);
            this._deflate.flush(zlib.Z_SYNC_FLUSH, ()=>{
                if (!this._deflate) {
                    return;
                }
                let data = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
                if (fin) {
                    data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);
                }
                this._deflate[kCallback] = null;
                this._deflate[kTotalLength] = 0;
                this._deflate[kBuffers] = [];
                if (fin && this.params[`${endpoint}_no_context_takeover`]) {
                    this._deflate.reset();
                }
                callback(null, data);
            });
        }
    }
    module.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
        this[kBuffers].push(chunk);
        this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
        this[kTotalLength] += chunk.length;
        if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
            this[kBuffers].push(chunk);
            return;
        }
        this[kError] = new RangeError('Max payload size exceeded');
        this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';
        this[kError][kStatusCode] = 1009;
        this.removeListener('data', inflateOnData);
        this.reset();
    }
    function inflateOnError(err) {
        this[kPerMessageDeflate]._inflate = null;
        err[kStatusCode] = 1007;
        this[kCallback](err);
    }
}
,
"6f03e0ed":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const aliases = [
        'stdin',
        'stdout',
        'stderr'
    ];
    const hasAlias = (options)=>aliases.some((alias)=>options[alias] !== undefined);
    const normalizeStdio = (options)=>{
        if (!options) {
            return;
        }
        const { stdio } = options;
        if (stdio === undefined) {
            return aliases.map((alias)=>options[alias]);
        }
        if (hasAlias(options)) {
            throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${aliases.map((alias)=>`\`${alias}\``).join(', ')}`);
        }
        if (typeof stdio === 'string') {
            return stdio;
        }
        if (!Array.isArray(stdio)) {
            throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
        }
        const length = Math.max(stdio.length, aliases.length);
        return Array.from({
            length
        }, (value, index)=>stdio[index]);
    };
    module.exports = normalizeStdio;
    module.exports.node = (options)=>{
        const stdio = normalizeStdio(options);
        if (stdio === 'ipc') {
            return 'ipc';
        }
        if (stdio === undefined || typeof stdio === 'string') {
            return [
                stdio,
                stdio,
                stdio,
                'ipc'
            ];
        }
        if (stdio.includes('ipc')) {
            return stdio;
        }
        return [
            ...stdio,
            'ipc'
        ];
    };
}
,
"6f6d4eaf":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "getAdditionContext", ()=>getAdditionContext);
    module.o(exports, "throwError", ()=>throwError);
    module.o(exports, "getAliasEntries", ()=>getAliasEntries);
    module.o(exports, "transformAliasWithVite", ()=>transformAliasWithVite);
    var _f_node_fs = module.i(farmRequire('node:fs'));
    var _f_node_path = farmRequire('node:path');
    var getAdditionContext = async (cwd, option, currentFile, content, ctx, pluginName)=>{
        const { globals = [], additionalData } = option;
        const result = globals.reduce((result, file)=>{
            let filepath;
            if (_f_node_path.isAbsolute(file)) {
                filepath = file;
            } else {
                filepath = _f_node_path.join(cwd, file);
            }
            try {
                result.push(module.f(_f_node_fs).readFileSync(filepath, 'utf-8'));
                ctx.addWatchFile(currentFile, filepath);
            } catch (error) {
                throwError(pluginName, 'read', error);
            }
            return result;
        }, []);
        if (additionalData) {
            if (typeof additionalData === 'string') {
                result.push(additionalData);
            } else {
                result.push(await additionalData(content, currentFile));
            }
        }
        return result.join('\n');
    };
    function throwError(pluginName, type, error) {
        throw new Error(`[${pluginName} ${type} Error] ${error?.stack ?? error}`);
    }
    function getAliasEntries(entries) {
        if (!entries || !Object.keys(entries).length) {
            return [];
        }
        if (Array.isArray(entries)) {
            return entries.map((entry)=>{
                return {
                    find: entry.find,
                    replacement: entry.replacement
                };
            });
        } else if (typeof entries === 'object') {
            return Object.entries(entries).map(([key, value])=>{
                return {
                    find: key,
                    replacement: value
                };
            });
        }
        return [];
    }
    function transformAliasWithVite(alias) {
        return alias.reduce((acc, item)=>{
            acc[item.find] = item.replacement;
            return acc;
        }, {});
    }
}
,
"712c2dd4":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    exports.fromCallback = function(fn) {
        return Object.defineProperty(function(...args) {
            if (typeof args[args.length - 1] === 'function') fn.apply(this, args);
            else {
                return new Promise((resolve, reject)=>{
                    args.push((err, res)=>err != null ? reject(err) : resolve(res));
                    fn.apply(this, args);
                });
            }
        }, 'name', {
            value: fn.name
        });
    };
    exports.fromPromise = function(fn) {
        return Object.defineProperty(function(...args) {
            const cb = args[args.length - 1];
            if (typeof cb !== 'function') return fn.apply(this, args);
            else {
                args.pop();
                fn.apply(this, args).then((r)=>cb(null, r), cb);
            }
        }, 'name', {
            value: fn.name
        });
    };
}
,
"7139422c":function  (module, exports, farmRequire, farmDynamicRequire) {
    var createError = farmRequire("48aa4d88", true);
    var eql = farmRequire("c3831ec6", true);
    module.exports = assert;
    function assert(value, status, msg, opts) {
        if (value) return;
        throw createError(status, msg, opts);
    }
    assert.fail = function(status, msg, opts) {
        assert(false, status, msg, opts);
    };
    assert.equal = function(a, b, status, msg, opts) {
        assert(a == b, status, msg, opts);
    };
    assert.notEqual = function(a, b, status, msg, opts) {
        assert(a != b, status, msg, opts);
    };
    assert.ok = function(value, status, msg, opts) {
        assert(value, status, msg, opts);
    };
    assert.strictEqual = function(a, b, status, msg, opts) {
        assert(a === b, status, msg, opts);
    };
    assert.notStrictEqual = function(a, b, status, msg, opts) {
        assert(a !== b, status, msg, opts);
    };
    assert.deepEqual = function(a, b, status, msg, opts) {
        assert(eql(a, b), status, msg, opts);
    };
    assert.notDeepEqual = function(a, b, status, msg, opts) {
        assert(!eql(a, b), status, msg, opts);
    };
}
,
"71758cda":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.readdir = exports.readdirWithFileTypes = exports.read = void 0;
    const fsStat = farmRequire("be5cf725", true);
    const constants_1 = farmRequire("5dd9d74a", true);
    const utils = farmRequire("a9271465", true);
    const common = farmRequire("8ac9b201", true);
    function read(directory, settings) {
        if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
            return readdirWithFileTypes(directory, settings);
        }
        return readdir(directory, settings);
    }
    exports.read = read;
    function readdirWithFileTypes(directory, settings) {
        const dirents = settings.fs.readdirSync(directory, {
            withFileTypes: true
        });
        return dirents.map((dirent)=>{
            const entry = {
                dirent,
                name: dirent.name,
                path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
            };
            if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
                try {
                    const stats = settings.fs.statSync(entry.path);
                    entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
                } catch (error) {
                    if (settings.throwErrorOnBrokenSymbolicLink) {
                        throw error;
                    }
                }
            }
            return entry;
        });
    }
    exports.readdirWithFileTypes = readdirWithFileTypes;
    function readdir(directory, settings) {
        const names = settings.fs.readdirSync(directory);
        return names.map((name)=>{
            const entryPath = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
            const stats = fsStat.statSync(entryPath, settings.fsStatSettings);
            const entry = {
                name,
                path: entryPath,
                dirent: utils.fs.createDirentFromStats(name, stats)
            };
            if (settings.stats) {
                entry.stats = stats;
            }
            return entry;
        });
    }
    exports.readdir = readdir;
}
,
"73492c43":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const path = global.nodeRequire('path', true);
    const fs = farmRequire("ffc819a8", true);
    const pathExists = farmRequire("05a93efb", true).pathExists;
    function symlinkPaths(srcpath, dstpath, callback) {
        if (path.isAbsolute(srcpath)) {
            return fs.lstat(srcpath, (err)=>{
                if (err) {
                    err.message = err.message.replace('lstat', 'ensureSymlink');
                    return callback(err);
                }
                return callback(null, {
                    toCwd: srcpath,
                    toDst: srcpath
                });
            });
        } else {
            const dstdir = path.dirname(dstpath);
            const relativeToDst = path.join(dstdir, srcpath);
            return pathExists(relativeToDst, (err, exists)=>{
                if (err) return callback(err);
                if (exists) {
                    return callback(null, {
                        toCwd: relativeToDst,
                        toDst: srcpath
                    });
                } else {
                    return fs.lstat(srcpath, (err)=>{
                        if (err) {
                            err.message = err.message.replace('lstat', 'ensureSymlink');
                            return callback(err);
                        }
                        return callback(null, {
                            toCwd: srcpath,
                            toDst: path.relative(dstdir, srcpath)
                        });
                    });
                }
            });
        }
    }
    function symlinkPathsSync(srcpath, dstpath) {
        let exists;
        if (path.isAbsolute(srcpath)) {
            exists = fs.existsSync(srcpath);
            if (!exists) throw new Error('absolute srcpath does not exist');
            return {
                toCwd: srcpath,
                toDst: srcpath
            };
        } else {
            const dstdir = path.dirname(dstpath);
            const relativeToDst = path.join(dstdir, srcpath);
            exists = fs.existsSync(relativeToDst);
            if (exists) {
                return {
                    toCwd: relativeToDst,
                    toDst: srcpath
                };
            } else {
                exists = fs.existsSync(srcpath);
                if (!exists) throw new Error('relative srcpath does not exist');
                return {
                    toCwd: srcpath,
                    toDst: path.relative(dstdir, srcpath)
                };
            }
        }
    }
    module.exports = {
        symlinkPaths,
        symlinkPathsSync
    };
}
,
"73e7c96d":function  (module, exports, farmRequire, farmDynamicRequire) {
    var s = 1000;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
        options = options || {};
        var type = typeof val;
        if (type === 'string' && val.length > 0) {
            return parse(val);
        } else if (type === 'number' && isFinite(val)) {
            return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
    };
    function parse(str) {
        str = String(str);
        if (str.length > 100) {
            return;
        }
        var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
        if (!match) {
            return;
        }
        var n = parseFloat(match[1]);
        var type = (match[2] || 'ms').toLowerCase();
        switch(type){
            case 'years':
            case 'year':
            case 'yrs':
            case 'yr':
            case 'y':
                return n * y;
            case 'weeks':
            case 'week':
            case 'w':
                return n * w;
            case 'days':
            case 'day':
            case 'd':
                return n * d;
            case 'hours':
            case 'hour':
            case 'hrs':
            case 'hr':
            case 'h':
                return n * h;
            case 'minutes':
            case 'minute':
            case 'mins':
            case 'min':
            case 'm':
                return n * m;
            case 'seconds':
            case 'second':
            case 'secs':
            case 'sec':
            case 's':
                return n * s;
            case 'milliseconds':
            case 'millisecond':
            case 'msecs':
            case 'msec':
            case 'ms':
                return n;
            default:
                return undefined;
        }
    }
    function fmtShort(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
            return Math.round(ms / d) + 'd';
        }
        if (msAbs >= h) {
            return Math.round(ms / h) + 'h';
        }
        if (msAbs >= m) {
            return Math.round(ms / m) + 'm';
        }
        if (msAbs >= s) {
            return Math.round(ms / s) + 's';
        }
        return ms + 'ms';
    }
    function fmtLong(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
            return plural(ms, msAbs, d, 'day');
        }
        if (msAbs >= h) {
            return plural(ms, msAbs, h, 'hour');
        }
        if (msAbs >= m) {
            return plural(ms, msAbs, m, 'minute');
        }
        if (msAbs >= s) {
            return plural(ms, msAbs, s, 'second');
        }
        return ms + ' ms';
    }
    function plural(ms, msAbs, n, name) {
        var isPlural = msAbs >= n * 1.5;
        return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
    }
}
,
"74fe7e72":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const utils = farmRequire("781fd2fa", true);
    class EntryTransformer {
        constructor(_settings){
            this._settings = _settings;
        }
        getTransformer() {
            return (entry)=>this._transform(entry);
        }
        _transform(entry) {
            let filepath = entry.path;
            if (this._settings.absolute) {
                filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);
                filepath = utils.path.unixify(filepath);
            }
            if (this._settings.markDirectories && entry.dirent.isDirectory()) {
                filepath += '/';
            }
            if (!this._settings.objectMode) {
                return filepath;
            }
            return Object.assign(Object.assign({}, entry), {
                path: filepath
            });
        }
    }
    exports.default = EntryTransformer;
}
,
"7572a256":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const isStream = (stream)=>stream !== null && typeof stream === 'object' && typeof stream.pipe === 'function';
    isStream.writable = (stream)=>isStream(stream) && stream.writable !== false && typeof stream._write === 'function' && typeof stream._writableState === 'object';
    isStream.readable = (stream)=>isStream(stream) && stream.readable !== false && typeof stream._read === 'function' && typeof stream._readableState === 'object';
    isStream.duplex = (stream)=>isStream.writable(stream) && isStream.readable(stream);
    isStream.transform = (stream)=>isStream.duplex(stream) && typeof stream._transform === 'function';
    module.exports = isStream;
}
,
"75844d1d":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    module.exports = {
        BINARY_TYPES: [
            'nodebuffer',
            'arraybuffer',
            'fragments'
        ],
        EMPTY_BUFFER: Buffer.alloc(0),
        GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
        kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),
        kListener: Symbol('kListener'),
        kStatusCode: Symbol('status-code'),
        kWebSocket: Symbol('websocket'),
        NOOP: ()=>{}
    };
}
,
"76e61d33":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    function isValidUTF8(buf) {
        const len = buf.length;
        let i = 0;
        while(i < len){
            if ((buf[i] & 0x80) === 0x00) {
                i++;
            } else if ((buf[i] & 0xe0) === 0xc0) {
                if (i + 1 === len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i] & 0xfe) === 0xc0) {
                    return false;
                }
                i += 2;
            } else if ((buf[i] & 0xf0) === 0xe0) {
                if (i + 2 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 || buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) {
                    return false;
                }
                i += 3;
            } else if ((buf[i] & 0xf8) === 0xf0) {
                if (i + 3 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || (buf[i + 3] & 0xc0) !== 0x80 || buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 || buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4) {
                    return false;
                }
                i += 4;
            } else {
                return false;
            }
        }
        return true;
    }
    module.exports = isValidUTF8;
}
,
"774c471c":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    module.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
        return obj.__proto__;
    };
    function clone(obj) {
        if (obj === null || typeof obj !== 'object') return obj;
        if (obj instanceof Object) var copy = {
            __proto__: getPrototypeOf(obj)
        };
        else var copy = Object.create(null);
        Object.getOwnPropertyNames(obj).forEach(function(key) {
            Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
        });
        return copy;
    }
}
,
"776bdf70":function  (module, exports, farmRequire, farmDynamicRequire) {
    module.exports = [
        'SIGABRT',
        'SIGALRM',
        'SIGHUP',
        'SIGINT',
        'SIGTERM'
    ];
    if (process.platform !== 'win32') {
        module.exports.push('SIGVTALRM', 'SIGXCPU', 'SIGXFSZ', 'SIGUSR2', 'SIGTRAP', 'SIGSYS', 'SIGQUIT', 'SIGIOT');
    }
    if (process.platform === 'linux') {
        module.exports.push('SIGIO', 'SIGPOLL', 'SIGPWR', 'SIGSTKFLT', 'SIGUNUSED');
    }
}
,
"77e37188":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    module.exports = {
        ...farmRequire("f2e2163e", true),
        ...farmRequire("d1ce3aa3", true),
        ...farmRequire("f491c1b2", true),
        ...farmRequire("290c4885", true),
        ...farmRequire("580b8c97", true),
        ...farmRequire("abdb8a71", true),
        ...farmRequire("4a5b9174", true),
        ...farmRequire("f69bc856", true),
        ...farmRequire("05a93efb", true),
        ...farmRequire("4ffdf2a8", true)
    };
}
,
"77e5a0f9":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const u = farmRequire("712c2dd4", true).fromCallback;
    const path = global.nodeRequire('path', true);
    const fs = farmRequire("ffc819a8", true);
    const mkdir = farmRequire("abdb8a71", true);
    const pathExists = farmRequire("05a93efb", true).pathExists;
    const { areIdentical } = farmRequire("9c9fbd11", true);
    function createLink(srcpath, dstpath, callback) {
        function makeLink(srcpath, dstpath) {
            fs.link(srcpath, dstpath, (err)=>{
                if (err) return callback(err);
                callback(null);
            });
        }
        fs.lstat(dstpath, (_, dstStat)=>{
            fs.lstat(srcpath, (err, srcStat)=>{
                if (err) {
                    err.message = err.message.replace('lstat', 'ensureLink');
                    return callback(err);
                }
                if (dstStat && areIdentical(srcStat, dstStat)) return callback(null);
                const dir = path.dirname(dstpath);
                pathExists(dir, (err, dirExists)=>{
                    if (err) return callback(err);
                    if (dirExists) return makeLink(srcpath, dstpath);
                    mkdir.mkdirs(dir, (err)=>{
                        if (err) return callback(err);
                        makeLink(srcpath, dstpath);
                    });
                });
            });
        });
    }
    function createLinkSync(srcpath, dstpath) {
        let dstStat;
        try {
            dstStat = fs.lstatSync(dstpath);
        } catch  {}
        try {
            const srcStat = fs.lstatSync(srcpath);
            if (dstStat && areIdentical(srcStat, dstStat)) return;
        } catch (err) {
            err.message = err.message.replace('lstat', 'ensureLink');
            throw err;
        }
        const dir = path.dirname(dstpath);
        const dirExists = fs.existsSync(dir);
        if (dirExists) return fs.linkSync(srcpath, dstpath);
        mkdir.mkdirsSync(dir);
        return fs.linkSync(srcpath, dstpath);
    }
    module.exports = {
        createLink: u(createLink),
        createLinkSync
    };
}
,
"781fd2fa":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.string = exports.stream = exports.pattern = exports.path = exports.fs = exports.errno = exports.array = void 0;
    const array = farmRequire("b3530deb", true);
    exports.array = array;
    const errno = farmRequire("673480b1", true);
    exports.errno = errno;
    const fs = farmRequire("681483b0", true);
    exports.fs = fs;
    const path = farmRequire("465cd123", true);
    exports.path = path;
    const pattern = farmRequire("24c29448", true);
    exports.pattern = pattern;
    const stream = farmRequire("408b3b5b", true);
    exports.stream = stream;
    const string = farmRequire("a4db3af6", true);
    exports.string = string;
}
,
"787884bd":/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    module.exports = function(num) {
        if (typeof num === 'number') {
            return num - num === 0;
        }
        if (typeof num === 'string' && num.trim() !== '') {
            return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
        }
        return false;
    };
}
,
"79404dc4":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.legacyCreateProxyMiddleware = void 0;
    var create_proxy_middleware_1 = farmRequire("2349f859", true);
    Object.defineProperty(exports, "legacyCreateProxyMiddleware", {
        enumerable: true,
        get: function() {
            return create_proxy_middleware_1.legacyCreateProxyMiddleware;
        }
    });
}
,
"7942e799":/*!
 * keygrip
 * Copyright(c) 2011-2014 Jed Schmidt
 * MIT Licensed
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    var compare = farmRequire("e78d61ad", true);
    var crypto = global.nodeRequire("crypto", true);
    function Keygrip(keys, algorithm, encoding) {
        if (!algorithm) algorithm = "sha1";
        if (!encoding) encoding = "base64";
        if (!(this instanceof Keygrip)) return new Keygrip(keys, algorithm, encoding);
        if (!keys || !(0 in keys)) {
            throw new Error("Keys must be provided.");
        }
        function sign(data, key) {
            return crypto.createHmac(algorithm, key).update(data).digest(encoding).replace(/\/|\+|=/g, function(x) {
                return ({
                    "/": "_",
                    "+": "-",
                    "=": ""
                })[x];
            });
        }
        this.sign = function(data) {
            return sign(data, keys[0]);
        };
        this.verify = function(data, digest) {
            return this.index(data, digest) > -1;
        };
        this.index = function(data, digest) {
            for(var i = 0, l = keys.length; i < l; i++){
                if (compare(digest, sign(data, keys[i]))) {
                    return i;
                }
            }
            return -1;
        };
    }
    Keygrip.sign = Keygrip.verify = Keygrip.index = function() {
        throw new Error("Usage: require('keygrip')(<array-of-keys>)");
    };
    module.exports = Keygrip;
}
,
"7a5f0ee9":/*!
 * type-is
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    var typer = farmRequire("c39a2a9f", true);
    var mime = farmRequire("e0cde53a", true);
    module.exports = typeofrequest;
    module.exports.is = typeis;
    module.exports.hasBody = hasbody;
    module.exports.normalize = normalize;
    module.exports.match = mimeMatch;
    function typeis(value, types_) {
        var i;
        var types = types_;
        var val = tryNormalizeType(value);
        if (!val) {
            return false;
        }
        if (types && !Array.isArray(types)) {
            types = new Array(arguments.length - 1);
            for(i = 0; i < types.length; i++){
                types[i] = arguments[i + 1];
            }
        }
        if (!types || !types.length) {
            return val;
        }
        var type;
        for(i = 0; i < types.length; i++){
            if (mimeMatch(normalize(type = types[i]), val)) {
                return type[0] === '+' || type.indexOf('*') !== -1 ? val : type;
            }
        }
        return false;
    }
    function hasbody(req) {
        return req.headers['transfer-encoding'] !== undefined || !isNaN(req.headers['content-length']);
    }
    function typeofrequest(req, types_) {
        var types = types_;
        if (!hasbody(req)) {
            return null;
        }
        if (arguments.length > 2) {
            types = new Array(arguments.length - 1);
            for(var i = 0; i < types.length; i++){
                types[i] = arguments[i + 1];
            }
        }
        var value = req.headers['content-type'];
        return typeis(value, types);
    }
    function normalize(type) {
        if (typeof type !== 'string') {
            return false;
        }
        switch(type){
            case 'urlencoded':
                return 'application/x-www-form-urlencoded';
            case 'multipart':
                return 'multipart/*';
        }
        if (type[0] === '+') {
            return '*/*' + type;
        }
        return type.indexOf('/') === -1 ? mime.lookup(type) : type;
    }
    function mimeMatch(expected, actual) {
        if (expected === false) {
            return false;
        }
        var actualParts = actual.split('/');
        var expectedParts = expected.split('/');
        if (actualParts.length !== 2 || expectedParts.length !== 2) {
            return false;
        }
        if (expectedParts[0] !== '*' && expectedParts[0] !== actualParts[0]) {
            return false;
        }
        if (expectedParts[1].substr(0, 2) === '*+') {
            return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length);
        }
        if (expectedParts[1] !== '*' && expectedParts[1] !== actualParts[1]) {
            return false;
        }
        return true;
    }
    function normalizeType(value) {
        var type = typer.parse(value);
        type.parameters = undefined;
        return typer.format(type);
    }
    function tryNormalizeType(value) {
        if (!value) {
            return null;
        }
        try {
            return normalizeType(value);
        } catch (err) {
            return null;
        }
    }
}
,
"7af0e906":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const path = global.nodeRequire("path", true);
    const fsStat = farmRequire("be5cf725", true);
    const utils = farmRequire("781fd2fa", true);
    class Reader {
        constructor(_settings){
            this._settings = _settings;
            this._fsStatSettings = new fsStat.Settings({
                followSymbolicLink: this._settings.followSymbolicLinks,
                fs: this._settings.fs,
                throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
            });
        }
        _getFullEntryPath(filepath) {
            return path.resolve(this._settings.cwd, filepath);
        }
        _makeEntry(stats, pattern) {
            const entry = {
                name: pattern,
                path: pattern,
                dirent: utils.fs.createDirentFromStats(pattern, stats)
            };
            if (this._settings.stats) {
                entry.stats = stats;
            }
            return entry;
        }
        _isFatalError(error) {
            return !utils.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
        }
    }
    exports.default = Reader;
}
,
"7b6ea513":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    var _f_rustPluginResolver = farmRequire("7d77fe06");
    module._e(exports, _f_rustPluginResolver);
}
,
"7ba829d6":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.legacyOptionsAdapter = void 0;
    const url = global.nodeRequire("url", true);
    const debug_1 = farmRequire("2f90b0a5", true);
    const logger_1 = farmRequire("634664d9", true);
    const debug = debug_1.Debug.extend('legacy-options-adapter');
    const proxyEventMap = {
        onError: 'error',
        onProxyReq: 'proxyReq',
        onProxyRes: 'proxyRes',
        onProxyReqWs: 'proxyReqWs',
        onOpen: 'open',
        onClose: 'close'
    };
    function legacyOptionsAdapter(legacyContext, legacyOptions) {
        let options = {};
        let logger;
        if (typeof legacyContext === 'string' && !!url.parse(legacyContext).host) {
            throw new Error(`Shorthand syntax is removed from legacyCreateProxyMiddleware().
      Please use "legacyCreateProxyMiddleware({ target: 'http://www.example.org' })" instead.

      More details: https://github.com/chimurai/http-proxy-middleware/blob/master/MIGRATION.md#removed-shorthand-usage
      `);
        }
        if (legacyContext && legacyOptions) {
            debug('map legacy context/filter to options.pathFilter');
            options = {
                ...legacyOptions,
                pathFilter: legacyContext
            };
            logger = getLegacyLogger(options);
            logger.warn(`[http-proxy-middleware] Legacy "context" argument is deprecated. Migrate your "context" to "options.pathFilter":

      const options = {
        pathFilter: '${legacyContext}',
      }

      More details: https://github.com/chimurai/http-proxy-middleware/blob/master/MIGRATION.md#removed-context-argument
      `);
        } else if (legacyContext && !legacyOptions) {
            options = {
                ...legacyContext
            };
            logger = getLegacyLogger(options);
        } else {
            logger = getLegacyLogger({});
        }
        Object.entries(proxyEventMap).forEach(([legacyEventName, proxyEventName])=>{
            if (options[legacyEventName]) {
                options.on = {
                    ...options.on
                };
                options.on[proxyEventName] = options[legacyEventName];
                debug('map legacy event "%s" to "on.%s"', legacyEventName, proxyEventName);
                logger.warn(`[http-proxy-middleware] Legacy "${legacyEventName}" is deprecated. Migrate to "options.on.${proxyEventName}":

        const options = {
          on: {
            ${proxyEventName}: () => {},
          },
        }

        More details: https://github.com/chimurai/http-proxy-middleware/blob/master/MIGRATION.md#refactored-proxy-events
        `);
            }
        });
        const logProvider = options.logProvider && options.logProvider();
        const logLevel = options.logLevel;
        debug('legacy logLevel', logLevel);
        debug('legacy logProvider: %O', logProvider);
        if (typeof logLevel === 'string' && logLevel !== 'silent') {
            debug('map "logProvider" to "logger"');
            logger.warn(`[http-proxy-middleware] Legacy "logLevel" and "logProvider" are deprecated. Migrate to "options.logger":

      const options = {
        logger: console,
      }

      More details: https://github.com/chimurai/http-proxy-middleware/blob/master/MIGRATION.md#removed-logprovider-and-loglevel-options
      `);
        }
        return options;
    }
    exports.legacyOptionsAdapter = legacyOptionsAdapter;
    function getLegacyLogger(options) {
        const legacyLogger = options.logProvider && options.logProvider();
        if (legacyLogger) {
            options.logger = legacyLogger;
        }
        return (0, logger_1.getLogger)(options);
    }
}
,
"7bf476fc":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "HmrEngine", ()=>HmrEngine);
    var _f_fs_extra = module.i(farmRequire("77e37188"));
    var _f_promises = farmRequire('node:fs/promises');
    var _f_node_path = farmRequire('node:path');
    var _f_index = farmRequire("491ca098");
    var _f_index1 = farmRequire("65ad6846");
    var _f_error = farmRequire("972397d2");
    class HmrEngine {
        _logger;
        _updateQueue;
        _compiler;
        _devServer;
        _onUpdates;
        _lastModifiedTimestamp;
        constructor(compiler, devServer, _logger){
            this._logger = _logger;
            this._updateQueue = [];
            this.recompileAndSendResult = async ()=>{
                const queue = [
                    ...this._updateQueue
                ];
                if (queue.length === 0) {
                    return;
                }
                let updatedFilesStr = queue.map((item)=>{
                    if (_f_node_path.isAbsolute(item)) {
                        return _f_node_path.relative(this._compiler.config.config.root, item);
                    } else {
                        const resolvedPath = this._compiler.transformModulePath(this._compiler.config.config.root, item);
                        return _f_node_path.relative(this._compiler.config.config.root, resolvedPath);
                    }
                }).join(', ');
                if (updatedFilesStr.length >= 100) {
                    updatedFilesStr = updatedFilesStr.slice(0, 100) + `...(${queue.length} files)`;
                }
                try {
                    this._compiler.onUpdateFinish(async ()=>{
                        if (this._updateQueue.length > 0) {
                            await this.recompileAndSendResult();
                        }
                        if (this._devServer?.config?.writeToDisk) {
                            this._compiler.writeResourcesToDisk();
                        }
                    });
                    _f_index.checkClearScreen(this._compiler.config.config);
                    const start = Date.now();
                    const result = await this._compiler.update(queue);
                    this._logger.info(`${_f_index1.bold(_f_index1.cyan(updatedFilesStr))} updated in ${_f_index1.bold(_f_index1.green(`${Date.now() - start}ms`))}`);
                    this._updateQueue = this._updateQueue.filter((item)=>!queue.includes(item));
                    const { dynamicResources, dynamicModuleResourcesMap } = _f_index1.getDynamicResources(result.dynamicResourcesMap);
                    const { added, changed, removed, immutableModules, mutableModules, boundaries } = result;
                    const resultStr = `{
        added: [${formatHmrResult(added)}],
        changed: [${formatHmrResult(changed)}],
        removed: [${formatHmrResult(removed)}],
        immutableModules: ${JSON.stringify(immutableModules.trim())},
        mutableModules: ${JSON.stringify(mutableModules.trim())},
        boundaries: ${JSON.stringify(boundaries)},
        dynamicResources: ${JSON.stringify(dynamicResources)},
        dynamicModuleResourcesMap: ${JSON.stringify(dynamicModuleResourcesMap)}
      }`;
                    this.callUpdates(result);
                    this._devServer.ws.clients.forEach((client)=>{
                        client.rawSend(`
        {
          type: 'farm-update',
          result: ${resultStr}
        }
      `);
                    });
                } catch (err) {
                    _f_index.checkClearScreen(this._compiler.config.config);
                    throw new Error(_f_error.logError(err));
                }
            };
            this._compiler = compiler;
            this._devServer = devServer;
            this._lastModifiedTimestamp = new Map();
        }
        callUpdates(result) {
            this._onUpdates?.forEach((cb)=>cb(result));
        }
        onUpdateFinish(cb) {
            if (!this._onUpdates) {
                this._onUpdates = [];
            }
            this._onUpdates.push(cb);
        }
        recompileAndSendResult;
        async hmrUpdate(absPath, force = false) {
            const paths = Array.isArray(absPath) ? absPath : [
                absPath
            ];
            for (const path of paths){
                if (this._compiler.hasModule(path) && !this._updateQueue.includes(path)) {
                    if (module.f(_f_fs_extra).existsSync(path)) {
                        const lastModifiedTimestamp = this._lastModifiedTimestamp.get(path);
                        const currentTimestamp = (await _f_promises.stat(path)).mtime.toISOString();
                        if (!force && lastModifiedTimestamp === currentTimestamp) {
                            continue;
                        }
                        this._lastModifiedTimestamp.set(path, currentTimestamp);
                    }
                    this._updateQueue.push(path);
                }
            }
            if (!this._compiler.compiling && this._updateQueue.length > 0) {
                try {
                    await this.recompileAndSendResult();
                } catch (e) {
                    const serialization = e.message.replace(/\x1b\[[0-9;]*m/g, '');
                    const errorStr = `${JSON.stringify({
                        message: serialization
                    })}`;
                    this._devServer.ws.clients.forEach((client)=>{
                        client.rawSend(`
            {
              type: 'error',
              err: ${errorStr},
              overlay: ${this._devServer.config.hmr.overlay}
            }
          `);
                    });
                    this._logger.error(e);
                }
            }
        }
    }
    function formatHmrResult(array) {
        return array.map((item)=>`'${item.replaceAll('\\', '\\\\')}'`).join(', ');
    }
}
,
"7d77fe06":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "rustPluginResolver", ()=>rustPluginResolver);
    var _f_node_module = farmRequire('node:module');
    var _f_node_path = module.i(farmRequire('node:path'));
    var _f_node_url = farmRequire('node:url');
    async function rustPluginResolver(plugin, root) {
        let pluginPath;
        let options = '{}';
        if (typeof plugin === 'string') {
            pluginPath = plugin;
        } else if (Array.isArray(plugin) && plugin.length === 2) {
            [pluginPath, options] = [
                plugin[0],
                JSON.stringify(plugin[1]) ?? '{}'
            ];
        } else {
            throw new Error('Invalid config: [plugins]. A rust plugin must be a string, or [string, Record<string, any>]');
        }
        if (!module.f(_f_node_path).isAbsolute(pluginPath) && !pluginPath.startsWith('.')) {
            const require = _f_node_module.createRequire(module.f(_f_node_path).join(root, 'package.json'));
            pluginPath = require.resolve(pluginPath);
        }
        if (!pluginPath.endsWith('.farm')) {
            if (process.platform === 'win32') {
                pluginPath = (await import(_f_node_url.pathToFileURL(pluginPath).toString())).default;
            } else {
                pluginPath = await import(pluginPath).then((m)=>m.default);
            }
            if (typeof pluginPath === 'function') {
                const [_path, _options] = pluginPath();
                options = JSON.stringify({
                    ..._options,
                    ...JSON.parse(options)
                });
                pluginPath = _path;
            }
            if (typeof pluginPath !== 'string') {
                const { binary, options: pluginOptions } = pluginPath;
                options = JSON.stringify({
                    ...pluginOptions,
                    ...JSON.parse(options)
                });
                pluginPath = binary;
            }
        }
        return [
            pluginPath,
            options
        ];
    }
}
,
"7da8dae6":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    const taskManager = farmRequire("4249400c", true);
    const async_1 = farmRequire("1caed8ab", true);
    const stream_1 = farmRequire("a38475ea", true);
    const sync_1 = farmRequire("8038bbfb", true);
    const settings_1 = farmRequire("5954bc0f", true);
    const utils = farmRequire("781fd2fa", true);
    async function FastGlob(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, async_1.default, options);
        const result = await Promise.all(works);
        return utils.array.flatten(result);
    }
    (function(FastGlob) {
        FastGlob.glob = FastGlob;
        FastGlob.globSync = sync;
        FastGlob.globStream = stream;
        FastGlob.async = FastGlob;
        function sync(source, options) {
            assertPatternsInput(source);
            const works = getWorks(source, sync_1.default, options);
            return utils.array.flatten(works);
        }
        FastGlob.sync = sync;
        function stream(source, options) {
            assertPatternsInput(source);
            const works = getWorks(source, stream_1.default, options);
            return utils.stream.merge(works);
        }
        FastGlob.stream = stream;
        function generateTasks(source, options) {
            assertPatternsInput(source);
            const patterns = [].concat(source);
            const settings = new settings_1.default(options);
            return taskManager.generate(patterns, settings);
        }
        FastGlob.generateTasks = generateTasks;
        function isDynamicPattern(source, options) {
            assertPatternsInput(source);
            const settings = new settings_1.default(options);
            return utils.pattern.isDynamicPattern(source, settings);
        }
        FastGlob.isDynamicPattern = isDynamicPattern;
        function escapePath(source) {
            assertPatternsInput(source);
            return utils.path.escape(source);
        }
        FastGlob.escapePath = escapePath;
        function convertPathToPattern(source) {
            assertPatternsInput(source);
            return utils.path.convertPathToPattern(source);
        }
        FastGlob.convertPathToPattern = convertPathToPattern;
        let posix;
        (function(posix) {
            function escapePath(source) {
                assertPatternsInput(source);
                return utils.path.escapePosixPath(source);
            }
            posix.escapePath = escapePath;
            function convertPathToPattern(source) {
                assertPatternsInput(source);
                return utils.path.convertPosixPathToPattern(source);
            }
            posix.convertPathToPattern = convertPathToPattern;
        })(posix = FastGlob.posix || (FastGlob.posix = {}));
        let win32;
        (function(win32) {
            function escapePath(source) {
                assertPatternsInput(source);
                return utils.path.escapeWindowsPath(source);
            }
            win32.escapePath = escapePath;
            function convertPathToPattern(source) {
                assertPatternsInput(source);
                return utils.path.convertWindowsPathToPattern(source);
            }
            win32.convertPathToPattern = convertPathToPattern;
        })(win32 = FastGlob.win32 || (FastGlob.win32 = {}));
    })(FastGlob || (FastGlob = {}));
    function getWorks(source, _Provider, options) {
        const patterns = [].concat(source);
        const settings = new settings_1.default(options);
        const tasks = taskManager.generate(patterns, settings);
        const provider = new _Provider(settings);
        return tasks.map(provider.read, provider);
    }
    function assertPatternsInput(input) {
        const source = [].concat(input);
        const isValidSource = source.every((item)=>utils.string.isString(item) && !utils.string.isEmpty(item));
        if (!isValidSource) {
            throw new TypeError('Patterns must be a string (non empty) or an array of strings');
        }
    }
    module.exports = FastGlob;
}
,
"8038bbfb":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const sync_1 = farmRequire("f2828d33", true);
    const provider_1 = farmRequire("ba3d9d5e", true);
    class ProviderSync extends provider_1.default {
        constructor(){
            super(...arguments);
            this._reader = new sync_1.default(this._settings);
        }
        read(task) {
            const root = this._getRootDirectory(task);
            const options = this._getReaderOptions(task);
            const entries = this.api(root, task, options);
            return entries.map(options.transform);
        }
        api(root, task, options) {
            if (task.dynamic) {
                return this._reader.dynamic(root, options);
            }
            return this._reader.static(task.patterns, options);
        }
    }
    exports.default = ProviderSync;
}
,
"81da7c90":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.HttpProxyMiddleware = void 0;
    const httpProxy = farmRequire("3a7d7323", true);
    const configuration_1 = farmRequire("0e4db454", true);
    const get_plugins_1 = farmRequire("ce7af38f", true);
    const path_filter_1 = farmRequire("28903419", true);
    const PathRewriter = farmRequire("f0ba01fa", true);
    const Router = farmRequire("83ea8c2a", true);
    const debug_1 = farmRequire("2f90b0a5", true);
    const function_1 = farmRequire("f8468536", true);
    class HttpProxyMiddleware {
        constructor(options){
            this.wsInternalSubscribed = false;
            this.serverOnCloseSubscribed = false;
            this.middleware = async (req, res, next)=>{
                if (this.shouldProxy(this.proxyOptions.pathFilter, req)) {
                    try {
                        const activeProxyOptions = await this.prepareProxyRequest(req);
                        (0, debug_1.Debug)(`proxy request to target: %O`, activeProxyOptions.target);
                        this.proxy.web(req, res, activeProxyOptions);
                    } catch (err) {
                        next && next(err);
                    }
                } else {
                    next && next();
                }
                const server = (req.socket ?? req.connection)?.server;
                if (server && !this.serverOnCloseSubscribed) {
                    server.on('close', ()=>{
                        (0, debug_1.Debug)('server close signal received: closing proxy server');
                        this.proxy.close();
                    });
                    this.serverOnCloseSubscribed = true;
                }
                if (this.proxyOptions.ws === true) {
                    this.catchUpgradeRequest(server);
                }
            };
            this.catchUpgradeRequest = (server)=>{
                if (!this.wsInternalSubscribed) {
                    (0, debug_1.Debug)('subscribing to server upgrade event');
                    server.on('upgrade', this.handleUpgrade);
                    this.wsInternalSubscribed = true;
                }
            };
            this.handleUpgrade = async (req, socket, head)=>{
                if (this.shouldProxy(this.proxyOptions.pathFilter, req)) {
                    const activeProxyOptions = await this.prepareProxyRequest(req);
                    this.proxy.ws(req, socket, head, activeProxyOptions);
                    (0, debug_1.Debug)('server upgrade event received. Proxying WebSocket');
                }
            };
            this.shouldProxy = (pathFilter, req)=>{
                return (0, path_filter_1.matchPathFilter)(pathFilter, req.url, req);
            };
            this.prepareProxyRequest = async (req)=>{
                if (this.middleware.__LEGACY_HTTP_PROXY_MIDDLEWARE__) {
                    req.url = req.originalUrl || req.url;
                }
                const newProxyOptions = Object.assign({}, this.proxyOptions);
                await this.applyRouter(req, newProxyOptions);
                await this.applyPathRewrite(req, this.pathRewriter);
                return newProxyOptions;
            };
            this.applyRouter = async (req, options)=>{
                let newTarget;
                if (options.router) {
                    newTarget = await Router.getTarget(req, options);
                    if (newTarget) {
                        (0, debug_1.Debug)('router new target: "%s"', newTarget);
                        options.target = newTarget;
                    }
                }
            };
            this.applyPathRewrite = async (req, pathRewriter)=>{
                if (pathRewriter) {
                    const path = await pathRewriter(req.url, req);
                    if (typeof path === 'string') {
                        (0, debug_1.Debug)('pathRewrite new path: %s', req.url);
                        req.url = path;
                    } else {
                        (0, debug_1.Debug)('pathRewrite: no rewritten path found: %s', req.url);
                    }
                }
            };
            (0, configuration_1.verifyConfig)(options);
            this.proxyOptions = options;
            (0, debug_1.Debug)(`create proxy server`);
            this.proxy = httpProxy.createProxyServer({});
            this.registerPlugins(this.proxy, this.proxyOptions);
            this.pathRewriter = PathRewriter.createPathRewriter(this.proxyOptions.pathRewrite);
            this.middleware.upgrade = (req, socket, head)=>{
                if (!this.wsInternalSubscribed) {
                    this.handleUpgrade(req, socket, head);
                }
            };
        }
        registerPlugins(proxy, options) {
            const plugins = (0, get_plugins_1.getPlugins)(options);
            plugins.forEach((plugin)=>{
                (0, debug_1.Debug)(`register plugin: "${(0, function_1.getFunctionName)(plugin)}"`);
                plugin(proxy, options);
            });
        }
    }
    exports.HttpProxyMiddleware = HttpProxyMiddleware;
}
,
"8276c222":function  (module, exports, farmRequire, farmDynamicRequire) {
    var supportsArgumentsClass = function() {
        return Object.prototype.toString.call(arguments);
    }() == '[object Arguments]';
    exports = module.exports = supportsArgumentsClass ? supported : unsupported;
    exports.supported = supported;
    function supported(object) {
        return Object.prototype.toString.call(object) == '[object Arguments]';
    }
    ;
    exports.unsupported = unsupported;
    function unsupported(object) {
        return object && typeof object == 'object' && typeof object.length == 'number' && Object.prototype.hasOwnProperty.call(object, 'callee') && !Object.prototype.propertyIsEnumerable.call(object, 'callee') || false;
    }
    ;
}
,
"830b3dc6":function  (module, exports, farmRequire, farmDynamicRequire) {
    const { existsSync, readFileSync } = global.nodeRequire('fs', true);
    const { join } = global.nodeRequire('path', true);
    const { platform, arch } = process;
    let nativeBindingPath = null;
    let localFileExisted = false;
    let loadError = null;
    function isMusl() {
        if (!process.report || typeof process.report.getReport !== 'function') {
            try {
                return readFileSync('/usr/bin/ldd', 'utf8').includes('musl');
            } catch (e) {
                return true;
            }
        } else {
            const { glibcVersionRuntime } = process.report.getReport().header;
            return !glibcVersionRuntime;
        }
    }
    switch(platform){
        case 'android':
            switch(arch){
                case 'arm64':
                    localFileExisted = existsSync(join(__dirname, 'farm.android-arm64.node'));
                    try {
                        if (localFileExisted) {
                            nativeBindingPath = require.resolve('./farm.android-arm64.node');
                        } else {
                            nativeBindingPath = require.resolve('@farmfe/core-android-arm64');
                        }
                    } catch (e) {
                        loadError = e;
                    }
                    break;
                case 'arm':
                    localFileExisted = existsSync(join(__dirname, 'farm.android-arm-eabi.node'));
                    try {
                        if (localFileExisted) {
                            nativeBindingPath = require.resolve('./farm.android-arm-eabi.node');
                        } else {
                            nativeBindingPath = require.resolve('@farmfe/core-android-arm-eabi');
                        }
                    } catch (e) {
                        loadError = e;
                    }
                    break;
                default:
                    throw new Error(`Unsupported architecture on Android ${arch}`);
            }
            break;
        case 'win32':
            switch(arch){
                case 'x64':
                    localFileExisted = existsSync(join(__dirname, 'farm.win32-x64-msvc.node'));
                    try {
                        if (localFileExisted) {
                            nativeBindingPath = require.resolve('./farm.win32-x64-msvc.node');
                        } else {
                            nativeBindingPath = require.resolve('@farmfe/core-win32-x64-msvc');
                        }
                    } catch (e) {
                        loadError = e;
                    }
                    break;
                case 'ia32':
                    localFileExisted = existsSync(join(__dirname, 'farm.win32-ia32-msvc.node'));
                    try {
                        if (localFileExisted) {
                            nativeBindingPath = require.resolve('./farm.win32-ia32-msvc.node');
                        } else {
                            nativeBindingPath = require.resolve('@farmfe/core-win32-ia32-msvc');
                        }
                    } catch (e) {
                        loadError = e;
                    }
                    break;
                case 'arm64':
                    localFileExisted = existsSync(join(__dirname, 'farm.win32-arm64-msvc.node'));
                    try {
                        if (localFileExisted) {
                            nativeBindingPath = require.resolve('./farm.win32-arm64-msvc.node');
                        } else {
                            nativeBindingPath = require.resolve('@farmfe/core-win32-arm64-msvc');
                        }
                    } catch (e) {
                        loadError = e;
                    }
                    break;
                default:
                    throw new Error(`Unsupported architecture on Windows: ${arch}`);
            }
            break;
        case 'darwin':
            switch(arch){
                case 'x64':
                    localFileExisted = existsSync(join(__dirname, 'farm.darwin-x64.node'));
                    try {
                        if (localFileExisted) {
                            nativeBindingPath = require.resolve('./farm.darwin-x64.node');
                        } else {
                            nativeBindingPath = require.resolve('@farmfe/core-darwin-x64');
                        }
                    } catch (e) {
                        loadError = e;
                    }
                    break;
                case 'arm64':
                    localFileExisted = existsSync(join(__dirname, 'farm.darwin-arm64.node'));
                    try {
                        if (localFileExisted) {
                            nativeBindingPath = require.resolve('./farm.darwin-arm64.node');
                        } else {
                            nativeBindingPath = require.resolve('@farmfe/core-darwin-arm64');
                        }
                    } catch (e) {
                        loadError = e;
                    }
                    break;
                default:
                    throw new Error(`Unsupported architecture on macOS: ${arch}`);
            }
            break;
        case 'freebsd':
            if (arch !== 'x64') {
                throw new Error(`Unsupported architecture on FreeBSD: ${arch}`);
            }
            localFileExisted = existsSync(join(__dirname, 'farm.freebsd-x64.node'));
            try {
                if (localFileExisted) {
                    nativeBindingPath = require.resolve('./farm.freebsd-x64.node');
                } else {
                    nativeBindingPath = require.resolve('@farmfe/core-freebsd-x64');
                }
            } catch (e) {
                loadError = e;
            }
            break;
        case 'linux':
            switch(arch){
                case 'x64':
                    if (isMusl()) {
                        localFileExisted = existsSync(join(__dirname, 'farm.linux-x64-musl.node'));
                        try {
                            if (localFileExisted) {
                                nativeBindingPath = require.resolve('./farm.linux-x64-musl.node');
                            } else {
                                nativeBindingPath = require.resolve('@farmfe/core-linux-x64-musl');
                            }
                        } catch (e) {
                            loadError = e;
                        }
                    } else {
                        localFileExisted = existsSync(join(__dirname, 'farm.linux-x64-gnu.node'));
                        try {
                            if (localFileExisted) {
                                nativeBindingPath = require.resolve('./farm.linux-x64-gnu.node');
                            } else {
                                nativeBindingPath = require.resolve('@farmfe/core-linux-x64-gnu');
                            }
                        } catch (e) {
                            loadError = e;
                        }
                    }
                    break;
                case 'arm64':
                    if (isMusl()) {
                        localFileExisted = existsSync(join(__dirname, 'farm.linux-arm64-musl.node'));
                        try {
                            if (localFileExisted) {
                                nativeBindingPath = require.resolve('./farm.linux-arm64-musl.node');
                            } else {
                                nativeBindingPath = require.resolve('@farmfe/core-linux-arm64-musl');
                            }
                        } catch (e) {
                            loadError = e;
                        }
                    } else {
                        localFileExisted = existsSync(join(__dirname, 'farm.linux-arm64-gnu.node'));
                        try {
                            if (localFileExisted) {
                                nativeBindingPath = require.resolve('./farm.linux-arm64-gnu.node');
                            } else {
                                nativeBindingPath = require.resolve('@farmfe/core-linux-arm64-gnu');
                            }
                        } catch (e) {
                            loadError = e;
                        }
                    }
                    break;
                case 'arm':
                    localFileExisted = existsSync(join(__dirname, 'farm.linux-arm-gnueabihf.node'));
                    try {
                        if (localFileExisted) {
                            nativeBindingPath = require.resolve('./farm.linux-arm-gnueabihf.node');
                        } else {
                            nativeBindingPath = require.resolve('@farmfe/core-linux-arm-gnueabihf');
                        }
                    } catch (e) {
                        loadError = e;
                    }
                    break;
                default:
                    throw new Error(`Unsupported architecture on Linux: ${arch}`);
            }
            break;
        default:
            throw new Error(`Unsupported OS: ${platform}, architecture: ${arch}`);
    }
    if (loadError) {
        throw loadError;
    }
    module.exports = nativeBindingPath;
}
,
"83936b24":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const { Duplex } = global.nodeRequire('stream', true);
    function emitClose(stream) {
        stream.emit('close');
    }
    function duplexOnEnd() {
        if (!this.destroyed && this._writableState.finished) {
            this.destroy();
        }
    }
    function duplexOnError(err) {
        this.removeListener('error', duplexOnError);
        this.destroy();
        if (this.listenerCount('error') === 0) {
            this.emit('error', err);
        }
    }
    function createWebSocketStream(ws, options) {
        let terminateOnDestroy = true;
        const duplex = new Duplex({
            ...options,
            autoDestroy: false,
            emitClose: false,
            objectMode: false,
            writableObjectMode: false
        });
        ws.on('message', function message(msg, isBinary) {
            const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
            if (!duplex.push(data)) ws.pause();
        });
        ws.once('error', function error(err) {
            if (duplex.destroyed) return;
            terminateOnDestroy = false;
            duplex.destroy(err);
        });
        ws.once('close', function close() {
            if (duplex.destroyed) return;
            duplex.push(null);
        });
        duplex._destroy = function(err, callback) {
            if (ws.readyState === ws.CLOSED) {
                callback(err);
                process.nextTick(emitClose, duplex);
                return;
            }
            let called = false;
            ws.once('error', function error(err) {
                called = true;
                callback(err);
            });
            ws.once('close', function close() {
                if (!called) callback(err);
                process.nextTick(emitClose, duplex);
            });
            if (terminateOnDestroy) ws.terminate();
        };
        duplex._final = function(callback) {
            if (ws.readyState === ws.CONNECTING) {
                ws.once('open', function open() {
                    duplex._final(callback);
                });
                return;
            }
            if (ws._socket === null) return;
            if (ws._socket._writableState.finished) {
                callback();
                if (duplex._readableState.endEmitted) duplex.destroy();
            } else {
                ws._socket.once('finish', function finish() {
                    callback();
                });
                ws.close();
            }
        };
        duplex._read = function() {
            if (ws.isPaused) ws.resume();
        };
        duplex._write = function(chunk, encoding, callback) {
            if (ws.readyState === ws.CONNECTING) {
                ws.once('open', function open() {
                    duplex._write(chunk, encoding, callback);
                });
                return;
            }
            ws.send(chunk, callback);
        };
        duplex.on('end', duplexOnEnd);
        duplex.on('error', duplexOnError);
        return duplex;
    }
    module.exports = createWebSocketStream;
}
,
"83b19369":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "loadEnv", ()=>loadEnv);
    module.o(exports, "getExistsEnvFiles", ()=>getExistsEnvFiles);
    module.o(exports, "setProcessEnv", ()=>setProcessEnv);
    module.o(exports, "isDisableCache", ()=>isDisableCache);
    module.o(exports, "getEnvFilesForMode", ()=>getEnvFilesForMode);
    var _f_node_fs = module.i(farmRequire('node:fs'));
    var _f_node_path = module.i(farmRequire('node:path'));
    var _f_dotenv = farmRequire("3263d6bf");
    var _f_dotenv_expand = farmRequire("a785a22a");
    var _f_index = farmRequire("65ad6846");
    function loadEnv(mode, envDir, prefixes = [
        'FARM_',
        'VITE_'
    ]) {
        if (mode === 'local') {
            throw new Error(`"local" cannot be used as a mode name because it conflicts with ` + `the .local postfix for .env files.`);
        }
        prefixes = _f_index.arraify(prefixes);
        const env = {};
        const envFiles = getEnvFilesForMode(mode, envDir);
        const parsed = Object.fromEntries(envFiles.flatMap((filePath)=>{
            if (!_f_index.tryStatSync(filePath)?.isFile()) return [];
            return Object.entries(_f_dotenv.parse(module.f(_f_node_fs).readFileSync(filePath)));
        }));
        const processEnv = {
            ...process.env
        };
        _f_dotenv_expand.expand({
            parsed,
            processEnv
        });
        for (const [key, value] of Object.entries(parsed)){
            if (prefixes.some((prefix)=>key.startsWith(prefix))) {
                env[key] = value;
            }
        }
        for(const key in process.env){
            if (prefixes.some((prefix)=>key.startsWith(prefix)) && key !== 'FARM_LIB_CORE_PATH') {
                env[key] = process.env[key];
            }
        }
        return env;
    }
    function getExistsEnvFiles(mode, envDir) {
        const envFiles = getEnvFilesForMode(mode, envDir);
        return envFiles.filter((filePath)=>_f_index.tryStatSync(filePath)?.isFile());
    }
    function setProcessEnv(mode) {
        process.env.NODE_ENV = mode;
    }
    var isDisableCache = ()=>!!process.env.DISABLE_CACHE;
    function getEnvFilesForMode(mode, envDir) {
        return [
            `.env`,
            `.env.local`,
            `.env.${mode}`,
            `.env.${mode}.local`
        ].map((file)=>_f_index.normalizePath(module.f(_f_node_path).join(envDir, file)));
    }
}
,
"83ea8c2a":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.getTarget = void 0;
    const isPlainObj = farmRequire("17cd914f", true);
    const debug_1 = farmRequire("2f90b0a5", true);
    const debug = debug_1.Debug.extend('router');
    async function getTarget(req, config) {
        let newTarget;
        const router = config.router;
        if (isPlainObj(router)) {
            newTarget = getTargetFromProxyTable(req, router);
        } else if (typeof router === 'function') {
            newTarget = await router(req);
        }
        return newTarget;
    }
    exports.getTarget = getTarget;
    function getTargetFromProxyTable(req, table) {
        let result;
        const host = req.headers.host;
        const path = req.url;
        const hostAndPath = host + path;
        for (const [key, value] of Object.entries(table)){
            if (containsPath(key)) {
                if (hostAndPath.indexOf(key) > -1) {
                    result = value;
                    debug('match: "%s" -> "%s"', key, result);
                    break;
                }
            } else {
                if (key === host) {
                    result = value;
                    debug('match: "%s" -> "%s"', host, result);
                    break;
                }
            }
        }
        return result;
    }
    function containsPath(v) {
        return v.indexOf('/') > -1;
    }
}
,
"84a68c6c":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "urlRegex", ()=>urlRegex);
    module.o(exports, "loopbackHosts", ()=>loopbackHosts);
    module.o(exports, "wildcardHosts", ()=>wildcardHosts);
    module.o(exports, "resolveServerUrls", ()=>resolveServerUrls);
    module.o(exports, "resolveHostname", ()=>resolveHostname);
    var _f_node_os = module.i(farmRequire('node:os'));
    var urlRegex = /^(https?:)?\/\/([^/]+)/;
    var loopbackHosts = new Set([
        'localhost',
        '127.0.0.1',
        '::1',
        '0000:0000:0000:0000:0000:0000:0000:0001'
    ]);
    var wildcardHosts = new Set([
        '0.0.0.0',
        '::',
        '0000:0000:0000:0000:0000:0000:0000:0000'
    ]);
    function resolveServerUrls(server, options, publicPath) {
        const address = server.address();
        const isAddressInfo = (x)=>x?.address;
        if (!isAddressInfo(address)) {
            return {
                local: [],
                network: []
            };
        }
        const local = [];
        const network = [];
        const hostname = resolveHostname(options.host);
        const protocol = options.https ? 'https' : 'http';
        const { port } = getAddressHostnamePort(address);
        const base = publicPath || '';
        if (hostname.host !== undefined && !wildcardHosts.has(hostname.host)) {
            const url = createServerUrl(protocol, hostname.name, port, base);
            if (loopbackHosts.has(hostname.host)) {
                local.push(url);
            } else {
                network.push(url);
            }
        } else {
            const networkInterfaces = Object.values(module.f(_f_node_os).networkInterfaces()).flatMap((nInterface)=>nInterface || []);
            networkInterfaces.filter((detail)=>detail && detail.address && (detail.family === 'IPv4' || detail.family === 4)).forEach((detail)=>{
                let host = detail.address.replace('127.0.0.1', hostname.name);
                host = host.includes(':') ? `[${host}]` : host;
                const url = createServerUrl(protocol, host, port, base);
                detail.address.includes('127.0.0.1') ? local.push(url) : network.push(url);
            });
        }
        return {
            local,
            network
        };
    }
    function resolveHostname(optionsHost) {
        let host;
        if (optionsHost === undefined || optionsHost === false) {
            host = 'localhost';
        } else if (optionsHost === true) {
            host = undefined;
        } else {
            host = optionsHost;
        }
        const name = host === undefined || wildcardHosts.has(host) ? 'localhost' : host;
        return {
            host,
            name
        };
    }
    function getAddressHostnamePort(server) {
        const hostname = server.address || 'localhost';
        const port = server.port;
        return {
            host: hostname,
            port
        };
    }
    function createServerUrl(protocol, hostname, port, publicPath) {
        const hostnameName = hostname.includes(':') ? `[${hostname}]` : hostname;
        return `${protocol}://${hostnameName}:${port}${publicPath}`;
    }
}
,
"860853df":/*!
 * toidentifier
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    module.exports = toIdentifier;
    function toIdentifier(str) {
        return str.split(' ').map(function(token) {
            return token.slice(0, 1).toUpperCase() + token.slice(1);
        }).join('').replace(/[^ _0-9a-z]/gi, '');
    }
}
,
"86b15c4b":function  (module, exports, farmRequire, farmDynamicRequire) {
    const tty = global.nodeRequire('tty', true);
    const util = global.nodeRequire('util', true);
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util.deprecate(()=>{}, 'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    exports.colors = [
        6,
        2,
        3,
        4,
        5,
        1
    ];
    try {
        const supportsColor = farmRequire("6d9407b3", true);
        if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
            exports.colors = [
                20,
                21,
                26,
                27,
                32,
                33,
                38,
                39,
                40,
                41,
                42,
                43,
                44,
                45,
                56,
                57,
                62,
                63,
                68,
                69,
                74,
                75,
                76,
                77,
                78,
                79,
                80,
                81,
                92,
                93,
                98,
                99,
                112,
                113,
                128,
                129,
                134,
                135,
                148,
                149,
                160,
                161,
                162,
                163,
                164,
                165,
                166,
                167,
                168,
                169,
                170,
                171,
                172,
                173,
                178,
                179,
                184,
                185,
                196,
                197,
                198,
                199,
                200,
                201,
                202,
                203,
                204,
                205,
                206,
                207,
                208,
                209,
                214,
                215,
                220,
                221
            ];
        }
    } catch (error) {}
    exports.inspectOpts = Object.keys(process.env).filter((key)=>{
        return /^debug_/i.test(key);
    }).reduce((obj, key)=>{
        const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k)=>{
            return k.toUpperCase();
        });
        let val = process.env[key];
        if (/^(yes|on|true|enabled)$/i.test(val)) {
            val = true;
        } else if (/^(no|off|false|disabled)$/i.test(val)) {
            val = false;
        } else if (val === 'null') {
            val = null;
        } else {
            val = Number(val);
        }
        obj[prop] = val;
        return obj;
    }, {});
    function useColors() {
        return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
        const { namespace: name, useColors } = this;
        if (useColors) {
            const c = this.color;
            const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
            const prefix = `  ${colorCode};1m${name} \u001B[0m`;
            args[0] = prefix + args[0].split('\n').join('\n' + prefix);
            args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
        } else {
            args[0] = getDate() + name + ' ' + args[0];
        }
    }
    function getDate() {
        if (exports.inspectOpts.hideDate) {
            return '';
        }
        return new Date().toISOString() + ' ';
    }
    function log(...args) {
        return process.stderr.write(util.format(...args) + '\n');
    }
    function save(namespaces) {
        if (namespaces) {
            process.env.DEBUG = namespaces;
        } else {
            delete process.env.DEBUG;
        }
    }
    function load() {
        return process.env.DEBUG;
    }
    function init(debug) {
        debug.inspectOpts = {};
        const keys = Object.keys(exports.inspectOpts);
        for(let i = 0; i < keys.length; i++){
            debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
        }
    }
    module.exports = farmRequire("2b9488fe")(exports);
    const { formatters } = module.exports;
    formatters.o = function(v) {
        this.inspectOpts.colors = this.useColors;
        return util.inspect(v, this.inspectOpts).split('\n').map((str)=>str.trim()).join(' ');
    };
    formatters.O = function(v) {
        this.inspectOpts.colors = this.useColors;
        return util.inspect(v, this.inspectOpts);
    };
}
,
"871cfe23":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "externalAdapter", ()=>externalAdapter);
    var _f_constants = farmRequire("97f6a66c");
    var _f_normalize_external = farmRequire("1a581683");
    var _f_share = farmRequire("bc6cc539");
    function externalAdapter() {
        return {
            name: 'farm:external-adapter',
            priority: -Infinity,
            config (config) {
                if (config?.compilation?.external && _f_share.isArray(config.compilation.external)) {
                    let [stringExternal, recordExternal] = _f_normalize_external.mergeCustomExternal(config?.compilation, _f_normalize_external.partialExternal(config.compilation.external));
                    return {
                        compilation: {
                            external: stringExternal,
                            custom: {
                                [_f_constants.CUSTOM_KEYS.external_record]: JSON.stringify(recordExternal)
                            }
                        }
                    };
                }
            }
        };
    }
}
,
"8871c848":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const cp = global.nodeRequire('child_process', true);
    const parse = farmRequire("ec975e7c", true);
    const enoent = farmRequire("e0e571dc", true);
    function spawn(command, args, options) {
        const parsed = parse(command, args, options);
        const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
        enoent.hookChildProcess(spawned, parsed);
        return spawned;
    }
    function spawnSync(command, args, options) {
        const parsed = parse(command, args, options);
        const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
        result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
        return result;
    }
    module.exports = spawn;
    module.exports.spawn = spawn;
    module.exports.sync = spawnSync;
    module.exports._parse = parse;
    module.exports._enoent = enoent;
}
,
"893ee78a":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "compilerHandler", ()=>compilerHandler);
    var _f_node_perf_hooks = farmRequire('node:perf_hooks');
    var _f_index = farmRequire("953dfae2");
    var _f_error = farmRequire("972397d2");
    var _f_color = farmRequire("f19542e0");
    async function compilerHandler(callback, config, logger, options) {
        const IS_TARGET_NODE = _f_index.FARM_TARGET_NODE_ENVS.includes(config.compilation.output.targetEnv);
        IS_TARGET_NODE && options?.clear && _f_index.clearScreen();
        const { persistentCache, output } = config.compilation;
        const startTime = _f_node_perf_hooks.performance.now();
        try {
            await callback();
        } catch (error) {
            logger.error(`Compiler ${_f_error.logError(error, false)}`);
            return;
        }
        const elapsedTime = Math.floor(_f_node_perf_hooks.performance.now() - startTime);
        const persistentCacheText = persistentCache ? _f_color.bold(_f_color.PersistentCacheBrand) : '';
        logger.info(`Build completed in ${_f_color.bold(_f_color.green(`${elapsedTime}ms`))} ${persistentCacheText} Resources emitted to ${_f_color.bold(_f_color.green(output.path))}.`);
    }
}
,
"8984add7":function  (module, exports, farmRequire, farmDynamicRequire) {
    var url = global.nodeRequire("url", true);
    var URL = url.URL;
    var http = global.nodeRequire("http", true);
    var https = global.nodeRequire("https", true);
    var Writable = global.nodeRequire("stream", true).Writable;
    var assert = global.nodeRequire("assert", true);
    var debug = farmRequire("ac30203e", true);
    var useNativeURL = false;
    try {
        assert(new URL());
    } catch (error) {
        useNativeURL = error.code === "ERR_INVALID_URL";
    }
    var preservedUrlFields = [
        "auth",
        "host",
        "hostname",
        "href",
        "path",
        "pathname",
        "port",
        "protocol",
        "query",
        "search",
        "hash"
    ];
    var events = [
        "abort",
        "aborted",
        "connect",
        "error",
        "socket",
        "timeout"
    ];
    var eventHandlers = Object.create(null);
    events.forEach(function(event) {
        eventHandlers[event] = function(arg1, arg2, arg3) {
            this._redirectable.emit(event, arg1, arg2, arg3);
        };
    });
    var InvalidUrlError = createErrorType("ERR_INVALID_URL", "Invalid URL", TypeError);
    var RedirectionError = createErrorType("ERR_FR_REDIRECTION_FAILURE", "Redirected request failed");
    var TooManyRedirectsError = createErrorType("ERR_FR_TOO_MANY_REDIRECTS", "Maximum number of redirects exceeded", RedirectionError);
    var MaxBodyLengthExceededError = createErrorType("ERR_FR_MAX_BODY_LENGTH_EXCEEDED", "Request body larger than maxBodyLength limit");
    var WriteAfterEndError = createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    var destroy = Writable.prototype.destroy || noop;
    function RedirectableRequest(options, responseCallback) {
        Writable.call(this);
        this._sanitizeOptions(options);
        this._options = options;
        this._ended = false;
        this._ending = false;
        this._redirectCount = 0;
        this._redirects = [];
        this._requestBodyLength = 0;
        this._requestBodyBuffers = [];
        if (responseCallback) {
            this.on("response", responseCallback);
        }
        var self = this;
        this._onNativeResponse = function(response) {
            try {
                self._processResponse(response);
            } catch (cause) {
                self.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({
                    cause: cause
                }));
            }
        };
        this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
        destroyRequest(this._currentRequest);
        this._currentRequest.abort();
        this.emit("abort");
    };
    RedirectableRequest.prototype.destroy = function(error) {
        destroyRequest(this._currentRequest, error);
        destroy.call(this, error);
        return this;
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback) {
        if (this._ending) {
            throw new WriteAfterEndError();
        }
        if (!isString(data) && !isBuffer(data)) {
            throw new TypeError("data should be a string, Buffer or Uint8Array");
        }
        if (isFunction(encoding)) {
            callback = encoding;
            encoding = null;
        }
        if (data.length === 0) {
            if (callback) {
                callback();
            }
            return;
        }
        if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
            this._requestBodyLength += data.length;
            this._requestBodyBuffers.push({
                data: data,
                encoding: encoding
            });
            this._currentRequest.write(data, encoding, callback);
        } else {
            this.emit("error", new MaxBodyLengthExceededError());
            this.abort();
        }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback) {
        if (isFunction(data)) {
            callback = data;
            data = encoding = null;
        } else if (isFunction(encoding)) {
            callback = encoding;
            encoding = null;
        }
        if (!data) {
            this._ended = this._ending = true;
            this._currentRequest.end(null, null, callback);
        } else {
            var self = this;
            var currentRequest = this._currentRequest;
            this.write(data, encoding, function() {
                self._ended = true;
                currentRequest.end(null, null, callback);
            });
            this._ending = true;
        }
    };
    RedirectableRequest.prototype.setHeader = function(name, value) {
        this._options.headers[name] = value;
        this._currentRequest.setHeader(name, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name) {
        delete this._options.headers[name];
        this._currentRequest.removeHeader(name);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
        var self = this;
        function destroyOnTimeout(socket) {
            socket.setTimeout(msecs);
            socket.removeListener("timeout", socket.destroy);
            socket.addListener("timeout", socket.destroy);
        }
        function startTimer(socket) {
            if (self._timeout) {
                clearTimeout(self._timeout);
            }
            self._timeout = setTimeout(function() {
                self.emit("timeout");
                clearTimer();
            }, msecs);
            destroyOnTimeout(socket);
        }
        function clearTimer() {
            if (self._timeout) {
                clearTimeout(self._timeout);
                self._timeout = null;
            }
            self.removeListener("abort", clearTimer);
            self.removeListener("error", clearTimer);
            self.removeListener("response", clearTimer);
            self.removeListener("close", clearTimer);
            if (callback) {
                self.removeListener("timeout", callback);
            }
            if (!self.socket) {
                self._currentRequest.removeListener("socket", startTimer);
            }
        }
        if (callback) {
            this.on("timeout", callback);
        }
        if (this.socket) {
            startTimer(this.socket);
        } else {
            this._currentRequest.once("socket", startTimer);
        }
        this.on("socket", destroyOnTimeout);
        this.on("abort", clearTimer);
        this.on("error", clearTimer);
        this.on("response", clearTimer);
        this.on("close", clearTimer);
        return this;
    };
    [
        "flushHeaders",
        "getHeader",
        "setNoDelay",
        "setSocketKeepAlive"
    ].forEach(function(method) {
        RedirectableRequest.prototype[method] = function(a, b) {
            return this._currentRequest[method](a, b);
        };
    });
    [
        "aborted",
        "connection",
        "socket"
    ].forEach(function(property) {
        Object.defineProperty(RedirectableRequest.prototype, property, {
            get: function() {
                return this._currentRequest[property];
            }
        });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options) {
        if (!options.headers) {
            options.headers = {};
        }
        if (options.host) {
            if (!options.hostname) {
                options.hostname = options.host;
            }
            delete options.host;
        }
        if (!options.pathname && options.path) {
            var searchPos = options.path.indexOf("?");
            if (searchPos < 0) {
                options.pathname = options.path;
            } else {
                options.pathname = options.path.substring(0, searchPos);
                options.search = options.path.substring(searchPos);
            }
        }
    };
    RedirectableRequest.prototype._performRequest = function() {
        var protocol = this._options.protocol;
        var nativeProtocol = this._options.nativeProtocols[protocol];
        if (!nativeProtocol) {
            throw new TypeError("Unsupported protocol " + protocol);
        }
        if (this._options.agents) {
            var scheme = protocol.slice(0, -1);
            this._options.agent = this._options.agents[scheme];
        }
        var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
        request._redirectable = this;
        for (var event of events){
            request.on(event, eventHandlers[event]);
        }
        this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : this._options.path;
        if (this._isRedirect) {
            var i = 0;
            var self = this;
            var buffers = this._requestBodyBuffers;
            (function writeNext(error) {
                if (request === self._currentRequest) {
                    if (error) {
                        self.emit("error", error);
                    } else if (i < buffers.length) {
                        var buffer = buffers[i++];
                        if (!request.finished) {
                            request.write(buffer.data, buffer.encoding, writeNext);
                        }
                    } else if (self._ended) {
                        request.end();
                    }
                }
            })();
        }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
        var statusCode = response.statusCode;
        if (this._options.trackRedirects) {
            this._redirects.push({
                url: this._currentUrl,
                headers: response.headers,
                statusCode: statusCode
            });
        }
        var location = response.headers.location;
        if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
            response.responseUrl = this._currentUrl;
            response.redirects = this._redirects;
            this.emit("response", response);
            this._requestBodyBuffers = [];
            return;
        }
        destroyRequest(this._currentRequest);
        response.destroy();
        if (++this._redirectCount > this._options.maxRedirects) {
            throw new TooManyRedirectsError();
        }
        var requestHeaders;
        var beforeRedirect = this._options.beforeRedirect;
        if (beforeRedirect) {
            requestHeaders = Object.assign({
                Host: response.req.getHeader("host")
            }, this._options.headers);
        }
        var method = this._options.method;
        if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
            this._options.method = "GET";
            this._requestBodyBuffers = [];
            removeMatchingHeaders(/^content-/i, this._options.headers);
        }
        var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
        var currentUrlParts = parseUrl(this._currentUrl);
        var currentHost = currentHostHeader || currentUrlParts.host;
        var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, {
            host: currentHost
        }));
        var redirectUrl = resolveUrl(location, currentUrl);
        debug("redirecting to", redirectUrl.href);
        this._isRedirect = true;
        spreadUrlObject(redirectUrl, this._options);
        if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
            removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
        }
        if (isFunction(beforeRedirect)) {
            var responseDetails = {
                headers: response.headers,
                statusCode: statusCode
            };
            var requestDetails = {
                url: currentUrl,
                method: method,
                headers: requestHeaders
            };
            beforeRedirect(this._options, responseDetails, requestDetails);
            this._sanitizeOptions(this._options);
        }
        this._performRequest();
    };
    function wrap(protocols) {
        var exports = {
            maxRedirects: 21,
            maxBodyLength: 10 * 1024 * 1024
        };
        var nativeProtocols = {};
        Object.keys(protocols).forEach(function(scheme) {
            var protocol = scheme + ":";
            var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
            var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);
            function request(input, options, callback) {
                if (isURL(input)) {
                    input = spreadUrlObject(input);
                } else if (isString(input)) {
                    input = spreadUrlObject(parseUrl(input));
                } else {
                    callback = options;
                    options = validateUrl(input);
                    input = {
                        protocol: protocol
                    };
                }
                if (isFunction(options)) {
                    callback = options;
                    options = null;
                }
                options = Object.assign({
                    maxRedirects: exports.maxRedirects,
                    maxBodyLength: exports.maxBodyLength
                }, input, options);
                options.nativeProtocols = nativeProtocols;
                if (!isString(options.host) && !isString(options.hostname)) {
                    options.hostname = "::1";
                }
                assert.equal(options.protocol, protocol, "protocol mismatch");
                debug("options", options);
                return new RedirectableRequest(options, callback);
            }
            function get(input, options, callback) {
                var wrappedRequest = wrappedProtocol.request(input, options, callback);
                wrappedRequest.end();
                return wrappedRequest;
            }
            Object.defineProperties(wrappedProtocol, {
                request: {
                    value: request,
                    configurable: true,
                    enumerable: true,
                    writable: true
                },
                get: {
                    value: get,
                    configurable: true,
                    enumerable: true,
                    writable: true
                }
            });
        });
        return exports;
    }
    function noop() {}
    function parseUrl(input) {
        var parsed;
        if (useNativeURL) {
            parsed = new URL(input);
        } else {
            parsed = validateUrl(url.parse(input));
            if (!isString(parsed.protocol)) {
                throw new InvalidUrlError({
                    input
                });
            }
        }
        return parsed;
    }
    function resolveUrl(relative, base) {
        return useNativeURL ? new URL(relative, base) : parseUrl(url.resolve(base, relative));
    }
    function validateUrl(input) {
        if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
            throw new InvalidUrlError({
                input: input.href || input
            });
        }
        if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
            throw new InvalidUrlError({
                input: input.href || input
            });
        }
        return input;
    }
    function spreadUrlObject(urlObject, target) {
        var spread = target || {};
        for (var key of preservedUrlFields){
            spread[key] = urlObject[key];
        }
        if (spread.hostname.startsWith("[")) {
            spread.hostname = spread.hostname.slice(1, -1);
        }
        if (spread.port !== "") {
            spread.port = Number(spread.port);
        }
        spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;
        return spread;
    }
    function removeMatchingHeaders(regex, headers) {
        var lastValue;
        for(var header in headers){
            if (regex.test(header)) {
                lastValue = headers[header];
                delete headers[header];
            }
        }
        return lastValue === null || typeof lastValue === "undefined" ? undefined : String(lastValue).trim();
    }
    function createErrorType(code, message, baseClass) {
        function CustomError(properties) {
            Error.captureStackTrace(this, this.constructor);
            Object.assign(this, properties || {});
            this.code = code;
            this.message = this.cause ? message + ": " + this.cause.message : message;
        }
        CustomError.prototype = new (baseClass || Error)();
        Object.defineProperties(CustomError.prototype, {
            constructor: {
                value: CustomError,
                enumerable: false
            },
            name: {
                value: "Error [" + code + "]",
                enumerable: false
            }
        });
        return CustomError;
    }
    function destroyRequest(request, error) {
        for (var event of events){
            request.removeListener(event, eventHandlers[event]);
        }
        request.on("error", noop);
        request.destroy(error);
    }
    function isSubdomain(subdomain, domain) {
        assert(isString(subdomain) && isString(domain));
        var dot = subdomain.length - domain.length - 1;
        return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
    }
    function isString(value) {
        return typeof value === "string" || value instanceof String;
    }
    function isFunction(value) {
        return typeof value === "function";
    }
    function isBuffer(value) {
        return typeof value === "object" && "length" in value;
    }
    function isURL(value) {
        return URL && value instanceof URL;
    }
    module.exports = wrap({
        http: http,
        https: https
    });
    module.exports.wrap = wrap;
}
,
"89dda374":/*!
 * depd
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    module.exports = eventListenerCount;
    function eventListenerCount(emitter, type) {
        return emitter.listeners(type).length;
    }
}
,
"8aa22968":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "signalsByName", ()=>signalsByName);
    module.o(exports, "signalsByNumber", ()=>signalsByNumber);
    var _f_node_os = farmRequire("node:os");
    var _f_realtime = farmRequire("abc9f14f");
    var _f_signals = farmRequire("6c899748");
    const getSignalsByName = ()=>{
        const signals = _f_signals.getSignals();
        return Object.fromEntries(signals.map(getSignalByName));
    };
    const getSignalByName = ({ name, number, description, supported, action, forced, standard })=>[
            name,
            {
                name,
                number,
                description,
                supported,
                action,
                forced,
                standard
            }
        ];
    var signalsByName = getSignalsByName();
    const getSignalsByNumber = ()=>{
        const signals = _f_signals.getSignals();
        const length = _f_realtime.SIGRTMAX + 1;
        const signalsA = Array.from({
            length
        }, (value, number)=>getSignalByNumber(number, signals));
        return Object.assign({}, ...signalsA);
    };
    const getSignalByNumber = (number, signals)=>{
        const signal = findSignalByNumber(number, signals);
        if (signal === undefined) {
            return {};
        }
        const { name, description, supported, action, forced, standard } = signal;
        return {
            [number]: {
                name,
                number,
                description,
                supported,
                action,
                forced,
                standard
            }
        };
    };
    const findSignalByNumber = (number, signals)=>{
        const signal = signals.find(({ name })=>_f_node_os.constants.signals[name] === number);
        if (signal !== undefined) {
            return signal;
        }
        return signals.find((signalA)=>signalA.number === number);
    };
    var signalsByNumber = getSignalsByNumber();
}
,
"8ab57d03":function  (module, exports, farmRequire, farmDynamicRequire) {
    var Stream = global.nodeRequire('stream', true).Stream;
    module.exports = legacy;
    function legacy(fs) {
        return {
            ReadStream: ReadStream,
            WriteStream: WriteStream
        };
        function ReadStream(path, options) {
            if (!(this instanceof ReadStream)) return new ReadStream(path, options);
            Stream.call(this);
            var self = this;
            this.path = path;
            this.fd = null;
            this.readable = true;
            this.paused = false;
            this.flags = 'r';
            this.mode = 438;
            this.bufferSize = 64 * 1024;
            options = options || {};
            var keys = Object.keys(options);
            for(var index = 0, length = keys.length; index < length; index++){
                var key = keys[index];
                this[key] = options[key];
            }
            if (this.encoding) this.setEncoding(this.encoding);
            if (this.start !== undefined) {
                if ('number' !== typeof this.start) {
                    throw TypeError('start must be a Number');
                }
                if (this.end === undefined) {
                    this.end = Infinity;
                } else if ('number' !== typeof this.end) {
                    throw TypeError('end must be a Number');
                }
                if (this.start > this.end) {
                    throw new Error('start must be <= end');
                }
                this.pos = this.start;
            }
            if (this.fd !== null) {
                process.nextTick(function() {
                    self._read();
                });
                return;
            }
            fs.open(this.path, this.flags, this.mode, function(err, fd) {
                if (err) {
                    self.emit('error', err);
                    self.readable = false;
                    return;
                }
                self.fd = fd;
                self.emit('open', fd);
                self._read();
            });
        }
        function WriteStream(path, options) {
            if (!(this instanceof WriteStream)) return new WriteStream(path, options);
            Stream.call(this);
            this.path = path;
            this.fd = null;
            this.writable = true;
            this.flags = 'w';
            this.encoding = 'binary';
            this.mode = 438;
            this.bytesWritten = 0;
            options = options || {};
            var keys = Object.keys(options);
            for(var index = 0, length = keys.length; index < length; index++){
                var key = keys[index];
                this[key] = options[key];
            }
            if (this.start !== undefined) {
                if ('number' !== typeof this.start) {
                    throw TypeError('start must be a Number');
                }
                if (this.start < 0) {
                    throw new Error('start must be >= zero');
                }
                this.pos = this.start;
            }
            this.busy = false;
            this._queue = [];
            if (this.fd === null) {
                this._open = fs.open;
                this._queue.push([
                    this._open,
                    this.path,
                    this.flags,
                    this.mode,
                    undefined
                ]);
                this.flush();
            }
        }
    }
}
,
"8ac9b201":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.joinPathSegments = void 0;
    function joinPathSegments(a, b, separator) {
        if (a.endsWith(separator)) {
            return a + b;
        }
        return a + separator + b;
    }
    exports.joinPathSegments = joinPathSegments;
}
,
"8c2028dc":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "Logger", ()=>Logger);
    module.o(exports, "NoopLogger", ()=>NoopLogger);
    module.o(exports, "printServerUrls", ()=>printServerUrls);
    module.o(exports, "bootstrapLogger", ()=>bootstrapLogger);
    module.o(exports, "bootstrap", ()=>bootstrap);
    module.o(exports, "logger", ()=>logger);
    module.o(exports, "buildErrorMessage", ()=>buildErrorMessage);
    var _f_color = farmRequire("f19542e0");
    var _f_share = farmRequire("bc6cc539");
    var LogLevel;
    (function(LogLevel) {
        LogLevel["Trace"] = "trace";
        LogLevel["Debug"] = "debug";
        LogLevel["Info"] = "info";
        LogLevel["Warn"] = "warn";
        LogLevel["Error"] = "error";
    })(LogLevel || (LogLevel = {}));
    const LOGGER_METHOD = {
        info: 'log',
        warn: 'warn',
        error: 'error'
    };
    const warnOnceMessages = new Set();
    const infoOnceMessages = new Set();
    const errorOnceMessages = new Set();
    class Logger {
        options;
        levelValues;
        prefix;
        constructor(options, levelValues = {
            trace: 0,
            debug: 1,
            info: 2,
            warn: 3,
            error: 4
        }, prefix){
            this.options = options;
            this.levelValues = levelValues;
            this.prefix = prefix;
            if (!this.options) this.options = {};
            this.brandPrefix();
        }
        brandPrefix(color) {
            const { name = 'Farm' } = this.options;
            const formattedName = _f_color.colors.bold(name);
            const formattedPrefix = _f_color.colors.bold(`[ ${formattedName} ]`);
            this.prefix = color ? color(formattedPrefix) : formattedPrefix;
        }
        logMessage(level, message, color, showBanner = true) {
            const loggerMethod = level in LOGGER_METHOD ? LOGGER_METHOD[level] : 'log';
            if (this.levelValues[level] <= this.levelValues[level]) {
                const prefix = showBanner ? this.prefix + ' ' : '';
                const loggerMessage = color ? color(prefix + message) : prefix + message;
                console[loggerMethod](loggerMessage);
            }
        }
        setPrefix(options) {
            if (options.name) {
                this.options.name = options.name;
                this.brandPrefix(options.brandColor);
            }
        }
        trace(message) {
            this.brandPrefix(_f_color.colors.green);
            this.logMessage("trace", message, _f_color.colors.magenta);
        }
        debug(message) {
            this.brandPrefix(_f_color.colors.debugColor);
            this.logMessage("debug", message, _f_color.colors.blue);
        }
        info(message, iOptions) {
            const options = iOptions;
            if (options) {
                this.setPrefix(options);
            }
            if (!options || !options.brandColor) {
                this.brandPrefix(_f_color.colors.brandColor);
            }
            this.logMessage("info", message, null);
        }
        warn(message) {
            this.brandPrefix(_f_color.colors.yellow);
            this.logMessage("warn", message, _f_color.colors.yellow);
        }
        error(message, errorOptions) {
            this.brandPrefix(_f_color.colors.red);
            const effectiveOptions = {
                ...this.options,
                ...errorOptions
            };
            const causeError = errorOptions?.e || errorOptions?.error;
            let error;
            if (typeof message === 'string') {
                error = new Error(message);
                error.stack = '';
            } else {
                error = message;
            }
            if (causeError) {
                error.message += `\nCaused by: ${causeError.stack ?? causeError}`;
            }
            this.logMessage("error", error, _f_color.colors.red);
            if (effectiveOptions.exit) {
                process.exit(1);
            }
        }
        infoOnce(message) {
            if (!infoOnceMessages.has(message)) {
                infoOnceMessages.add(message);
                this.info(message);
            }
        }
        warnOnce(message) {
            if (!warnOnceMessages.has(message)) {
                warnOnceMessages.add(message);
                this.warn(message);
            }
        }
        errorOnce(message) {
            if (!errorOnceMessages.has(message)) {
                errorOnceMessages.add(message);
                this.error(message);
            }
        }
        hasErrorLogged(message) {
            return errorOnceMessages.has(message);
        }
        hasWarnLogged(message) {
            return warnOnceMessages.has(message);
        }
    }
    class NoopLogger extends Logger {
        setPrefix(_options) {}
        trace(_message) {}
        debug(_message) {}
        info(_message, _iOptions) {}
        warn(_message) {}
        error(_message, _errorOptions) {
            if (_errorOptions.exit) {
                let e = _message instanceof Error ? _message : new Error(_message);
                if (_errorOptions?.e || _errorOptions?.error) {
                    e.cause = _errorOptions.e || _errorOptions.error;
                }
                throw e;
            }
        }
        infoOnce(_message) {}
        warnOnce(_message) {}
        errorOnce(_message) {}
        hasErrorLogged(_message) {
            return false;
        }
        hasWarnLogged(_message) {
            return false;
        }
    }
    function printServerUrls(urls, logger, previewFlag = false) {
        if (previewFlag) logger.info(_f_color.colors.bold(_f_color.colors.magenta('preview server running at: \n')));
        const colorUrl = (url)=>_f_color.colors.cyan(url.replace(/:(\d+)\//, (_, port)=>`:${_f_color.colors.bold(port)}/`));
        const logUrl = (url, type)=>logger.info(`${_f_color.colors.bold(_f_color.colors.magenta('>'))} ${_f_color.colors.bold(type)}${_f_color.colors.bold(colorUrl(url))}`);
        urls.local.map((url)=>logUrl(url, 'Local:   '));
        urls.network.map((url)=>logUrl(url, 'Network: '));
    }
    function bootstrapLogger(options) {
        return new Logger(options);
    }
    function bootstrap(times, config) {
        const usePersistentCache = config.config.persistentCache;
        const persistentCacheFlag = usePersistentCache ? _f_color.colors.bold(_f_color.PersistentCacheBrand) : '';
        console.log('\n', _f_color.colors.bold(_f_color.colors.brandColor(`${''}  Farm  v${_f_share.version}`)));
        console.log(`${_f_color.colors.bold(_f_color.colors.green(` `))}  ${_f_color.colors.bold('Ready in')} ${_f_color.colors.bold(_f_color.colors.green(`${times}ms`))} ${persistentCacheFlag}`, '\n');
    }
    var logger = new Logger();
    function buildErrorMessage(err, args = [], includeStack = true) {
        if (err.plugin) args.push(`  Plugin: ${_f_color.colors.magenta(err.plugin)}`);
        const loc = err.loc ? `:${err.loc.line}:${err.loc.column}` : '';
        if (err.id) args.push(`  File: ${_f_color.colors.cyan(err.id)}${loc}`);
        if (err.frame) args.push(_f_color.colors.yellow(_f_share.pad(err.frame)));
        if (includeStack && err.stack) args.push(_f_share.pad(cleanStack(err.stack)));
        return args.join('\n');
    }
    function cleanStack(stack) {
        return stack.split(/\n/g).filter((l)=>/^\s*at/.test(l)).join('\n');
    }
}
,
"8c243424":/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ function  (module, exports, farmRequire, farmDynamicRequire) {
    module.exports = runParallel;
    const queueMicrotask = farmRequire("6e017c36", true);
    function runParallel(tasks, cb) {
        let results, pending, keys;
        let isSync = true;
        if (Array.isArray(tasks)) {
            results = [];
            pending = tasks.length;
        } else {
            keys = Object.keys(tasks);
            results = {};
            pending = keys.length;
        }
        function done(err) {
            function end() {
                if (cb) cb(err, results);
                cb = null;
            }
            if (isSync) queueMicrotask(end);
            else end();
        }
        function each(i, err, result) {
            results[i] = result;
            if (--pending === 0 || err) {
                done(err);
            }
        }
        if (!pending) {
            done(null);
        } else if (keys) {
            keys.forEach(function(key) {
                tasks[key](function(err, result) {
                    each(key, err, result);
                });
            });
        } else {
            tasks.forEach(function(task, i) {
                task(function(err, result) {
                    each(i, err, result);
                });
            });
        }
        isSync = false;
    }
}
,
"8c2cda22":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const co = farmRequire("6d02a8d3", true);
    const compose = farmRequire("d4b3f209", true);
    module.exports = convert;
    function convert(mw) {
        if (typeof mw !== 'function') {
            throw new TypeError('middleware must be a function');
        }
        if (mw.constructor.name !== 'GeneratorFunction' && mw.constructor.name !== 'AsyncGeneratorFunction') {
            return mw;
        }
        const converted = function(ctx, next) {
            return co.call(ctx, mw.call(ctx, function*(next) {
                return yield next();
            }(next)));
        };
        converted._name = mw._name || mw.name;
        return converted;
    }
    convert.compose = function(arr) {
        if (!Array.isArray(arr)) {
            arr = Array.from(arguments);
        }
        return compose(arr.map(convert));
    };
    convert.back = function(mw) {
        if (typeof mw !== 'function') {
            throw new TypeError('middleware must be a function');
        }
        if (mw.constructor.name === 'GeneratorFunction' || mw.constructor.name === 'AsyncGeneratorFunction') {
            return mw;
        }
        const converted = function*(next) {
            const ctx = this;
            let called = false;
            yield mw(ctx, function() {
                if (called) {
                    throw new Error('next() called multiple times');
                }
                called = true;
                return co.call(ctx, next);
            });
        };
        converted._name = mw._name || mw.name;
        return converted;
    };
}
,
"8c96cd12":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const { PassThrough: PassThroughStream } = global.nodeRequire('stream', true);
    module.exports = (options)=>{
        options = {
            ...options
        };
        const { array } = options;
        let { encoding } = options;
        const isBuffer = encoding === 'buffer';
        let objectMode = false;
        if (array) {
            objectMode = !(encoding || isBuffer);
        } else {
            encoding = encoding || 'utf8';
        }
        if (isBuffer) {
            encoding = null;
        }
        const stream = new PassThroughStream({
            objectMode
        });
        if (encoding) {
            stream.setEncoding(encoding);
        }
        let length = 0;
        const chunks = [];
        stream.on('data', (chunk)=>{
            chunks.push(chunk);
            if (objectMode) {
                length = chunks.length;
            } else {
                length += chunk.length;
            }
        });
        stream.getBufferedValue = ()=>{
            if (array) {
                return chunks;
            }
            return isBuffer ? Buffer.concat(chunks, length) : chunks.join('');
        };
        stream.getBufferedLength = ()=>length;
        return stream;
    };
}
,
"8f02d3ce":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const URL = global.nodeRequire('url', true).URL;
    const net = global.nodeRequire('net', true);
    const accepts = farmRequire("ee4d4390", true);
    const contentType = farmRequire("910e4680", true);
    const stringify = global.nodeRequire('url', true).format;
    const parse = farmRequire("11116ee2", true);
    const qs = global.nodeRequire('querystring', true);
    const typeis = farmRequire("7a5f0ee9", true);
    const fresh = farmRequire("a2f11397", true);
    const only = farmRequire("d8812774", true);
    const util = global.nodeRequire('util', true);
    const IP = Symbol('context#ip');
    module.exports = {
        get header () {
            return this.req.headers;
        },
        set header (val){
            this.req.headers = val;
        },
        get headers () {
            return this.req.headers;
        },
        set headers (val){
            this.req.headers = val;
        },
        get url () {
            return this.req.url;
        },
        set url (val){
            this.req.url = val;
        },
        get origin () {
            return `${this.protocol}://${this.host}`;
        },
        get href () {
            if (/^https?:\/\//i.test(this.originalUrl)) return this.originalUrl;
            return this.origin + this.originalUrl;
        },
        get method () {
            return this.req.method;
        },
        set method (val){
            this.req.method = val;
        },
        get path () {
            return parse(this.req).pathname;
        },
        set path (path){
            const url = parse(this.req);
            if (url.pathname === path) return;
            url.pathname = path;
            url.path = null;
            this.url = stringify(url);
        },
        get query () {
            const str1 = this.querystring;
            const c = this._querycache = this._querycache || {};
            return c[str1] || (c[str1] = qs.parse(str1));
        },
        set query (obj){
            this.querystring = qs.stringify(obj);
        },
        get querystring () {
            if (!this.req) return '';
            return parse(this.req).query || '';
        },
        set querystring (str){
            const url = parse(this.req);
            if (url.search === `?${str}`) return;
            url.search = str;
            url.path = null;
            this.url = stringify(url);
        },
        get search () {
            if (!this.querystring) return '';
            return `?${this.querystring}`;
        },
        set search (str){
            this.querystring = str;
        },
        get host () {
            const proxy = this.app.proxy;
            let host = proxy && this.get('X-Forwarded-Host');
            if (!host) {
                if (this.req.httpVersionMajor >= 2) host = this.get(':authority');
                if (!host) host = this.get('Host');
            }
            if (!host) return '';
            return host.split(/\s*,\s*/, 1)[0];
        },
        get hostname () {
            const host = this.host;
            if (!host) return '';
            if ('[' === host[0]) return this.URL.hostname || '';
            return host.split(':', 1)[0];
        },
        get URL () {
            if (!this.memoizedURL) {
                const originalUrl = this.originalUrl || '';
                try {
                    this.memoizedURL = new URL(`${this.origin}${originalUrl}`);
                } catch (err) {
                    this.memoizedURL = Object.create(null);
                }
            }
            return this.memoizedURL;
        },
        get fresh () {
            const method = this.method;
            const s = this.ctx.status;
            if ('GET' !== method && 'HEAD' !== method) return false;
            if (s >= 200 && s < 300 || 304 === s) {
                return fresh(this.header, this.response.header);
            }
            return false;
        },
        get stale () {
            return !this.fresh;
        },
        get idempotent () {
            const methods = [
                'GET',
                'HEAD',
                'PUT',
                'DELETE',
                'OPTIONS',
                'TRACE'
            ];
            return !!~methods.indexOf(this.method);
        },
        get socket () {
            return this.req.socket;
        },
        get charset () {
            try {
                const { parameters } = contentType.parse(this.req);
                return parameters.charset || '';
            } catch (e) {
                return '';
            }
        },
        get length () {
            const len = this.get('Content-Length');
            if (len === '') return;
            return ~~len;
        },
        get protocol () {
            if (this.socket.encrypted) return 'https';
            if (!this.app.proxy) return 'http';
            const proto = this.get('X-Forwarded-Proto');
            return proto ? proto.split(/\s*,\s*/, 1)[0] : 'http';
        },
        get secure () {
            return 'https' === this.protocol;
        },
        get ips () {
            const proxy = this.app.proxy;
            const val1 = this.get(this.app.proxyIpHeader);
            let ips = proxy && val1 ? val1.split(/\s*,\s*/) : [];
            if (this.app.maxIpsCount > 0) {
                ips = ips.slice(-this.app.maxIpsCount);
            }
            return ips;
        },
        get ip () {
            if (!this[IP]) {
                this[IP] = this.ips[0] || this.socket.remoteAddress || '';
            }
            return this[IP];
        },
        set ip (_ip){
            this[IP] = _ip;
        },
        get subdomains () {
            const offset = this.app.subdomainOffset;
            const hostname = this.hostname;
            if (net.isIP(hostname)) return [];
            return hostname.split('.').reverse().slice(offset);
        },
        get accept () {
            return this._accept || (this._accept = accepts(this.req));
        },
        set accept (obj){
            this._accept = obj;
        },
        accepts (...args) {
            return this.accept.types(...args);
        },
        acceptsEncodings (...args) {
            return this.accept.encodings(...args);
        },
        acceptsCharsets (...args) {
            return this.accept.charsets(...args);
        },
        acceptsLanguages (...args) {
            return this.accept.languages(...args);
        },
        is (type, ...types) {
            return typeis(this.req, type, ...types);
        },
        get type () {
            const type = this.get('Content-Type');
            if (!type) return '';
            return type.split(';')[0];
        },
        get (field) {
            const req = this.req;
            switch(field = field.toLowerCase()){
                case 'referer':
                case 'referrer':
                    return req.headers.referrer || req.headers.referer || '';
                default:
                    return req.headers[field] || '';
            }
        },
        inspect () {
            if (!this.req) return;
            return this.toJSON();
        },
        toJSON () {
            return only(this, [
                'method',
                'url',
                'header'
            ]);
        }
    };
    if (util.inspect.custom) {
        module.exports[util.inspect.custom] = module.exports.inspect;
    }
}
,
"910e4680":/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;
    var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/;
    var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
    var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g;
    var QUOTE_REGEXP = /([\\"])/g;
    var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
    exports.format = format;
    exports.parse = parse;
    function format(obj) {
        if (!obj || typeof obj !== 'object') {
            throw new TypeError('argument obj is required');
        }
        var parameters = obj.parameters;
        var type = obj.type;
        if (!type || !TYPE_REGEXP.test(type)) {
            throw new TypeError('invalid type');
        }
        var string = type;
        if (parameters && typeof parameters === 'object') {
            var param;
            var params = Object.keys(parameters).sort();
            for(var i = 0; i < params.length; i++){
                param = params[i];
                if (!TOKEN_REGEXP.test(param)) {
                    throw new TypeError('invalid parameter name');
                }
                string += '; ' + param + '=' + qstring(parameters[param]);
            }
        }
        return string;
    }
    function parse(string) {
        if (!string) {
            throw new TypeError('argument string is required');
        }
        var header = typeof string === 'object' ? getcontenttype(string) : string;
        if (typeof header !== 'string') {
            throw new TypeError('argument string is required to be a string');
        }
        var index = header.indexOf(';');
        var type = index !== -1 ? header.slice(0, index).trim() : header.trim();
        if (!TYPE_REGEXP.test(type)) {
            throw new TypeError('invalid media type');
        }
        var obj = new ContentType(type.toLowerCase());
        if (index !== -1) {
            var key;
            var match;
            var value;
            PARAM_REGEXP.lastIndex = index;
            while(match = PARAM_REGEXP.exec(header)){
                if (match.index !== index) {
                    throw new TypeError('invalid parameter format');
                }
                index += match[0].length;
                key = match[1].toLowerCase();
                value = match[2];
                if (value.charCodeAt(0) === 0x22) {
                    value = value.slice(1, -1);
                    if (value.indexOf('\\') !== -1) {
                        value = value.replace(QESC_REGEXP, '$1');
                    }
                }
                obj.parameters[key] = value;
            }
            if (index !== header.length) {
                throw new TypeError('invalid parameter format');
            }
        }
        return obj;
    }
    function getcontenttype(obj) {
        var header;
        if (typeof obj.getHeader === 'function') {
            header = obj.getHeader('content-type');
        } else if (typeof obj.headers === 'object') {
            header = obj.headers && obj.headers['content-type'];
        }
        if (typeof header !== 'string') {
            throw new TypeError('content-type header is missing from object');
        }
        return header;
    }
    function qstring(val) {
        var str = String(val);
        if (TOKEN_REGEXP.test(str)) {
            return str;
        }
        if (str.length > 0 && !TEXT_REGEXP.test(str)) {
            throw new TypeError('invalid parameter value');
        }
        return '"' + str.replace(QUOTE_REGEXP, '\\$1') + '"';
    }
    function ContentType(type) {
        this.parameters = Object.create(null);
        this.type = type;
    }
}
,
"91b8e001":function  (module, exports, farmRequire, farmDynamicRequire) {
    var s = 1000;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
        options = options || {};
        var type = typeof val;
        if (type === 'string' && val.length > 0) {
            return parse(val);
        } else if (type === 'number' && isFinite(val)) {
            return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
    };
    function parse(str) {
        str = String(str);
        if (str.length > 100) {
            return;
        }
        var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
        if (!match) {
            return;
        }
        var n = parseFloat(match[1]);
        var type = (match[2] || 'ms').toLowerCase();
        switch(type){
            case 'years':
            case 'year':
            case 'yrs':
            case 'yr':
            case 'y':
                return n * y;
            case 'weeks':
            case 'week':
            case 'w':
                return n * w;
            case 'days':
            case 'day':
            case 'd':
                return n * d;
            case 'hours':
            case 'hour':
            case 'hrs':
            case 'hr':
            case 'h':
                return n * h;
            case 'minutes':
            case 'minute':
            case 'mins':
            case 'min':
            case 'm':
                return n * m;
            case 'seconds':
            case 'second':
            case 'secs':
            case 'sec':
            case 's':
                return n * s;
            case 'milliseconds':
            case 'millisecond':
            case 'msecs':
            case 'msec':
            case 'ms':
                return n;
            default:
                return undefined;
        }
    }
    function fmtShort(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
            return Math.round(ms / d) + 'd';
        }
        if (msAbs >= h) {
            return Math.round(ms / h) + 'h';
        }
        if (msAbs >= m) {
            return Math.round(ms / m) + 'm';
        }
        if (msAbs >= s) {
            return Math.round(ms / s) + 's';
        }
        return ms + 'ms';
    }
    function fmtLong(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
            return plural(ms, msAbs, d, 'day');
        }
        if (msAbs >= h) {
            return plural(ms, msAbs, h, 'hour');
        }
        if (msAbs >= m) {
            return plural(ms, msAbs, m, 'minute');
        }
        if (msAbs >= s) {
            return plural(ms, msAbs, s, 'second');
        }
        return ms + ' ms';
    }
    function plural(ms, msAbs, n, name) {
        var isPlural = msAbs >= n * 1.5;
        return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
    }
}
,
"922e32a0":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const normalizeArgs = (file, args = [])=>{
        if (!Array.isArray(args)) {
            return [
                file
            ];
        }
        return [
            file,
            ...args
        ];
    };
    const NO_ESCAPE_REGEXP = /^[\w.-]+$/;
    const DOUBLE_QUOTES_REGEXP = /"/g;
    const escapeArg = (arg)=>{
        if (typeof arg !== 'string' || NO_ESCAPE_REGEXP.test(arg)) {
            return arg;
        }
        return `"${arg.replace(DOUBLE_QUOTES_REGEXP, '\\"')}"`;
    };
    const joinCommand = (file, args)=>{
        return normalizeArgs(file, args).join(' ');
    };
    const getEscapedCommand = (file, args)=>{
        return normalizeArgs(file, args).map((arg)=>escapeArg(arg)).join(' ');
    };
    const SPACES_REGEXP = / +/g;
    const parseCommand = (command)=>{
        const tokens = [];
        for (const token of command.trim().split(SPACES_REGEXP)){
            const previousToken = tokens[tokens.length - 1];
            if (previousToken && previousToken.endsWith('\\')) {
                tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;
            } else {
                tokens.push(token);
            }
        }
        return tokens;
    };
    module.exports = {
        joinCommand,
        getEscapedCommand,
        parseCommand
    };
}
,
"93658e5a":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "__FARM_GLOBAL__", ()=>__FARM_GLOBAL__);
    var __FARM_GLOBAL__ = {
        __FARM_RESTART_DEV_SERVER__: false
    };
}
,
"95307fb5":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "default", ()=>defineLazyProperty);
    function defineLazyProperty(object, propertyName, valueGetter) {
        const define = (value)=>Object.defineProperty(object, propertyName, {
                value,
                enumerable: true,
                writable: true
            });
        Object.defineProperty(object, propertyName, {
            configurable: true,
            enumerable: true,
            get () {
                const result = valueGetter();
                define(result);
                return result;
            },
            set (value) {
                define(value);
            }
        });
        return object;
    }
}
,
"953dfae2":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "start", ()=>start);
    module.o(exports, "build", ()=>build);
    module.o(exports, "preview", ()=>preview);
    module.o(exports, "watch", ()=>watch);
    module.o(exports, "clean", ()=>clean);
    module.o(exports, "createBundleHandler", ()=>createBundleHandler);
    module.o(exports, "createCompiler", ()=>createCompiler);
    module.o(exports, "createDevServer", ()=>createDevServer);
    module.o(exports, "createFileWatcher", ()=>createFileWatcher);
    module.o(exports, "logFileChanges", ()=>logFileChanges);
    module.o(exports, "loadEnv", ()=>_f_env.loadEnv);
    var _f_node_fs = farmRequire('node:fs');
    var _f_promises = module.i(farmRequire('node:fs/promises'));
    var _f_node_path = module.i(farmRequire('node:path'));
    var _f_fs_extra = module.i(farmRequire("77e37188"));
    var _f_index = farmRequire("bf50199b");
    var _f_env = farmRequire("83b19369");
    var _f_index1 = farmRequire("491ca098");
    var _f_index2 = farmRequire("bd075d6a");
    var _f_build = farmRequire("893ee78a");
    var _f_color = farmRequire("f19542e0");
    var _f_logger = farmRequire("8c2028dc");
    var _f_index3 = farmRequire("3466e00c");
    var _f__global = farmRequire("93658e5a");
    var _f_error = farmRequire("972397d2");
    var _f_lazy_compilation = farmRequire("cbf7c3bf");
    var _f_config_watcher = farmRequire("6716d73f");
    var _f_http = farmRequire("84a68c6c");
    var _f_index4 = farmRequire("bf50199b");
    module._e(exports, _f_index4);
    var _f_index5 = farmRequire("491ca098");
    module._e(exports, _f_index5);
    var _f_index6 = farmRequire("bd075d6a");
    module._e(exports, _f_index6);
    var _f_type = farmRequire("3fc2054c");
    module._e(exports, _f_type);
    var _f_index7 = farmRequire("65ad6846");
    module._e(exports, _f_index7);
    async function start(inlineConfig) {
        inlineConfig = inlineConfig ?? {};
        const logger = inlineConfig.logger ?? new _f_logger.Logger();
        _f_env.setProcessEnv('development');
        try {
            const resolvedUserConfig = await _f_index1.resolveConfig(inlineConfig, 'development', logger);
            if (resolvedUserConfig.compilation.lazyCompilation && typeof resolvedUserConfig.server?.host === 'string') {
                setLazyCompilationDefine(resolvedUserConfig);
            }
            const compiler = await createCompiler(resolvedUserConfig, logger);
            const devServer = await createDevServer(compiler, resolvedUserConfig, logger);
            await devServer.listen();
        } catch (error) {
            logger.error('Failed to start the server', {
                exit: true,
                error
            });
        }
    }
    async function build(inlineConfig) {
        inlineConfig = inlineConfig ?? {};
        const logger = inlineConfig.logger ?? new _f_logger.Logger();
        _f_env.setProcessEnv('production');
        const resolvedUserConfig = await _f_index1.resolveConfig(inlineConfig, 'production', logger, false);
        try {
            await createBundleHandler(resolvedUserConfig, logger);
            await copyPublicDirectory(resolvedUserConfig, logger);
        } catch (err) {
            logger.error(`Failed to build: ${err}`, {
                exit: true
            });
        }
    }
    async function preview(inlineConfig) {
        inlineConfig = inlineConfig ?? {};
        const logger = inlineConfig.logger ?? new _f_logger.Logger();
        const resolvedUserConfig = await _f_index1.resolveConfig(inlineConfig, 'production', logger);
        const { root, output } = resolvedUserConfig.compilation;
        const distDir = module.f(_f_node_path).resolve(root, output.path);
        try {
            _f_node_fs.statSync(distDir);
        } catch (err) {
            if (err.code === 'ENOENT') {
                throw new Error(`The directory "${distDir}" does not exist. Did you build your project?`);
            }
        }
        const serverConfig = {
            ...resolvedUserConfig.server,
            host: inlineConfig.host ?? true,
            port: inlineConfig.port ?? (Number(process.env.FARM_DEFAULT_SERVER_PORT) || 1911)
        };
        await _f_index2.Server.resolvePortConflict(serverConfig, logger);
        const port = serverConfig.port;
        const host = serverConfig.host;
        const previewOptions = {
            ...serverConfig,
            distDir,
            output: {
                path: output.path,
                publicPath: output.publicPath
            },
            port,
            host
        };
        const server = new _f_index2.Server({
            logger
        });
        server.createPreviewServer(previewOptions);
    }
    async function watch(inlineConfig) {
        inlineConfig = inlineConfig ?? {};
        const logger = inlineConfig.logger ?? new _f_logger.Logger();
        _f_env.setProcessEnv('development');
        inlineConfig.server ??= {};
        inlineConfig.server.hmr ??= false;
        const resolvedUserConfig = await _f_index1.resolveConfig(inlineConfig, 'development', logger, false);
        const lazyEnabled = resolvedUserConfig.compilation?.lazyCompilation;
        if (lazyEnabled) {
            setLazyCompilationDefine(resolvedUserConfig);
        }
        const compilerFileWatcher = await createBundleHandler(resolvedUserConfig, logger, true);
        let devServer;
        if (lazyEnabled) {
            devServer = new _f_index2.Server({
                logger,
                compiler: compilerFileWatcher.serverOrCompiler
            });
            devServer.createServer(resolvedUserConfig.server);
            devServer.applyMiddlewares([
                _f_lazy_compilation.lazyCompilation
            ]);
            await devServer.startServer(resolvedUserConfig.server);
        }
        async function handleFileChange(files) {
            logFileChanges(files, resolvedUserConfig.root, logger);
            try {
                farmWatcher.close();
                if (lazyEnabled && devServer) {
                    devServer.close();
                }
                _f__global.__FARM_GLOBAL__.__FARM_RESTART_DEV_SERVER__ = true;
                compilerFileWatcher?.close();
                await watch(inlineConfig);
            } catch (error) {
                logger.error(`Error restarting the watcher: ${error.message}`);
            }
        }
        const farmWatcher = new _f_config_watcher.ConfigWatcher(resolvedUserConfig).watch(handleFileChange);
    }
    async function clean(rootPath, recursive) {
        const logger = new _f_logger.Logger();
        const nodeModulesFolders = recursive ? await findNodeModulesRecursively(rootPath) : [
            module.f(_f_node_path).join(rootPath, 'node_modules')
        ];
        await Promise.all(nodeModulesFolders.map(async (nodeModulesPath)=>{
            const farmFolderPath = module.f(_f_node_path).join(nodeModulesPath, '.farm');
            try {
                const stats = await module.f(_f_promises).stat(farmFolderPath);
                if (stats.isDirectory()) {
                    await module.f(_f_promises).rm(farmFolderPath, {
                        recursive: true,
                        force: true
                    });
                    logger.info(`Cache cleaned at ${_f_color.colors.bold(_f_color.colors.green(nodeModulesPath))}`);
                }
            } catch (error) {
                if (error.code === 'ENOENT') {
                    logger.warn(`No cached files found in ${_f_color.colors.bold(_f_color.colors.green(nodeModulesPath))}`);
                } else {
                    logger.error(`Error cleaning cache in ${_f_color.colors.bold(_f_color.colors.green(nodeModulesPath))}: ${error.message}`);
                }
            }
        }));
    }
    async function findNodeModulesRecursively(rootPath) {
        const result = [];
        async function traverse(currentPath) {
            const items = await module.f(_f_promises).readdir(currentPath);
            for (const item of items){
                const fullPath = module.f(_f_node_path).join(currentPath, item);
                const stats = await module.f(_f_promises).stat(fullPath);
                if (stats.isDirectory()) {
                    if (item === 'node_modules') {
                        result.push(fullPath);
                    } else {
                        await traverse(fullPath);
                    }
                }
            }
        }
        await traverse(rootPath);
        return result;
    }
    async function createBundleHandler(resolvedUserConfig, logger, watchMode = false) {
        const compiler = await createCompiler(resolvedUserConfig, logger);
        await _f_build.compilerHandler(async ()=>{
            if (resolvedUserConfig.compilation?.output?.clean) {
                compiler.removeOutputPathDir();
            }
            try {
                await compiler.compile();
            } catch (err) {
                throw new Error(_f_error.logError(err));
            }
            compiler.writeResourcesToDisk();
        }, resolvedUserConfig, logger);
        if (resolvedUserConfig.compilation?.watch || watchMode) {
            const watcher = new _f_index3.FileWatcher(compiler, resolvedUserConfig, logger);
            await watcher.watch();
            return watcher;
        }
    }
    async function createCompiler(resolvedUserConfig, logger) {
        const { jsPlugins, rustPlugins, compilation: compilationConfig } = resolvedUserConfig;
        const compiler = new _f_index.Compiler({
            config: compilationConfig,
            jsPlugins,
            rustPlugins
        }, logger);
        for (const plugin of jsPlugins){
            await plugin.configureCompiler?.(compiler);
        }
        return compiler;
    }
    async function copyPublicDirectory(resolvedUserConfig, logger) {
        const absPublicDirPath = _f_index1.normalizePublicDir(resolvedUserConfig.root, resolvedUserConfig.publicDir);
        try {
            if (await module.f(_f_fs_extra).pathExists(absPublicDirPath)) {
                const files = await module.f(_f_fs_extra).readdir(absPublicDirPath);
                const outputPath = resolvedUserConfig.compilation.output.path;
                for (const file of files){
                    const publicFile = module.f(_f_node_path).join(absPublicDirPath, file);
                    const destFile = module.f(_f_node_path).join(outputPath, file);
                    if (await module.f(_f_fs_extra).pathExists(destFile)) {
                        continue;
                    }
                    await module.f(_f_fs_extra).copy(publicFile, destFile);
                }
                logger.info(`Public directory resources copied ${_f_color.colors.bold(_f_color.colors.green('successfully'))}.`);
            }
        } catch (error) {
            logger.error(`Error copying public directory: ${error.message}`);
        }
    }
    async function createDevServer(compiler, resolvedUserConfig, logger) {
        const server = new _f_index2.Server({
            compiler,
            logger
        });
        await server.createDevServer(resolvedUserConfig.server);
        await createFileWatcher(server, resolvedUserConfig, logger);
        resolvedUserConfig.jsPlugins.forEach((plugin)=>plugin.configureDevServer?.(server));
        return server;
    }
    async function createFileWatcher(devServer, resolvedUserConfig, logger = new _f_logger.Logger()) {
        if (devServer.config.hmr && resolvedUserConfig.compilation.mode === 'production') {
            logger.error('HMR cannot be enabled in production mode.');
            return;
        }
        if (!devServer.config.hmr) {
            return;
        }
        if (devServer.watcher) {
            return;
        }
        const fileWatcher = new _f_index3.FileWatcher(devServer, resolvedUserConfig, logger);
        devServer.watcher = fileWatcher;
        await fileWatcher.watch();
        const configFilePath = await _f_index1.getConfigFilePath(resolvedUserConfig.root);
        const farmWatcher = new _f_config_watcher.ConfigWatcher({
            ...resolvedUserConfig,
            configFilePath
        });
        farmWatcher.watch(async (files)=>{
            _f_index1.checkClearScreen(resolvedUserConfig);
            devServer.restart(async ()=>{
                logFileChanges(files, resolvedUserConfig.root, logger);
                farmWatcher?.close();
                await devServer.close();
                _f__global.__FARM_GLOBAL__.__FARM_RESTART_DEV_SERVER__ = true;
                await start(resolvedUserConfig);
            });
        });
        return fileWatcher;
    }
    function logFileChanges(files, root, logger) {
        const changedFiles = files.map((file)=>module.f(_f_node_path).relative(root, file)).join(', ');
        logger.info(_f_color.colors.bold(_f_color.colors.green(`${changedFiles} changed, server will restart.`)));
    }
    function setLazyCompilationDefine(resolvedUserConfig) {
        const hostname = _f_http.resolveHostname(resolvedUserConfig.server.host);
        resolvedUserConfig.compilation.define = {
            ...resolvedUserConfig.compilation.define ?? {},
            FARM_LAZY_COMPILE_SERVER_URL: `${resolvedUserConfig.server.protocol || 'http'}://${hostname.host || 'localhost'}:${resolvedUserConfig.server.port}`
        };
    }
    var _f_index8 = farmRequire("491ca098");
    module._(exports, "defineConfig", _f_index8, "defineFarmConfig");
}
,
"959fb2d0":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const Stream = global.nodeRequire('stream', true);
    const PassThrough = Stream.PassThrough;
    const slice = Array.prototype.slice;
    module.exports = merge2;
    function merge2() {
        const streamsQueue = [];
        const args = slice.call(arguments);
        let merging = false;
        let options = args[args.length - 1];
        if (options && !Array.isArray(options) && options.pipe == null) {
            args.pop();
        } else {
            options = {};
        }
        const doEnd = options.end !== false;
        const doPipeError = options.pipeError === true;
        if (options.objectMode == null) {
            options.objectMode = true;
        }
        if (options.highWaterMark == null) {
            options.highWaterMark = 64 * 1024;
        }
        const mergedStream = PassThrough(options);
        function addStream() {
            for(let i = 0, len = arguments.length; i < len; i++){
                streamsQueue.push(pauseStreams(arguments[i], options));
            }
            mergeStream();
            return this;
        }
        function mergeStream() {
            if (merging) {
                return;
            }
            merging = true;
            let streams = streamsQueue.shift();
            if (!streams) {
                process.nextTick(endStream);
                return;
            }
            if (!Array.isArray(streams)) {
                streams = [
                    streams
                ];
            }
            let pipesCount = streams.length + 1;
            function next() {
                if (--pipesCount > 0) {
                    return;
                }
                merging = false;
                mergeStream();
            }
            function pipe(stream) {
                function onend() {
                    stream.removeListener('merge2UnpipeEnd', onend);
                    stream.removeListener('end', onend);
                    if (doPipeError) {
                        stream.removeListener('error', onerror);
                    }
                    next();
                }
                function onerror(err) {
                    mergedStream.emit('error', err);
                }
                if (stream._readableState.endEmitted) {
                    return next();
                }
                stream.on('merge2UnpipeEnd', onend);
                stream.on('end', onend);
                if (doPipeError) {
                    stream.on('error', onerror);
                }
                stream.pipe(mergedStream, {
                    end: false
                });
                stream.resume();
            }
            for(let i = 0; i < streams.length; i++){
                pipe(streams[i]);
            }
            next();
        }
        function endStream() {
            merging = false;
            mergedStream.emit('queueDrain');
            if (doEnd) {
                mergedStream.end();
            }
        }
        mergedStream.setMaxListeners(0);
        mergedStream.add = addStream;
        mergedStream.on('unpipe', function(stream) {
            stream.emit('merge2UnpipeEnd');
        });
        if (args.length) {
            addStream.apply(null, args);
        }
        return mergedStream;
    }
    function pauseStreams(streams, options) {
        if (!Array.isArray(streams)) {
            if (!streams._readableState && streams.pipe) {
                streams = streams.pipe(PassThrough(options));
            }
            if (!streams._readableState || !streams.pause || !streams.pipe) {
                throw new Error('Only readable stream can be merged.');
            }
            streams.pause();
        } else {
            for(let i = 0, len = streams.length; i < len; i++){
                streams[i] = pauseStreams(streams[i], options);
            }
        }
        return streams;
    }
}
,
"96c3b423":/*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    var deprecate = farmRequire("f6eecd34")('http-errors');
    var setPrototypeOf = farmRequire("b4cbd046", true);
    var statuses = farmRequire("5be87a60", true);
    var inherits = farmRequire("510e1346", true);
    module.exports = createError;
    module.exports.HttpError = createHttpErrorConstructor();
    populateConstructorExports(module.exports, statuses.codes, module.exports.HttpError);
    function codeClass(status) {
        return Number(String(status).charAt(0) + '00');
    }
    function createError() {
        var err;
        var msg;
        var status = 500;
        var props = {};
        for(var i = 0; i < arguments.length; i++){
            var arg = arguments[i];
            if (arg instanceof Error) {
                err = arg;
                status = err.status || err.statusCode || status;
                continue;
            }
            switch(typeof arg){
                case 'string':
                    msg = arg;
                    break;
                case 'number':
                    status = arg;
                    if (i !== 0) {
                        deprecate('non-first-argument status code; replace with createError(' + arg + ', ...)');
                    }
                    break;
                case 'object':
                    props = arg;
                    break;
            }
        }
        if (typeof status === 'number' && (status < 400 || status >= 600)) {
            deprecate('non-error status code; use only 4xx or 5xx status codes');
        }
        if (typeof status !== 'number' || !statuses[status] && (status < 400 || status >= 600)) {
            status = 500;
        }
        var HttpError = createError[status] || createError[codeClass(status)];
        if (!err) {
            err = HttpError ? new HttpError(msg) : new Error(msg || statuses[status]);
            Error.captureStackTrace(err, createError);
        }
        if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
            err.expose = status < 500;
            err.status = err.statusCode = status;
        }
        for(var key in props){
            if (key !== 'status' && key !== 'statusCode') {
                err[key] = props[key];
            }
        }
        return err;
    }
    function createHttpErrorConstructor() {
        function HttpError() {
            throw new TypeError('cannot construct abstract class');
        }
        inherits(HttpError, Error);
        return HttpError;
    }
    function createClientErrorConstructor(HttpError, name, code) {
        var className = name.match(/Error$/) ? name : name + 'Error';
        function ClientError(message) {
            var msg = message != null ? message : statuses[code];
            var err = new Error(msg);
            Error.captureStackTrace(err, ClientError);
            setPrototypeOf(err, ClientError.prototype);
            Object.defineProperty(err, 'message', {
                enumerable: true,
                configurable: true,
                value: msg,
                writable: true
            });
            Object.defineProperty(err, 'name', {
                enumerable: false,
                configurable: true,
                value: className,
                writable: true
            });
            return err;
        }
        inherits(ClientError, HttpError);
        ClientError.prototype.status = code;
        ClientError.prototype.statusCode = code;
        ClientError.prototype.expose = true;
        return ClientError;
    }
    function createServerErrorConstructor(HttpError, name, code) {
        var className = name.match(/Error$/) ? name : name + 'Error';
        function ServerError(message) {
            var msg = message != null ? message : statuses[code];
            var err = new Error(msg);
            Error.captureStackTrace(err, ServerError);
            setPrototypeOf(err, ServerError.prototype);
            Object.defineProperty(err, 'message', {
                enumerable: true,
                configurable: true,
                value: msg,
                writable: true
            });
            Object.defineProperty(err, 'name', {
                enumerable: false,
                configurable: true,
                value: className,
                writable: true
            });
            return err;
        }
        inherits(ServerError, HttpError);
        ServerError.prototype.status = code;
        ServerError.prototype.statusCode = code;
        ServerError.prototype.expose = false;
        return ServerError;
    }
    function populateConstructorExports(exports, codes, HttpError) {
        codes.forEach(function forEachCode(code) {
            var CodeError;
            var name = toIdentifier(statuses[code]);
            switch(codeClass(code)){
                case 400:
                    CodeError = createClientErrorConstructor(HttpError, name, code);
                    break;
                case 500:
                    CodeError = createServerErrorConstructor(HttpError, name, code);
                    break;
            }
            if (CodeError) {
                exports[code] = CodeError;
                exports[name] = CodeError;
            }
        });
        exports["I'mateapot"] = deprecate.function(exports.ImATeapot, '"I\'mateapot"; use "ImATeapot" instead');
    }
    function toIdentifier(str) {
        return str.split(' ').map(function(token) {
            return token.slice(0, 1).toUpperCase() + token.slice(1);
        }).join('').replace(/[^ _0-9a-z]/gi, '');
    }
}
,
"972397d2":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "cleanStack", ()=>cleanStack);
    module.o(exports, "buildErrorMessage", ()=>buildErrorMessage);
    module.o(exports, "logError", ()=>logError);
    var _f_color = farmRequire("f19542e0");
    var _f_share = farmRequire("bc6cc539");
    function cleanStack(stack) {
        return stack.split(/\n/g).filter((l)=>/^\s*at/.test(l)).join('\n');
    }
    function buildErrorMessage(err, args = [], includeStack = true) {
        if (err.plugin) args.push(`  Plugin: ${_f_color.colors.magenta(err.plugin)}`);
        const loc = err.loc ? `:${err.loc.line}:${err.loc.column}` : '';
        if (err.id) args.push(`  File: ${_f_color.colors.cyan(err.id)}${loc}`);
        if (err.frame) args.push(_f_color.colors.yellow(_f_share.pad(err.frame)));
        else if (err.source) args.push(_f_color.colors.yellow(err.source));
        if (includeStack && err.stack) args.push(_f_share.pad(cleanStack(err.stack)));
        return args.join('\n');
    }
    function logError(err, throwErrorFlag = true) {
        let errorMessages = [];
        try {
            errorMessages = JSON.parse(err.message);
        } catch (_) {
            throw new Error(err.message);
        }
        if (!Array.isArray(errorMessages) || errorMessages.length === 0) {
            if (throwErrorFlag) {
                throw new Error(err.message);
            }
            return err.message;
        }
        const formattedErrorMessages = errorMessages.map((errorMsg)=>{
            try {
                const parsedErrorMsg = JSON.parse(errorMsg);
                if (parsedErrorMsg && typeof parsedErrorMsg === 'object' && (parsedErrorMsg.message || parsedErrorMsg.reason)) {
                    return `${buildErrorMessage(parsedErrorMsg, [
                        _f_color.colors.red(`Internal server error: ${parsedErrorMsg.message || parsedErrorMsg.reason}`)
                    ])}`;
                } else {
                    return _f_color.colors.red(errorMsg);
                }
            } catch  {
                return _f_color.colors.red(errorMsg);
            }
        });
        const errorMessage = formattedErrorMessages.join('\n');
        if (throwErrorFlag) {
            throw new Error(errorMessage);
        }
        return errorMessage;
    }
}
,
"97f6a66c":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "DEFAULT_CONFIG_NAMES", ()=>DEFAULT_CONFIG_NAMES);
    module.o(exports, "FARM_DEFAULT_NAMESPACE", ()=>FARM_DEFAULT_NAMESPACE);
    module.o(exports, "CUSTOM_KEYS", ()=>CUSTOM_KEYS);
    var DEFAULT_CONFIG_NAMES = [
        'farm.config.ts',
        'farm.config.js',
        'farm.config.cjs',
        'farm.config.mjs',
        'farm.config.cts',
        'farm.config.mts'
    ];
    var FARM_DEFAULT_NAMESPACE = 'FARM_DEFAULT_NAMESPACE';
    var CUSTOM_KEYS = {
        external_record: 'external.record',
        runtime_isolate: 'runtime.isolate',
        resolve_dedupe: 'resolve.dedupe',
        css_locals_conversion: 'css.modules.locals_conversion',
        assets_mode: 'assets.mode',
        output_ascii_only: 'output.ascii_only'
    };
}
,
"9887cd18":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const { isUtf8 } = global.nodeRequire('buffer', true);
    const tokenChars = [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        1,
        1,
        1,
        1,
        1,
        0,
        0,
        1,
        1,
        0,
        1,
        1,
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        0,
        1,
        0,
        1,
        0
    ];
    function isValidStatusCode(code) {
        return code >= 1000 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3000 && code <= 4999;
    }
    function _isValidUTF8(buf) {
        const len = buf.length;
        let i = 0;
        while(i < len){
            if ((buf[i] & 0x80) === 0) {
                i++;
            } else if ((buf[i] & 0xe0) === 0xc0) {
                if (i + 1 === len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i] & 0xfe) === 0xc0) {
                    return false;
                }
                i += 2;
            } else if ((buf[i] & 0xf0) === 0xe0) {
                if (i + 2 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 || buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) {
                    return false;
                }
                i += 3;
            } else if ((buf[i] & 0xf8) === 0xf0) {
                if (i + 3 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || (buf[i + 3] & 0xc0) !== 0x80 || buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 || buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4) {
                    return false;
                }
                i += 4;
            } else {
                return false;
            }
        }
        return true;
    }
    module.exports = {
        isValidStatusCode,
        isValidUTF8: _isValidUTF8,
        tokenChars
    };
    if (isUtf8) {
        module.exports.isValidUTF8 = function(buf) {
            return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
        };
    } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
        try {
            const isValidUTF8 = farmRequire("3ee4e850", true);
            module.exports.isValidUTF8 = function(buf) {
                return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
            };
        } catch (e) {}
    }
}
,
"9996a2b2":function  (module, exports, farmRequire, farmDynamicRequire) {
    const isWindows = process.platform === 'win32' || process.env.OSTYPE === 'cygwin' || process.env.OSTYPE === 'msys';
    const path = global.nodeRequire('path', true);
    const COLON = isWindows ? ';' : ':';
    const isexe = farmRequire("14fd5962", true);
    const getNotFoundError = (cmd)=>Object.assign(new Error(`not found: ${cmd}`), {
            code: 'ENOENT'
        });
    const getPathInfo = (cmd, opt)=>{
        const colon = opt.colon || COLON;
        const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [
            ''
        ] : [
            ...isWindows ? [
                process.cwd()
            ] : [],
            ...(opt.path || process.env.PATH || '').split(colon)
        ];
        const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM' : '';
        const pathExt = isWindows ? pathExtExe.split(colon) : [
            ''
        ];
        if (isWindows) {
            if (cmd.indexOf('.') !== -1 && pathExt[0] !== '') pathExt.unshift('');
        }
        return {
            pathEnv,
            pathExt,
            pathExtExe
        };
    };
    const which = (cmd, opt, cb)=>{
        if (typeof opt === 'function') {
            cb = opt;
            opt = {};
        }
        if (!opt) opt = {};
        const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
        const found = [];
        const step = (i)=>new Promise((resolve, reject)=>{
                if (i === pathEnv.length) return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
                const ppRaw = pathEnv[i];
                const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
                const pCmd = path.join(pathPart, cmd);
                const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
                resolve(subStep(p, i, 0));
            });
        const subStep = (p, i, ii)=>new Promise((resolve, reject)=>{
                if (ii === pathExt.length) return resolve(step(i + 1));
                const ext = pathExt[ii];
                isexe(p + ext, {
                    pathExt: pathExtExe
                }, (er, is)=>{
                    if (!er && is) {
                        if (opt.all) found.push(p + ext);
                        else return resolve(p + ext);
                    }
                    return resolve(subStep(p, i, ii + 1));
                });
            });
        return cb ? step(0).then((res)=>cb(null, res), cb) : step(0);
    };
    const whichSync = (cmd, opt)=>{
        opt = opt || {};
        const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
        const found = [];
        for(let i = 0; i < pathEnv.length; i++){
            const ppRaw = pathEnv[i];
            const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
            const pCmd = path.join(pathPart, cmd);
            const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
            for(let j = 0; j < pathExt.length; j++){
                const cur = p + pathExt[j];
                try {
                    const is = isexe.sync(cur, {
                        pathExt: pathExtExe
                    });
                    if (is) {
                        if (opt.all) found.push(cur);
                        else return cur;
                    }
                } catch (ex) {}
            }
        }
        if (opt.all && found.length) return found;
        if (opt.nothrow) return null;
        throw getNotFoundError(cmd);
    };
    module.exports = which;
    which.sync = whichSync;
}
,
"9b4982dd":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const fs = farmRequire("3c1571d9", true);
    class Settings {
        constructor(_options = {}){
            this._options = _options;
            this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
            this.fs = fs.createFileSystemAdapter(this._options.fs);
            this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
            this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
        }
        _getValue(option, value) {
            return option !== null && option !== void 0 ? option : value;
        }
    }
    exports.default = Settings;
}
,
"9c9fbd11":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const fs = farmRequire("f2e2163e", true);
    const path = global.nodeRequire('path', true);
    const util = global.nodeRequire('util', true);
    function getStats(src, dest, opts) {
        const statFunc = opts.dereference ? (file)=>fs.stat(file, {
                bigint: true
            }) : (file)=>fs.lstat(file, {
                bigint: true
            });
        return Promise.all([
            statFunc(src),
            statFunc(dest).catch((err)=>{
                if (err.code === 'ENOENT') return null;
                throw err;
            })
        ]).then(([srcStat, destStat])=>({
                srcStat,
                destStat
            }));
    }
    function getStatsSync(src, dest, opts) {
        let destStat;
        const statFunc = opts.dereference ? (file)=>fs.statSync(file, {
                bigint: true
            }) : (file)=>fs.lstatSync(file, {
                bigint: true
            });
        const srcStat = statFunc(src);
        try {
            destStat = statFunc(dest);
        } catch (err) {
            if (err.code === 'ENOENT') return {
                srcStat,
                destStat: null
            };
            throw err;
        }
        return {
            srcStat,
            destStat
        };
    }
    function checkPaths(src, dest, funcName, opts, cb) {
        util.callbackify(getStats)(src, dest, opts, (err, stats)=>{
            if (err) return cb(err);
            const { srcStat, destStat } = stats;
            if (destStat) {
                if (areIdentical(srcStat, destStat)) {
                    const srcBaseName = path.basename(src);
                    const destBaseName = path.basename(dest);
                    if (funcName === 'move' && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
                        return cb(null, {
                            srcStat,
                            destStat,
                            isChangingCase: true
                        });
                    }
                    return cb(new Error('Source and destination must not be the same.'));
                }
                if (srcStat.isDirectory() && !destStat.isDirectory()) {
                    return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
                }
                if (!srcStat.isDirectory() && destStat.isDirectory()) {
                    return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`));
                }
            }
            if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
                return cb(new Error(errMsg(src, dest, funcName)));
            }
            return cb(null, {
                srcStat,
                destStat
            });
        });
    }
    function checkPathsSync(src, dest, funcName, opts) {
        const { srcStat, destStat } = getStatsSync(src, dest, opts);
        if (destStat) {
            if (areIdentical(srcStat, destStat)) {
                const srcBaseName = path.basename(src);
                const destBaseName = path.basename(dest);
                if (funcName === 'move' && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
                    return {
                        srcStat,
                        destStat,
                        isChangingCase: true
                    };
                }
                throw new Error('Source and destination must not be the same.');
            }
            if (srcStat.isDirectory() && !destStat.isDirectory()) {
                throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
            }
            if (!srcStat.isDirectory() && destStat.isDirectory()) {
                throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
            }
        }
        if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
            throw new Error(errMsg(src, dest, funcName));
        }
        return {
            srcStat,
            destStat
        };
    }
    function checkParentPaths(src, srcStat, dest, funcName, cb) {
        const srcParent = path.resolve(path.dirname(src));
        const destParent = path.resolve(path.dirname(dest));
        if (destParent === srcParent || destParent === path.parse(destParent).root) return cb();
        fs.stat(destParent, {
            bigint: true
        }, (err, destStat)=>{
            if (err) {
                if (err.code === 'ENOENT') return cb();
                return cb(err);
            }
            if (areIdentical(srcStat, destStat)) {
                return cb(new Error(errMsg(src, dest, funcName)));
            }
            return checkParentPaths(src, srcStat, destParent, funcName, cb);
        });
    }
    function checkParentPathsSync(src, srcStat, dest, funcName) {
        const srcParent = path.resolve(path.dirname(src));
        const destParent = path.resolve(path.dirname(dest));
        if (destParent === srcParent || destParent === path.parse(destParent).root) return;
        let destStat;
        try {
            destStat = fs.statSync(destParent, {
                bigint: true
            });
        } catch (err) {
            if (err.code === 'ENOENT') return;
            throw err;
        }
        if (areIdentical(srcStat, destStat)) {
            throw new Error(errMsg(src, dest, funcName));
        }
        return checkParentPathsSync(src, srcStat, destParent, funcName);
    }
    function areIdentical(srcStat, destStat) {
        return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
    }
    function isSrcSubdir(src, dest) {
        const srcArr = path.resolve(src).split(path.sep).filter((i)=>i);
        const destArr = path.resolve(dest).split(path.sep).filter((i)=>i);
        return srcArr.reduce((acc, cur, i)=>acc && destArr[i] === cur, true);
    }
    function errMsg(src, dest, funcName) {
        return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
    }
    module.exports = {
        checkPaths,
        checkPathsSync,
        checkParentPaths,
        checkParentPathsSync,
        isSrcSubdir,
        areIdentical
    };
}
,
"9dd588b5":function  (module, exports, farmRequire, farmDynamicRequire) {
    var bigInt = function(undefined) {
        "use strict";
        var BASE = 1e7, LOG_BASE = 7, MAX_INT = 9007199254740992, MAX_INT_ARR = smallToArray(MAX_INT), DEFAULT_ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";
        var supportsNativeBigInt = typeof BigInt === "function";
        function Integer(v, radix, alphabet, caseSensitive) {
            if (typeof v === "undefined") return Integer[0];
            if (typeof radix !== "undefined") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);
            return parseValue(v);
        }
        function BigInteger(value, sign) {
            this.value = value;
            this.sign = sign;
            this.isSmall = false;
        }
        BigInteger.prototype = Object.create(Integer.prototype);
        function SmallInteger(value) {
            this.value = value;
            this.sign = value < 0;
            this.isSmall = true;
        }
        SmallInteger.prototype = Object.create(Integer.prototype);
        function NativeBigInt(value) {
            this.value = value;
        }
        NativeBigInt.prototype = Object.create(Integer.prototype);
        function isPrecise(n) {
            return -MAX_INT < n && n < MAX_INT;
        }
        function smallToArray(n) {
            if (n < 1e7) return [
                n
            ];
            if (n < 1e14) return [
                n % 1e7,
                Math.floor(n / 1e7)
            ];
            return [
                n % 1e7,
                Math.floor(n / 1e7) % 1e7,
                Math.floor(n / 1e14)
            ];
        }
        function arrayToSmall(arr) {
            trim(arr);
            var length = arr.length;
            if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {
                switch(length){
                    case 0:
                        return 0;
                    case 1:
                        return arr[0];
                    case 2:
                        return arr[0] + arr[1] * BASE;
                    default:
                        return arr[0] + (arr[1] + arr[2] * BASE) * BASE;
                }
            }
            return arr;
        }
        function trim(v) {
            var i = v.length;
            while(v[--i] === 0);
            v.length = i + 1;
        }
        function createArray(length) {
            var x = new Array(length);
            var i = -1;
            while(++i < length){
                x[i] = 0;
            }
            return x;
        }
        function truncate(n) {
            if (n > 0) return Math.floor(n);
            return Math.ceil(n);
        }
        function add(a, b) {
            var l_a = a.length, l_b = b.length, r = new Array(l_a), carry = 0, base = BASE, sum, i;
            for(i = 0; i < l_b; i++){
                sum = a[i] + b[i] + carry;
                carry = sum >= base ? 1 : 0;
                r[i] = sum - carry * base;
            }
            while(i < l_a){
                sum = a[i] + carry;
                carry = sum === base ? 1 : 0;
                r[i++] = sum - carry * base;
            }
            if (carry > 0) r.push(carry);
            return r;
        }
        function addAny(a, b) {
            if (a.length >= b.length) return add(a, b);
            return add(b, a);
        }
        function addSmall(a, carry) {
            var l = a.length, r = new Array(l), base = BASE, sum, i;
            for(i = 0; i < l; i++){
                sum = a[i] - base + carry;
                carry = Math.floor(sum / base);
                r[i] = sum - carry * base;
                carry += 1;
            }
            while(carry > 0){
                r[i++] = carry % base;
                carry = Math.floor(carry / base);
            }
            return r;
        }
        BigInteger.prototype.add = function(v) {
            var n = parseValue(v);
            if (this.sign !== n.sign) {
                return this.subtract(n.negate());
            }
            var a = this.value, b = n.value;
            if (n.isSmall) {
                return new BigInteger(addSmall(a, Math.abs(b)), this.sign);
            }
            return new BigInteger(addAny(a, b), this.sign);
        };
        BigInteger.prototype.plus = BigInteger.prototype.add;
        SmallInteger.prototype.add = function(v) {
            var n = parseValue(v);
            var a = this.value;
            if (a < 0 !== n.sign) {
                return this.subtract(n.negate());
            }
            var b = n.value;
            if (n.isSmall) {
                if (isPrecise(a + b)) return new SmallInteger(a + b);
                b = smallToArray(Math.abs(b));
            }
            return new BigInteger(addSmall(b, Math.abs(a)), a < 0);
        };
        SmallInteger.prototype.plus = SmallInteger.prototype.add;
        NativeBigInt.prototype.add = function(v) {
            return new NativeBigInt(this.value + parseValue(v).value);
        };
        NativeBigInt.prototype.plus = NativeBigInt.prototype.add;
        function subtract(a, b) {
            var a_l = a.length, b_l = b.length, r = new Array(a_l), borrow = 0, base = BASE, i, difference;
            for(i = 0; i < b_l; i++){
                difference = a[i] - borrow - b[i];
                if (difference < 0) {
                    difference += base;
                    borrow = 1;
                } else borrow = 0;
                r[i] = difference;
            }
            for(i = b_l; i < a_l; i++){
                difference = a[i] - borrow;
                if (difference < 0) difference += base;
                else {
                    r[i++] = difference;
                    break;
                }
                r[i] = difference;
            }
            for(; i < a_l; i++){
                r[i] = a[i];
            }
            trim(r);
            return r;
        }
        function subtractAny(a, b, sign) {
            var value;
            if (compareAbs(a, b) >= 0) {
                value = subtract(a, b);
            } else {
                value = subtract(b, a);
                sign = !sign;
            }
            value = arrayToSmall(value);
            if (typeof value === "number") {
                if (sign) value = -value;
                return new SmallInteger(value);
            }
            return new BigInteger(value, sign);
        }
        function subtractSmall(a, b, sign) {
            var l = a.length, r = new Array(l), carry = -b, base = BASE, i, difference;
            for(i = 0; i < l; i++){
                difference = a[i] + carry;
                carry = Math.floor(difference / base);
                difference %= base;
                r[i] = difference < 0 ? difference + base : difference;
            }
            r = arrayToSmall(r);
            if (typeof r === "number") {
                if (sign) r = -r;
                return new SmallInteger(r);
            }
            return new BigInteger(r, sign);
        }
        BigInteger.prototype.subtract = function(v) {
            var n = parseValue(v);
            if (this.sign !== n.sign) {
                return this.add(n.negate());
            }
            var a = this.value, b = n.value;
            if (n.isSmall) return subtractSmall(a, Math.abs(b), this.sign);
            return subtractAny(a, b, this.sign);
        };
        BigInteger.prototype.minus = BigInteger.prototype.subtract;
        SmallInteger.prototype.subtract = function(v) {
            var n = parseValue(v);
            var a = this.value;
            if (a < 0 !== n.sign) {
                return this.add(n.negate());
            }
            var b = n.value;
            if (n.isSmall) {
                return new SmallInteger(a - b);
            }
            return subtractSmall(b, Math.abs(a), a >= 0);
        };
        SmallInteger.prototype.minus = SmallInteger.prototype.subtract;
        NativeBigInt.prototype.subtract = function(v) {
            return new NativeBigInt(this.value - parseValue(v).value);
        };
        NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;
        BigInteger.prototype.negate = function() {
            return new BigInteger(this.value, !this.sign);
        };
        SmallInteger.prototype.negate = function() {
            var sign = this.sign;
            var small = new SmallInteger(-this.value);
            small.sign = !sign;
            return small;
        };
        NativeBigInt.prototype.negate = function() {
            return new NativeBigInt(-this.value);
        };
        BigInteger.prototype.abs = function() {
            return new BigInteger(this.value, false);
        };
        SmallInteger.prototype.abs = function() {
            return new SmallInteger(Math.abs(this.value));
        };
        NativeBigInt.prototype.abs = function() {
            return new NativeBigInt(this.value >= 0 ? this.value : -this.value);
        };
        function multiplyLong(a, b) {
            var a_l = a.length, b_l = b.length, l = a_l + b_l, r = createArray(l), base = BASE, product, carry, i, a_i, b_j;
            for(i = 0; i < a_l; ++i){
                a_i = a[i];
                for(var j = 0; j < b_l; ++j){
                    b_j = b[j];
                    product = a_i * b_j + r[i + j];
                    carry = Math.floor(product / base);
                    r[i + j] = product - carry * base;
                    r[i + j + 1] += carry;
                }
            }
            trim(r);
            return r;
        }
        function multiplySmall(a, b) {
            var l = a.length, r = new Array(l), base = BASE, carry = 0, product, i;
            for(i = 0; i < l; i++){
                product = a[i] * b + carry;
                carry = Math.floor(product / base);
                r[i] = product - carry * base;
            }
            while(carry > 0){
                r[i++] = carry % base;
                carry = Math.floor(carry / base);
            }
            return r;
        }
        function shiftLeft(x, n) {
            var r = [];
            while(n-- > 0)r.push(0);
            return r.concat(x);
        }
        function multiplyKaratsuba(x, y) {
            var n = Math.max(x.length, y.length);
            if (n <= 30) return multiplyLong(x, y);
            n = Math.ceil(n / 2);
            var b = x.slice(n), a = x.slice(0, n), d = y.slice(n), c = y.slice(0, n);
            var ac = multiplyKaratsuba(a, c), bd = multiplyKaratsuba(b, d), abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));
            var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));
            trim(product);
            return product;
        }
        function useKaratsuba(l1, l2) {
            return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;
        }
        BigInteger.prototype.multiply = function(v) {
            var n = parseValue(v), a = this.value, b = n.value, sign = this.sign !== n.sign, abs;
            if (n.isSmall) {
                if (b === 0) return Integer[0];
                if (b === 1) return this;
                if (b === -1) return this.negate();
                abs = Math.abs(b);
                if (abs < BASE) {
                    return new BigInteger(multiplySmall(a, abs), sign);
                }
                b = smallToArray(abs);
            }
            if (useKaratsuba(a.length, b.length)) return new BigInteger(multiplyKaratsuba(a, b), sign);
            return new BigInteger(multiplyLong(a, b), sign);
        };
        BigInteger.prototype.times = BigInteger.prototype.multiply;
        function multiplySmallAndArray(a, b, sign) {
            if (a < BASE) {
                return new BigInteger(multiplySmall(b, a), sign);
            }
            return new BigInteger(multiplyLong(b, smallToArray(a)), sign);
        }
        SmallInteger.prototype._multiplyBySmall = function(a) {
            if (isPrecise(a.value * this.value)) {
                return new SmallInteger(a.value * this.value);
            }
            return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);
        };
        BigInteger.prototype._multiplyBySmall = function(a) {
            if (a.value === 0) return Integer[0];
            if (a.value === 1) return this;
            if (a.value === -1) return this.negate();
            return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);
        };
        SmallInteger.prototype.multiply = function(v) {
            return parseValue(v)._multiplyBySmall(this);
        };
        SmallInteger.prototype.times = SmallInteger.prototype.multiply;
        NativeBigInt.prototype.multiply = function(v) {
            return new NativeBigInt(this.value * parseValue(v).value);
        };
        NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;
        function square(a) {
            var l = a.length, r = createArray(l + l), base = BASE, product, carry, i, a_i, a_j;
            for(i = 0; i < l; i++){
                a_i = a[i];
                carry = 0 - a_i * a_i;
                for(var j = i; j < l; j++){
                    a_j = a[j];
                    product = 2 * (a_i * a_j) + r[i + j] + carry;
                    carry = Math.floor(product / base);
                    r[i + j] = product - carry * base;
                }
                r[i + l] = carry;
            }
            trim(r);
            return r;
        }
        BigInteger.prototype.square = function() {
            return new BigInteger(square(this.value), false);
        };
        SmallInteger.prototype.square = function() {
            var value = this.value * this.value;
            if (isPrecise(value)) return new SmallInteger(value);
            return new BigInteger(square(smallToArray(Math.abs(this.value))), false);
        };
        NativeBigInt.prototype.square = function(v) {
            return new NativeBigInt(this.value * this.value);
        };
        function divMod1(a, b) {
            var a_l = a.length, b_l = b.length, base = BASE, result = createArray(b.length), divisorMostSignificantDigit = b[b_l - 1], lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)), remainder = multiplySmall(a, lambda), divisor = multiplySmall(b, lambda), quotientDigit, shift, carry, borrow, i, l, q;
            if (remainder.length <= a_l) remainder.push(0);
            divisor.push(0);
            divisorMostSignificantDigit = divisor[b_l - 1];
            for(shift = a_l - b_l; shift >= 0; shift--){
                quotientDigit = base - 1;
                if (remainder[shift + b_l] !== divisorMostSignificantDigit) {
                    quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);
                }
                carry = 0;
                borrow = 0;
                l = divisor.length;
                for(i = 0; i < l; i++){
                    carry += quotientDigit * divisor[i];
                    q = Math.floor(carry / base);
                    borrow += remainder[shift + i] - (carry - q * base);
                    carry = q;
                    if (borrow < 0) {
                        remainder[shift + i] = borrow + base;
                        borrow = -1;
                    } else {
                        remainder[shift + i] = borrow;
                        borrow = 0;
                    }
                }
                while(borrow !== 0){
                    quotientDigit -= 1;
                    carry = 0;
                    for(i = 0; i < l; i++){
                        carry += remainder[shift + i] - base + divisor[i];
                        if (carry < 0) {
                            remainder[shift + i] = carry + base;
                            carry = 0;
                        } else {
                            remainder[shift + i] = carry;
                            carry = 1;
                        }
                    }
                    borrow += carry;
                }
                result[shift] = quotientDigit;
            }
            remainder = divModSmall(remainder, lambda)[0];
            return [
                arrayToSmall(result),
                arrayToSmall(remainder)
            ];
        }
        function divMod2(a, b) {
            var a_l = a.length, b_l = b.length, result = [], part = [], base = BASE, guess, xlen, highx, highy, check;
            while(a_l){
                part.unshift(a[--a_l]);
                trim(part);
                if (compareAbs(part, b) < 0) {
                    result.push(0);
                    continue;
                }
                xlen = part.length;
                highx = part[xlen - 1] * base + part[xlen - 2];
                highy = b[b_l - 1] * base + b[b_l - 2];
                if (xlen > b_l) {
                    highx = (highx + 1) * base;
                }
                guess = Math.ceil(highx / highy);
                do {
                    check = multiplySmall(b, guess);
                    if (compareAbs(check, part) <= 0) break;
                    guess--;
                }while (guess)
                result.push(guess);
                part = subtract(part, check);
            }
            result.reverse();
            return [
                arrayToSmall(result),
                arrayToSmall(part)
            ];
        }
        function divModSmall(value, lambda) {
            var length = value.length, quotient = createArray(length), base = BASE, i, q, remainder, divisor;
            remainder = 0;
            for(i = length - 1; i >= 0; --i){
                divisor = remainder * base + value[i];
                q = truncate(divisor / lambda);
                remainder = divisor - q * lambda;
                quotient[i] = q | 0;
            }
            return [
                quotient,
                remainder | 0
            ];
        }
        function divModAny(self, v) {
            var value, n = parseValue(v);
            if (supportsNativeBigInt) {
                return [
                    new NativeBigInt(self.value / n.value),
                    new NativeBigInt(self.value % n.value)
                ];
            }
            var a = self.value, b = n.value;
            var quotient;
            if (b === 0) throw new Error("Cannot divide by zero");
            if (self.isSmall) {
                if (n.isSmall) {
                    return [
                        new SmallInteger(truncate(a / b)),
                        new SmallInteger(a % b)
                    ];
                }
                return [
                    Integer[0],
                    self
                ];
            }
            if (n.isSmall) {
                if (b === 1) return [
                    self,
                    Integer[0]
                ];
                if (b == -1) return [
                    self.negate(),
                    Integer[0]
                ];
                var abs = Math.abs(b);
                if (abs < BASE) {
                    value = divModSmall(a, abs);
                    quotient = arrayToSmall(value[0]);
                    var remainder = value[1];
                    if (self.sign) remainder = -remainder;
                    if (typeof quotient === "number") {
                        if (self.sign !== n.sign) quotient = -quotient;
                        return [
                            new SmallInteger(quotient),
                            new SmallInteger(remainder)
                        ];
                    }
                    return [
                        new BigInteger(quotient, self.sign !== n.sign),
                        new SmallInteger(remainder)
                    ];
                }
                b = smallToArray(abs);
            }
            var comparison = compareAbs(a, b);
            if (comparison === -1) return [
                Integer[0],
                self
            ];
            if (comparison === 0) return [
                Integer[self.sign === n.sign ? 1 : -1],
                Integer[0]
            ];
            if (a.length + b.length <= 200) value = divMod1(a, b);
            else value = divMod2(a, b);
            quotient = value[0];
            var qSign = self.sign !== n.sign, mod = value[1], mSign = self.sign;
            if (typeof quotient === "number") {
                if (qSign) quotient = -quotient;
                quotient = new SmallInteger(quotient);
            } else quotient = new BigInteger(quotient, qSign);
            if (typeof mod === "number") {
                if (mSign) mod = -mod;
                mod = new SmallInteger(mod);
            } else mod = new BigInteger(mod, mSign);
            return [
                quotient,
                mod
            ];
        }
        BigInteger.prototype.divmod = function(v) {
            var result = divModAny(this, v);
            return {
                quotient: result[0],
                remainder: result[1]
            };
        };
        NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;
        BigInteger.prototype.divide = function(v) {
            return divModAny(this, v)[0];
        };
        NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function(v) {
            return new NativeBigInt(this.value / parseValue(v).value);
        };
        SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;
        BigInteger.prototype.mod = function(v) {
            return divModAny(this, v)[1];
        };
        NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function(v) {
            return new NativeBigInt(this.value % parseValue(v).value);
        };
        SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;
        BigInteger.prototype.pow = function(v) {
            var n = parseValue(v), a = this.value, b = n.value, value, x, y;
            if (b === 0) return Integer[1];
            if (a === 0) return Integer[0];
            if (a === 1) return Integer[1];
            if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];
            if (n.sign) {
                return Integer[0];
            }
            if (!n.isSmall) throw new Error("The exponent " + n.toString() + " is too large.");
            if (this.isSmall) {
                if (isPrecise(value = Math.pow(a, b))) return new SmallInteger(truncate(value));
            }
            x = this;
            y = Integer[1];
            while(true){
                if (b & 1 === 1) {
                    y = y.times(x);
                    --b;
                }
                if (b === 0) break;
                b /= 2;
                x = x.square();
            }
            return y;
        };
        SmallInteger.prototype.pow = BigInteger.prototype.pow;
        NativeBigInt.prototype.pow = function(v) {
            var n = parseValue(v);
            var a = this.value, b = n.value;
            var _0 = BigInt(0), _1 = BigInt(1), _2 = BigInt(2);
            if (b === _0) return Integer[1];
            if (a === _0) return Integer[0];
            if (a === _1) return Integer[1];
            if (a === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];
            if (n.isNegative()) return new NativeBigInt(_0);
            var x = this;
            var y = Integer[1];
            while(true){
                if ((b & _1) === _1) {
                    y = y.times(x);
                    --b;
                }
                if (b === _0) break;
                b /= _2;
                x = x.square();
            }
            return y;
        };
        BigInteger.prototype.modPow = function(exp, mod) {
            exp = parseValue(exp);
            mod = parseValue(mod);
            if (mod.isZero()) throw new Error("Cannot take modPow with modulus 0");
            var r = Integer[1], base = this.mod(mod);
            if (exp.isNegative()) {
                exp = exp.multiply(Integer[-1]);
                base = base.modInv(mod);
            }
            while(exp.isPositive()){
                if (base.isZero()) return Integer[0];
                if (exp.isOdd()) r = r.multiply(base).mod(mod);
                exp = exp.divide(2);
                base = base.square().mod(mod);
            }
            return r;
        };
        NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;
        function compareAbs(a, b) {
            if (a.length !== b.length) {
                return a.length > b.length ? 1 : -1;
            }
            for(var i = a.length - 1; i >= 0; i--){
                if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;
            }
            return 0;
        }
        BigInteger.prototype.compareAbs = function(v) {
            var n = parseValue(v), a = this.value, b = n.value;
            if (n.isSmall) return 1;
            return compareAbs(a, b);
        };
        SmallInteger.prototype.compareAbs = function(v) {
            var n = parseValue(v), a = Math.abs(this.value), b = n.value;
            if (n.isSmall) {
                b = Math.abs(b);
                return a === b ? 0 : a > b ? 1 : -1;
            }
            return -1;
        };
        NativeBigInt.prototype.compareAbs = function(v) {
            var a = this.value;
            var b = parseValue(v).value;
            a = a >= 0 ? a : -a;
            b = b >= 0 ? b : -b;
            return a === b ? 0 : a > b ? 1 : -1;
        };
        BigInteger.prototype.compare = function(v) {
            if (v === Infinity) {
                return -1;
            }
            if (v === -Infinity) {
                return 1;
            }
            var n = parseValue(v), a = this.value, b = n.value;
            if (this.sign !== n.sign) {
                return n.sign ? 1 : -1;
            }
            if (n.isSmall) {
                return this.sign ? -1 : 1;
            }
            return compareAbs(a, b) * (this.sign ? -1 : 1);
        };
        BigInteger.prototype.compareTo = BigInteger.prototype.compare;
        SmallInteger.prototype.compare = function(v) {
            if (v === Infinity) {
                return -1;
            }
            if (v === -Infinity) {
                return 1;
            }
            var n = parseValue(v), a = this.value, b = n.value;
            if (n.isSmall) {
                return a == b ? 0 : a > b ? 1 : -1;
            }
            if (a < 0 !== n.sign) {
                return a < 0 ? -1 : 1;
            }
            return a < 0 ? 1 : -1;
        };
        SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;
        NativeBigInt.prototype.compare = function(v) {
            if (v === Infinity) {
                return -1;
            }
            if (v === -Infinity) {
                return 1;
            }
            var a = this.value;
            var b = parseValue(v).value;
            return a === b ? 0 : a > b ? 1 : -1;
        };
        NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;
        BigInteger.prototype.equals = function(v) {
            return this.compare(v) === 0;
        };
        NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;
        BigInteger.prototype.notEquals = function(v) {
            return this.compare(v) !== 0;
        };
        NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;
        BigInteger.prototype.greater = function(v) {
            return this.compare(v) > 0;
        };
        NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;
        BigInteger.prototype.lesser = function(v) {
            return this.compare(v) < 0;
        };
        NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;
        BigInteger.prototype.greaterOrEquals = function(v) {
            return this.compare(v) >= 0;
        };
        NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;
        BigInteger.prototype.lesserOrEquals = function(v) {
            return this.compare(v) <= 0;
        };
        NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;
        BigInteger.prototype.isEven = function() {
            return (this.value[0] & 1) === 0;
        };
        SmallInteger.prototype.isEven = function() {
            return (this.value & 1) === 0;
        };
        NativeBigInt.prototype.isEven = function() {
            return (this.value & BigInt(1)) === BigInt(0);
        };
        BigInteger.prototype.isOdd = function() {
            return (this.value[0] & 1) === 1;
        };
        SmallInteger.prototype.isOdd = function() {
            return (this.value & 1) === 1;
        };
        NativeBigInt.prototype.isOdd = function() {
            return (this.value & BigInt(1)) === BigInt(1);
        };
        BigInteger.prototype.isPositive = function() {
            return !this.sign;
        };
        SmallInteger.prototype.isPositive = function() {
            return this.value > 0;
        };
        NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;
        BigInteger.prototype.isNegative = function() {
            return this.sign;
        };
        SmallInteger.prototype.isNegative = function() {
            return this.value < 0;
        };
        NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;
        BigInteger.prototype.isUnit = function() {
            return false;
        };
        SmallInteger.prototype.isUnit = function() {
            return Math.abs(this.value) === 1;
        };
        NativeBigInt.prototype.isUnit = function() {
            return this.abs().value === BigInt(1);
        };
        BigInteger.prototype.isZero = function() {
            return false;
        };
        SmallInteger.prototype.isZero = function() {
            return this.value === 0;
        };
        NativeBigInt.prototype.isZero = function() {
            return this.value === BigInt(0);
        };
        BigInteger.prototype.isDivisibleBy = function(v) {
            var n = parseValue(v);
            if (n.isZero()) return false;
            if (n.isUnit()) return true;
            if (n.compareAbs(2) === 0) return this.isEven();
            return this.mod(n).isZero();
        };
        NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;
        function isBasicPrime(v) {
            var n = v.abs();
            if (n.isUnit()) return false;
            if (n.equals(2) || n.equals(3) || n.equals(5)) return true;
            if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;
            if (n.lesser(49)) return true;
        }
        function millerRabinTest(n, a) {
            var nPrev = n.prev(), b = nPrev, r = 0, d, t, i, x;
            while(b.isEven())b = b.divide(2), r++;
            next: for(i = 0; i < a.length; i++){
                if (n.lesser(a[i])) continue;
                x = bigInt(a[i]).modPow(b, n);
                if (x.isUnit() || x.equals(nPrev)) continue;
                for(d = r - 1; d != 0; d--){
                    x = x.square().mod(n);
                    if (x.isUnit()) return false;
                    if (x.equals(nPrev)) continue next;
                }
                return false;
            }
            return true;
        }
        BigInteger.prototype.isPrime = function(strict) {
            var isPrime = isBasicPrime(this);
            if (isPrime !== undefined) return isPrime;
            var n = this.abs();
            var bits = n.bitLength();
            if (bits <= 64) return millerRabinTest(n, [
                2,
                3,
                5,
                7,
                11,
                13,
                17,
                19,
                23,
                29,
                31,
                37
            ]);
            var logN = Math.log(2) * bits.toJSNumber();
            var t = Math.ceil(strict === true ? 2 * Math.pow(logN, 2) : logN);
            for(var a = [], i = 0; i < t; i++){
                a.push(bigInt(i + 2));
            }
            return millerRabinTest(n, a);
        };
        NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;
        BigInteger.prototype.isProbablePrime = function(iterations, rng) {
            var isPrime = isBasicPrime(this);
            if (isPrime !== undefined) return isPrime;
            var n = this.abs();
            var t = iterations === undefined ? 5 : iterations;
            for(var a = [], i = 0; i < t; i++){
                a.push(bigInt.randBetween(2, n.minus(2), rng));
            }
            return millerRabinTest(n, a);
        };
        NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;
        BigInteger.prototype.modInv = function(n) {
            var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;
            while(!newR.isZero()){
                q = r.divide(newR);
                lastT = t;
                lastR = r;
                t = newT;
                r = newR;
                newT = lastT.subtract(q.multiply(newT));
                newR = lastR.subtract(q.multiply(newR));
            }
            if (!r.isUnit()) throw new Error(this.toString() + " and " + n.toString() + " are not co-prime");
            if (t.compare(0) === -1) {
                t = t.add(n);
            }
            if (this.isNegative()) {
                return t.negate();
            }
            return t;
        };
        NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;
        BigInteger.prototype.next = function() {
            var value = this.value;
            if (this.sign) {
                return subtractSmall(value, 1, this.sign);
            }
            return new BigInteger(addSmall(value, 1), this.sign);
        };
        SmallInteger.prototype.next = function() {
            var value = this.value;
            if (value + 1 < MAX_INT) return new SmallInteger(value + 1);
            return new BigInteger(MAX_INT_ARR, false);
        };
        NativeBigInt.prototype.next = function() {
            return new NativeBigInt(this.value + BigInt(1));
        };
        BigInteger.prototype.prev = function() {
            var value = this.value;
            if (this.sign) {
                return new BigInteger(addSmall(value, 1), true);
            }
            return subtractSmall(value, 1, this.sign);
        };
        SmallInteger.prototype.prev = function() {
            var value = this.value;
            if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);
            return new BigInteger(MAX_INT_ARR, true);
        };
        NativeBigInt.prototype.prev = function() {
            return new NativeBigInt(this.value - BigInt(1));
        };
        var powersOfTwo = [
            1
        ];
        while(2 * powersOfTwo[powersOfTwo.length - 1] <= BASE)powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
        var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];
        function shift_isSmall(n) {
            return Math.abs(n) <= BASE;
        }
        BigInteger.prototype.shiftLeft = function(v) {
            var n = parseValue(v).toJSNumber();
            if (!shift_isSmall(n)) {
                throw new Error(String(n) + " is too large for shifting.");
            }
            if (n < 0) return this.shiftRight(-n);
            var result = this;
            if (result.isZero()) return result;
            while(n >= powers2Length){
                result = result.multiply(highestPower2);
                n -= powers2Length - 1;
            }
            return result.multiply(powersOfTwo[n]);
        };
        NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;
        BigInteger.prototype.shiftRight = function(v) {
            var remQuo;
            var n = parseValue(v).toJSNumber();
            if (!shift_isSmall(n)) {
                throw new Error(String(n) + " is too large for shifting.");
            }
            if (n < 0) return this.shiftLeft(-n);
            var result = this;
            while(n >= powers2Length){
                if (result.isZero() || result.isNegative() && result.isUnit()) return result;
                remQuo = divModAny(result, highestPower2);
                result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
                n -= powers2Length - 1;
            }
            remQuo = divModAny(result, powersOfTwo[n]);
            return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
        };
        NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;
        function bitwise(x, y, fn) {
            y = parseValue(y);
            var xSign = x.isNegative(), ySign = y.isNegative();
            var xRem = xSign ? x.not() : x, yRem = ySign ? y.not() : y;
            var xDigit = 0, yDigit = 0;
            var xDivMod = null, yDivMod = null;
            var result = [];
            while(!xRem.isZero() || !yRem.isZero()){
                xDivMod = divModAny(xRem, highestPower2);
                xDigit = xDivMod[1].toJSNumber();
                if (xSign) {
                    xDigit = highestPower2 - 1 - xDigit;
                }
                yDivMod = divModAny(yRem, highestPower2);
                yDigit = yDivMod[1].toJSNumber();
                if (ySign) {
                    yDigit = highestPower2 - 1 - yDigit;
                }
                xRem = xDivMod[0];
                yRem = yDivMod[0];
                result.push(fn(xDigit, yDigit));
            }
            var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);
            for(var i = result.length - 1; i >= 0; i -= 1){
                sum = sum.multiply(highestPower2).add(bigInt(result[i]));
            }
            return sum;
        }
        BigInteger.prototype.not = function() {
            return this.negate().prev();
        };
        NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;
        BigInteger.prototype.and = function(n) {
            return bitwise(this, n, function(a, b) {
                return a & b;
            });
        };
        NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;
        BigInteger.prototype.or = function(n) {
            return bitwise(this, n, function(a, b) {
                return a | b;
            });
        };
        NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;
        BigInteger.prototype.xor = function(n) {
            return bitwise(this, n, function(a, b) {
                return a ^ b;
            });
        };
        NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;
        var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;
        function roughLOB(n) {
            var v = n.value, x = typeof v === "number" ? v | LOBMASK_I : typeof v === "bigint" ? v | BigInt(LOBMASK_I) : v[0] + v[1] * BASE | LOBMASK_BI;
            return x & -x;
        }
        function integerLogarithm(value, base) {
            if (base.compareTo(value) <= 0) {
                var tmp = integerLogarithm(value, base.square(base));
                var p = tmp.p;
                var e = tmp.e;
                var t = p.multiply(base);
                return t.compareTo(value) <= 0 ? {
                    p: t,
                    e: e * 2 + 1
                } : {
                    p: p,
                    e: e * 2
                };
            }
            return {
                p: bigInt(1),
                e: 0
            };
        }
        BigInteger.prototype.bitLength = function() {
            var n = this;
            if (n.compareTo(bigInt(0)) < 0) {
                n = n.negate().subtract(bigInt(1));
            }
            if (n.compareTo(bigInt(0)) === 0) {
                return bigInt(0);
            }
            return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));
        };
        NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;
        function max(a, b) {
            a = parseValue(a);
            b = parseValue(b);
            return a.greater(b) ? a : b;
        }
        function min(a, b) {
            a = parseValue(a);
            b = parseValue(b);
            return a.lesser(b) ? a : b;
        }
        function gcd(a, b) {
            a = parseValue(a).abs();
            b = parseValue(b).abs();
            if (a.equals(b)) return a;
            if (a.isZero()) return b;
            if (b.isZero()) return a;
            var c = Integer[1], d, t;
            while(a.isEven() && b.isEven()){
                d = min(roughLOB(a), roughLOB(b));
                a = a.divide(d);
                b = b.divide(d);
                c = c.multiply(d);
            }
            while(a.isEven()){
                a = a.divide(roughLOB(a));
            }
            do {
                while(b.isEven()){
                    b = b.divide(roughLOB(b));
                }
                if (a.greater(b)) {
                    t = b;
                    b = a;
                    a = t;
                }
                b = b.subtract(a);
            }while (!b.isZero())
            return c.isUnit() ? a : a.multiply(c);
        }
        function lcm(a, b) {
            a = parseValue(a).abs();
            b = parseValue(b).abs();
            return a.divide(gcd(a, b)).multiply(b);
        }
        function randBetween(a, b, rng) {
            a = parseValue(a);
            b = parseValue(b);
            var usedRNG = rng || Math.random;
            var low = min(a, b), high = max(a, b);
            var range = high.subtract(low).add(1);
            if (range.isSmall) return low.add(Math.floor(usedRNG() * range));
            var digits = toBase(range, BASE).value;
            var result = [], restricted = true;
            for(var i = 0; i < digits.length; i++){
                var top = restricted ? digits[i] + (i + 1 < digits.length ? digits[i + 1] / BASE : 0) : BASE;
                var digit = truncate(usedRNG() * top);
                result.push(digit);
                if (digit < digits[i]) restricted = false;
            }
            return low.add(Integer.fromArray(result, BASE, false));
        }
        var parseBase = function(text, base, alphabet, caseSensitive) {
            alphabet = alphabet || DEFAULT_ALPHABET;
            text = String(text);
            if (!caseSensitive) {
                text = text.toLowerCase();
                alphabet = alphabet.toLowerCase();
            }
            var length = text.length;
            var i;
            var absBase = Math.abs(base);
            var alphabetValues = {};
            for(i = 0; i < alphabet.length; i++){
                alphabetValues[alphabet[i]] = i;
            }
            for(i = 0; i < length; i++){
                var c = text[i];
                if (c === "-") continue;
                if (c in alphabetValues) {
                    if (alphabetValues[c] >= absBase) {
                        if (c === "1" && absBase === 1) continue;
                        throw new Error(c + " is not a valid digit in base " + base + ".");
                    }
                }
            }
            base = parseValue(base);
            var digits = [];
            var isNegative = text[0] === "-";
            for(i = isNegative ? 1 : 0; i < text.length; i++){
                var c = text[i];
                if (c in alphabetValues) digits.push(parseValue(alphabetValues[c]));
                else if (c === "<") {
                    var start = i;
                    do {
                        i++;
                    }while (text[i] !== ">" && i < text.length)
                    digits.push(parseValue(text.slice(start + 1, i)));
                } else throw new Error(c + " is not a valid character");
            }
            return parseBaseFromArray(digits, base, isNegative);
        };
        function parseBaseFromArray(digits, base, isNegative) {
            var val = Integer[0], pow = Integer[1], i;
            for(i = digits.length - 1; i >= 0; i--){
                val = val.add(digits[i].times(pow));
                pow = pow.times(base);
            }
            return isNegative ? val.negate() : val;
        }
        function stringify(digit, alphabet) {
            alphabet = alphabet || DEFAULT_ALPHABET;
            if (digit < alphabet.length) {
                return alphabet[digit];
            }
            return "<" + digit + ">";
        }
        function toBase(n, base) {
            base = bigInt(base);
            if (base.isZero()) {
                if (n.isZero()) return {
                    value: [
                        0
                    ],
                    isNegative: false
                };
                throw new Error("Cannot convert nonzero numbers to base 0.");
            }
            if (base.equals(-1)) {
                if (n.isZero()) return {
                    value: [
                        0
                    ],
                    isNegative: false
                };
                if (n.isNegative()) return {
                    value: [].concat.apply([], Array.apply(null, Array(-n.toJSNumber())).map(Array.prototype.valueOf, [
                        1,
                        0
                    ])),
                    isNegative: false
                };
                var arr = Array.apply(null, Array(n.toJSNumber() - 1)).map(Array.prototype.valueOf, [
                    0,
                    1
                ]);
                arr.unshift([
                    1
                ]);
                return {
                    value: [].concat.apply([], arr),
                    isNegative: false
                };
            }
            var neg = false;
            if (n.isNegative() && base.isPositive()) {
                neg = true;
                n = n.abs();
            }
            if (base.isUnit()) {
                if (n.isZero()) return {
                    value: [
                        0
                    ],
                    isNegative: false
                };
                return {
                    value: Array.apply(null, Array(n.toJSNumber())).map(Number.prototype.valueOf, 1),
                    isNegative: neg
                };
            }
            var out = [];
            var left = n, divmod;
            while(left.isNegative() || left.compareAbs(base) >= 0){
                divmod = left.divmod(base);
                left = divmod.quotient;
                var digit = divmod.remainder;
                if (digit.isNegative()) {
                    digit = base.minus(digit).abs();
                    left = left.next();
                }
                out.push(digit.toJSNumber());
            }
            out.push(left.toJSNumber());
            return {
                value: out.reverse(),
                isNegative: neg
            };
        }
        function toBaseString(n, base, alphabet) {
            var arr = toBase(n, base);
            return (arr.isNegative ? "-" : "") + arr.value.map(function(x) {
                return stringify(x, alphabet);
            }).join('');
        }
        BigInteger.prototype.toArray = function(radix) {
            return toBase(this, radix);
        };
        SmallInteger.prototype.toArray = function(radix) {
            return toBase(this, radix);
        };
        NativeBigInt.prototype.toArray = function(radix) {
            return toBase(this, radix);
        };
        BigInteger.prototype.toString = function(radix, alphabet) {
            if (radix === undefined) radix = 10;
            if (radix !== 10) return toBaseString(this, radix, alphabet);
            var v = this.value, l = v.length, str = String(v[--l]), zeros = "0000000", digit;
            while(--l >= 0){
                digit = String(v[l]);
                str += zeros.slice(digit.length) + digit;
            }
            var sign = this.sign ? "-" : "";
            return sign + str;
        };
        SmallInteger.prototype.toString = function(radix, alphabet) {
            if (radix === undefined) radix = 10;
            if (radix != 10) return toBaseString(this, radix, alphabet);
            return String(this.value);
        };
        NativeBigInt.prototype.toString = SmallInteger.prototype.toString;
        NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function() {
            return this.toString();
        };
        BigInteger.prototype.valueOf = function() {
            return parseInt(this.toString(), 10);
        };
        BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;
        SmallInteger.prototype.valueOf = function() {
            return this.value;
        };
        SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;
        NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function() {
            return parseInt(this.toString(), 10);
        };
        function parseStringValue(v) {
            if (isPrecise(+v)) {
                var x = +v;
                if (x === truncate(x)) return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);
                throw new Error("Invalid integer: " + v);
            }
            var sign = v[0] === "-";
            if (sign) v = v.slice(1);
            var split = v.split(/e/i);
            if (split.length > 2) throw new Error("Invalid integer: " + split.join("e"));
            if (split.length === 2) {
                var exp = split[1];
                if (exp[0] === "+") exp = exp.slice(1);
                exp = +exp;
                if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error("Invalid integer: " + exp + " is not a valid exponent.");
                var text = split[0];
                var decimalPlace = text.indexOf(".");
                if (decimalPlace >= 0) {
                    exp -= text.length - decimalPlace - 1;
                    text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);
                }
                if (exp < 0) throw new Error("Cannot include negative exponent part for integers");
                text += new Array(exp + 1).join("0");
                v = text;
            }
            var isValid = /^([0-9][0-9]*)$/.test(v);
            if (!isValid) throw new Error("Invalid integer: " + v);
            if (supportsNativeBigInt) {
                return new NativeBigInt(BigInt(sign ? "-" + v : v));
            }
            var r = [], max = v.length, l = LOG_BASE, min = max - l;
            while(max > 0){
                r.push(+v.slice(min, max));
                min -= l;
                if (min < 0) min = 0;
                max -= l;
            }
            trim(r);
            return new BigInteger(r, sign);
        }
        function parseNumberValue(v) {
            if (supportsNativeBigInt) {
                return new NativeBigInt(BigInt(v));
            }
            if (isPrecise(v)) {
                if (v !== truncate(v)) throw new Error(v + " is not an integer.");
                return new SmallInteger(v);
            }
            return parseStringValue(v.toString());
        }
        function parseValue(v) {
            if (typeof v === "number") {
                return parseNumberValue(v);
            }
            if (typeof v === "string") {
                return parseStringValue(v);
            }
            if (typeof v === "bigint") {
                return new NativeBigInt(v);
            }
            return v;
        }
        for(var i = 0; i < 1000; i++){
            Integer[i] = parseValue(i);
            if (i > 0) Integer[-i] = parseValue(-i);
        }
        Integer.one = Integer[1];
        Integer.zero = Integer[0];
        Integer.minusOne = Integer[-1];
        Integer.max = max;
        Integer.min = min;
        Integer.gcd = gcd;
        Integer.lcm = lcm;
        Integer.isInstance = function(x) {
            return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt;
        };
        Integer.randBetween = randBetween;
        Integer.fromArray = function(digits, base, isNegative) {
            return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);
        };
        return Integer;
    }();
    if (typeof module !== "undefined" && module.hasOwnProperty("exports")) {
        module.exports = bigInt;
    }
    if (typeof define === "function" && define.amd) {
        define(function() {
            return bigInt;
        });
    }
}
,
"9de2e012":/*!
 * destroy
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    var EventEmitter = global.nodeRequire('events', true).EventEmitter;
    var ReadStream = global.nodeRequire('fs', true).ReadStream;
    var Stream = global.nodeRequire('stream', true);
    var Zlib = global.nodeRequire('zlib', true);
    module.exports = destroy;
    function destroy(stream, suppress) {
        if (isFsReadStream(stream)) {
            destroyReadStream(stream);
        } else if (isZlibStream(stream)) {
            destroyZlibStream(stream);
        } else if (hasDestroy(stream)) {
            stream.destroy();
        }
        if (isEventEmitter(stream) && suppress) {
            stream.removeAllListeners('error');
            stream.addListener('error', noop);
        }
        return stream;
    }
    function destroyReadStream(stream) {
        stream.destroy();
        if (typeof stream.close === 'function') {
            stream.on('open', onOpenClose);
        }
    }
    function closeZlibStream(stream) {
        if (stream._hadError === true) {
            var prop = stream._binding === null ? '_binding' : '_handle';
            stream[prop] = {
                close: function() {
                    this[prop] = null;
                }
            };
        }
        stream.close();
    }
    function destroyZlibStream(stream) {
        if (typeof stream.destroy === 'function') {
            if (stream._binding) {
                stream.destroy();
                if (stream._processing) {
                    stream._needDrain = true;
                    stream.once('drain', onDrainClearBinding);
                } else {
                    stream._binding.clear();
                }
            } else if (stream._destroy && stream._destroy !== Stream.Transform.prototype._destroy) {
                stream.destroy();
            } else if (stream._destroy && typeof stream.close === 'function') {
                stream.destroyed = true;
                stream.close();
            } else {
                stream.destroy();
            }
        } else if (typeof stream.close === 'function') {
            closeZlibStream(stream);
        }
    }
    function hasDestroy(stream) {
        return stream instanceof Stream && typeof stream.destroy === 'function';
    }
    function isEventEmitter(val) {
        return val instanceof EventEmitter;
    }
    function isFsReadStream(stream) {
        return stream instanceof ReadStream;
    }
    function isZlibStream(stream) {
        return stream instanceof Zlib.Gzip || stream instanceof Zlib.Gunzip || stream instanceof Zlib.Deflate || stream instanceof Zlib.DeflateRaw || stream instanceof Zlib.Inflate || stream instanceof Zlib.InflateRaw || stream instanceof Zlib.Unzip;
    }
    function noop() {}
    function onDrainClearBinding() {
        this._binding.clear();
    }
    function onOpenClose() {
        if (typeof this.fd === 'number') {
            this.close();
        }
    }
}
,
"9eb92b73":/*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    module.exports = encodeUrl;
    var ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
    var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
    var UNMATCHED_SURROGATE_PAIR_REPLACE = '$1\uFFFD$2';
    function encodeUrl(url) {
        return String(url).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
    }
}
,
"9f146555":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "VitePluginAdapter", ()=>VitePluginAdapter);
    var _f_utils = farmRequire("e60815f7");
    var _f_path = module.i(farmRequire('path'));
    var _f_fs_extra = module.i(farmRequire("77e37188"));
    var _f_promises = farmRequire('fs/promises');
    var _f_index = farmRequire("bf50199b");
    var _f_merge = module.i(farmRequire("c074a41a"));
    var _f_apply_html_transform = farmRequire("b3cd9106");
    var _f_farm_to_vite_config = farmRequire("ae13b92b");
    var _f_farm_to_vite_context = farmRequire("6c19eb1c");
    var _f_utils1 = farmRequire("e60815f7");
    var _f_vite_server_adapter = farmRequire("d874708b");
    class VitePluginAdapter {
        name = 'to-be-override';
        priority = 0;
        _rawPlugin;
        _farmConfig;
        _viteConfig;
        _viteDevServer;
        _logger;
        _moduleGraph;
        buildStart;
        resolve;
        load;
        transform;
        buildEnd;
        finish;
        updateModules;
        renderResourcePot;
        renderStart;
        augmentResourceHash;
        finalizeResources;
        writeResources;
        transformHtml;
        filters;
        constructor(rawPlugin, farmConfig, filters, logger, mode){
            this.name = rawPlugin.name || `vite-plugin-adapted-${Date.now()}`;
            if (!rawPlugin.name) {
                throw new Error(`Vite plugin ${rawPlugin} is not compatible with Farm for now. Because plugin name is required in Farm.`);
            }
            this.priority = _f_utils.convertEnforceToPriority(rawPlugin.enforce);
            this._rawPlugin = rawPlugin;
            this._farmConfig = farmConfig;
            this._viteConfig = _f_farm_to_vite_config.farmUserConfigToViteConfig(farmConfig);
            this._logger = logger;
            this.filters = filters;
            const hooksMap = {
                buildStart: ()=>this.buildStart = this.viteBuildStartToFarmBuildStart(),
                resolveId: ()=>this.resolve = this.viteResolveIdToFarmResolve(),
                load: ()=>this.load = this.viteLoadToFarmLoad(),
                transform: ()=>this.transform = this.viteTransformToFarmTransform(),
                buildEnd: ()=>this.buildEnd = this.viteBuildEndToFarmBuildEnd(),
                handleHotUpdate: ()=>this.updateModules = this.viteHandleHotUpdateToFarmUpdateModules(),
                renderChunk: ()=>this.renderResourcePot = this.viteHandleRenderChunkToFarmRenderResourcePot(),
                renderStart: ()=>this.renderStart = this.viteRenderStartToFarmRenderStart(),
                augmentChunkHash: ()=>this.augmentResourceHash = this.viteAugmentChunkHashToFarmAugmentResourceHash(),
                generateBundle: ()=>this.finalizeResources = this.viteGenerateBundleToFarmFinalizeResources(),
                transformIndexHtml: ()=>this.transformHtml = this.viteTransformIndexHtmlToFarmTransformHtml(),
                'writeBundle|closeBundle': ()=>this.writeResources = this.viteWriteCloseBundleToFarmWriteResources()
            };
            const alwaysExecutedHooks = [
                'buildStart'
            ];
            const productionOnlyHooks = [
                'renderChunk',
                'generateBundle',
                'renderStart',
                'closeBundle',
                'writeBundle'
            ];
            for (const [hookNameGroup, fn] of Object.entries(hooksMap)){
                const hookNames = hookNameGroup.split('|');
                for (const hookName of hookNames){
                    if (rawPlugin[hookName] || alwaysExecutedHooks.includes(hookName)) {
                        if (mode !== 'production' && productionOnlyHooks.includes(hookName)) {
                            continue;
                        }
                        fn();
                    }
                }
            }
            const unsupportedHooks = [
                'moduleParsed',
                'renderError',
                'resolveDynamicImport',
                'resolveFileUrl',
                'resolveImportMeta',
                'shouldTransformCachedModule',
                'banner',
                'footer'
            ];
            for (const hookName of unsupportedHooks){
                if (this._rawPlugin[hookName]) {
                    throw new Error(`Vite plugin ${this.name} is not compatible with Farm for now. Because it uses hook "${hookName}" which is not supported by Farm.`);
                }
            }
        }
        get api() {
            return this._rawPlugin.api;
        }
        async config(config) {
            this._farmConfig = config;
            this._viteConfig = _f_farm_to_vite_config.farmUserConfigToViteConfig(this._farmConfig);
            const configHook = this.wrapRawPluginHook('config', this._rawPlugin.config);
            if (configHook) {
                this._viteConfig = _f_farm_to_vite_config.proxyViteConfig(module.f(_f_merge)(this._viteConfig, await configHook(_f_farm_to_vite_config.proxyViteConfig(this._viteConfig, this.name, this._logger), this.getViteConfigEnv())), this.name, this._logger);
                this._farmConfig = _f_farm_to_vite_config.viteConfigToFarmConfig(this._viteConfig, this._farmConfig, this.name);
            }
            return this._farmConfig;
        }
        async configResolved(config) {
            this._farmConfig = config;
            this._viteConfig = _f_farm_to_vite_config.proxyViteConfig(_f_farm_to_vite_config.farmUserConfigToViteConfig(config), this.name, this._logger);
            if (!this._rawPlugin.configResolved) return;
            const configResolvedHook = this.wrapRawPluginHook('configResolved', this._rawPlugin.configResolved);
            if (configResolvedHook) {
                await configResolvedHook(this._viteConfig);
            }
        }
        async configureDevServer(devServer) {
            const hook = this.wrapRawPluginHook('configureServer', this._rawPlugin.configureServer);
            this._viteDevServer = _f_vite_server_adapter.createViteDevServerAdapter(this.name, this._viteConfig, devServer);
            if (hook) {
                await hook(this._viteDevServer);
                this._viteDevServer.middlewareCallbacks.forEach((cb)=>{
                    devServer.app().use((ctx, koaNext)=>{
                        return new Promise((resolve, reject)=>{
                            const next = (err)=>{
                                if (err) reject(err);
                                koaNext().then(resolve);
                            };
                            return cb(ctx.req, ctx.res, next);
                        });
                    });
                });
            }
        }
        getViteConfigEnv() {
            return {
                isSsrBuild: this._farmConfig.compilation?.output?.targetEnv === 'node',
                command: this._farmConfig.compilation?.mode === 'production' ? 'build' : 'serve',
                mode: this._farmConfig.compilation?.mode
            };
        }
        shouldExecutePlugin() {
            const command = this._farmConfig.compilation?.mode === 'production' ? 'build' : 'serve';
            if (typeof this._rawPlugin.apply === 'function') {
                return this._rawPlugin.apply(this._viteConfig, {
                    mode: this._farmConfig.compilation.mode,
                    command,
                    isSsrBuild: this._farmConfig.compilation.output?.targetEnv === 'node'
                });
            } else if (this._rawPlugin.apply === undefined) {
                return true;
            }
            return this._rawPlugin.apply === command;
        }
        wrapExecutor(executor) {
            return async (...args)=>{
                if (this.shouldExecutePlugin()) {
                    return await executor(...args);
                }
            };
        }
        wrapRawPluginHook(hookName, hook, farmContext, currentHandlingFile, hookContext) {
            if (hook === undefined) {
                return undefined;
            }
            if (typeof hook === 'object') {
                if (!hook.handler) {
                    return undefined;
                }
                const logWarn = (name)=>{
                    this._logger.warn(`Farm does not support '${name}' property of vite plugin ${this.name} hook ${hookName} for now. '${name}' property will be ignored.`);
                };
                const supportedHooks = [
                    'transformIndexHtml'
                ];
                if (hook.order && !supportedHooks.includes(hookName)) {
                    logWarn('order');
                }
                if (hook.sequential) {
                    logWarn('sequential');
                }
                hook = hook.handler;
            }
            if (farmContext) {
                const pluginContext = _f_farm_to_vite_context.farmContextToViteContext(farmContext, currentHandlingFile, this.name, hookName, this._farmConfig, hookContext);
                return hook.bind(pluginContext);
            } else {
                return hook;
            }
        }
        viteBuildStartToFarmBuildStart() {
            return {
                executor: this.wrapExecutor((_, context)=>{
                    const hook = this.wrapRawPluginHook('buildStart', this._rawPlugin.buildStart, context);
                    if (this._viteDevServer) {
                        this._viteDevServer.moduleGraph.context = context;
                    }
                    return hook?.();
                })
            };
        }
        viteResolveIdToFarmResolve() {
            return {
                filters: {
                    sources: [
                        '.*'
                    ],
                    importers: this.filters
                },
                executor: this.wrapExecutor(async (params, context, hookContext)=>{
                    if (VitePluginAdapter.isFarmInternalVirtualModule(params.source) || params.importer && VitePluginAdapter.isFarmInternalVirtualModule(params.importer) || hookContext?.caller === this.name + '.resolveId') {
                        return null;
                    }
                    const hook = this.wrapRawPluginHook('resolveId', this._rawPlugin.resolveId, context, undefined, hookContext);
                    const absImporterPath = _f_utils.normalizePath(module.f(_f_path).resolve(process.cwd(), params.importer ?? ''));
                    let resolveIdResult = await hook?.(_f_utils.decodeStr(params.source), absImporterPath, {
                        isEntry: params.kind === 'entry'
                    });
                    if (_f_utils.isString(resolveIdResult)) {
                        resolveIdResult = _f_utils.normalizeAdapterVirtualModule(resolveIdResult);
                        return {
                            resolvedPath: _f_utils.removeQuery(_f_utils.encodeStr(resolveIdResult)),
                            query: _f_utils.customParseQueryString(resolveIdResult),
                            sideEffects: true,
                            external: false,
                            meta: {}
                        };
                    } else if (_f_utils.isObject(resolveIdResult)) {
                        const resolveId = _f_utils.normalizeAdapterVirtualModule(resolveIdResult?.id);
                        return {
                            resolvedPath: _f_utils.removeQuery(_f_utils.encodeStr(resolveId)),
                            query: _f_utils.customParseQueryString(resolveId),
                            sideEffects: Boolean(resolveIdResult?.moduleSideEffects),
                            external: Boolean(resolveIdResult?.external),
                            meta: resolveIdResult.meta ?? {}
                        };
                    }
                    const rootAbsolutePath = module.f(_f_path).join(this._farmConfig.root, params.source);
                    if (_f_utils.isStartsWithSlash(params.source) && module.f(_f_fs_extra).pathExistsSync(rootAbsolutePath)) {
                        return {
                            resolvedPath: _f_utils.removeQuery(_f_utils.encodeStr(rootAbsolutePath)),
                            query: _f_utils.customParseQueryString(rootAbsolutePath),
                            sideEffects: false,
                            external: false,
                            meta: {}
                        };
                    }
                    return null;
                })
            };
        }
        viteLoadToFarmLoad() {
            return {
                filters: {
                    resolvedPaths: this.filters
                },
                executor: this.wrapExecutor(async (params, context)=>{
                    if (VitePluginAdapter.isFarmInternalVirtualModule(params.moduleId)) {
                        return null;
                    }
                    const hook = this.wrapRawPluginHook('load', this._rawPlugin.load, context, params.moduleId);
                    const isSSR = this._farmConfig.compilation.output?.targetEnv === 'node';
                    const resolvedPath = _f_utils.normalizePath(_f_utils.decodeStr(params.resolvedPath));
                    const id = _f_utils.formatId(resolvedPath, params.query);
                    const result = await hook?.(id, isSSR ? {
                        ssr: true
                    } : undefined);
                    if (result) {
                        let map = undefined;
                        if (typeof result === 'object' && result.map) {
                            if (typeof result.map === 'string') {
                                map = result.map;
                            } else if (typeof result.map === 'object') {
                                map = JSON.stringify(result.map);
                            }
                        }
                        return {
                            content: _f_utils.getContentValue(result),
                            moduleType: _f_utils.formatLoadModuleType(id),
                            sourceMap: map
                        };
                    }
                })
            };
        }
        viteTransformToFarmTransform() {
            const moduleTypesCouldTransform = [
                _f_utils.VITE_PLUGIN_DEFAULT_MODULE_TYPE,
                'asset',
                'json'
            ];
            return {
                filters: {
                    resolvedPaths: this.filters
                },
                executor: this.wrapExecutor(async (params, context)=>{
                    if (VitePluginAdapter.isFarmInternalVirtualModule(params.moduleId)) {
                        return null;
                    }
                    const hook = this.wrapRawPluginHook('transform', this._rawPlugin.transform, context, params.moduleId);
                    const isSSR = this._farmConfig.compilation.output?.targetEnv === 'node';
                    const resolvedPath = _f_utils.normalizePath(_f_utils.decodeStr(params.resolvedPath));
                    const id = _f_utils.formatId(resolvedPath, params.query);
                    const result = await hook?.(params.content, id, isSSR ? {
                        ssr: true
                    } : undefined);
                    if (result) {
                        const content = _f_utils.getContentValue(result);
                        if (content) {
                            return {
                                content,
                                sourceMap: typeof result.map === 'object' && result.map !== null ? JSON.stringify(result.map) : undefined,
                                moduleType: moduleTypesCouldTransform.includes(params.moduleType) ? _f_utils.formatTransformModuleType(id) : params.moduleType
                            };
                        }
                    }
                })
            };
        }
        viteBuildEndToFarmBuildEnd() {
            return {
                executor: this.wrapExecutor((_, context)=>{
                    const hook = this.wrapRawPluginHook('buildEnd', this._rawPlugin.buildEnd, context);
                    return hook?.();
                })
            };
        }
        viteHandleHotUpdateToFarmUpdateModules() {
            return {
                executor: this.wrapExecutor(async ({ paths }, ctx)=>{
                    const hook = this.wrapRawPluginHook('handleHotUpdate', this._rawPlugin.handleHotUpdate, ctx);
                    let moduleGraph;
                    if (this._viteDevServer) {
                        moduleGraph = this._viteDevServer.moduleGraph;
                    } else if (this._moduleGraph) {
                        moduleGraph = this._moduleGraph;
                    } else {
                        moduleGraph = new _f_vite_server_adapter.ViteModuleGraphAdapter(this.name);
                        this._moduleGraph = moduleGraph;
                    }
                    moduleGraph.context = ctx;
                    const result = [];
                    for (const [file, _] of paths){
                        const mods = moduleGraph.getModulesByFile(file);
                        const filename = _f_utils.normalizePath(file);
                        const ctx = {
                            file: filename,
                            timestamp: Date.now(),
                            modules: (mods ?? []).map((m)=>({
                                    ...m,
                                    id: _f_utils.normalizePath(m.id),
                                    file: _f_utils.normalizePath(m.file)
                                })),
                            read: function() {
                                return _f_promises.readFile(file, 'utf-8');
                            },
                            server: this._viteDevServer
                        };
                        const updateMods = await hook?.(ctx);
                        if (updateMods) {
                            result.push(...updateMods.map((mod)=>mod.id));
                        } else {
                            result.push(...mods.map((mod)=>mod.id));
                        }
                    }
                    return [
                        ...new Set(result)
                    ].map((id)=>_f_utils.revertNormalizePath(id));
                })
            };
        }
        viteHandleRenderChunkToFarmRenderResourcePot() {
            return {
                filters: {
                    moduleIds: this.filters
                },
                executor: this.wrapExecutor(async (param, ctx)=>{
                    if (param.resourcePotInfo.resourcePotType !== 'js') {
                        return;
                    }
                    const hook = this.wrapRawPluginHook('renderChunk', this._rawPlugin.renderChunk, ctx);
                    const result = await hook(param.content, _f_utils.transformResourceInfo2RollupRenderedChunk(param.resourcePotInfo), {}, {
                        chunks: {}
                    });
                    if (result) {
                        if (typeof result === 'string') {
                            return {
                                content: result
                            };
                        } else if (typeof result === 'object') {
                            return {
                                content: result.code,
                                sourceMap: result.map
                            };
                        }
                    }
                })
            };
        }
        viteRenderStartToFarmRenderStart() {
            return {
                executor: this.wrapExecutor(async (param, ctx)=>{
                    const hook = this.wrapRawPluginHook('renderStart', this._rawPlugin.renderStart, ctx);
                    await hook(_f_utils.transformFarmConfigToRollupNormalizedOutputOptions(param), _f_utils1.transformFarmConfigToRollupNormalizedInputOptions(param));
                })
            };
        }
        viteAugmentChunkHashToFarmAugmentResourceHash() {
            return {
                filters: {
                    moduleIds: this.filters
                },
                executor: this.wrapExecutor(async (param, context)=>{
                    if (param.resourcePotType !== 'js') {
                        return;
                    }
                    const hook = this.wrapRawPluginHook('augmentChunkHash', this._rawPlugin.augmentChunkHash, context);
                    const hash = await hook?.(_f_utils.transformResourceInfo2RollupRenderedChunk(param));
                    return hash;
                })
            };
        }
        viteGenerateBundleToFarmFinalizeResources() {
            return {
                executor: this.wrapExecutor(async (param, context)=>{
                    const emittedFiles = [];
                    context.emitFile = async (params)=>{
                        emittedFiles.push(params);
                    };
                    const hook = this.wrapRawPluginHook('generateBundle', this._rawPlugin.generateBundle, context);
                    const bundles = Object.entries(param.resourcesMap).reduce((res, [key, val])=>{
                        res[key] = _f_utils1.transformResourceInfo2RollupResource(val);
                        return res;
                    }, {});
                    await hook?.(_f_utils.transformFarmConfigToRollupNormalizedOutputOptions(param.config), bundles);
                    const emittedFilesMap = emittedFiles.reduce((res, item)=>{
                        res[item.name] = {
                            name: item.name,
                            bytes: item.content,
                            emitted: false,
                            resourceType: 'asset',
                            origin: {
                                type: 'Module',
                                value: 'vite-plugin-adapter-generate-bundle-hook'
                            }
                        };
                        return res;
                    }, {});
                    const result = Object.entries(bundles).reduce((res, [key, val])=>{
                        res[key] = _f_utils.transformRollupResource2FarmResource(val, param.resourcesMap[key]);
                        return res;
                    }, emittedFilesMap);
                    return result;
                })
            };
        }
        viteTransformIndexHtmlToFarmTransformHtml() {
            const rawTransformHtmlHook = this._rawPlugin.transformIndexHtml;
            const order = rawTransformHtmlHook?.order ?? rawTransformHtmlHook?.enforce ?? this._rawPlugin.enforce ?? 'normal';
            const orderMap = {
                pre: 0,
                normal: 1,
                post: 2
            };
            return {
                order: orderMap[order] ?? 1,
                executor: this.wrapExecutor(async (params, context)=>{
                    const { htmlResource } = params;
                    const hook = this.wrapRawPluginHook('transformIndexHtml', this._rawPlugin.transformIndexHtml, context);
                    const result = await this.callViteTransformIndexHtmlHook(htmlResource, hook);
                    if (result) {
                        htmlResource.bytes = [
                            ...Buffer.from(result)
                        ];
                    }
                    return htmlResource;
                })
            };
        }
        viteWriteCloseBundleToFarmWriteResources() {
            return {
                executor: this.wrapExecutor(async (param, context)=>{
                    const hook = this.wrapRawPluginHook('writeBundle', this._rawPlugin.writeBundle, context);
                    if (hook) {
                        const bundles = Object.entries(param.resourcesMap).reduce((res, [key, val])=>{
                            res[key] = _f_utils1.transformResourceInfo2RollupResource(val);
                            return res;
                        }, {});
                        await hook?.(_f_utils.transformFarmConfigToRollupNormalizedOutputOptions(param.config), bundles);
                    }
                    const closeBundle = this.wrapRawPluginHook('closeBundle', this._rawPlugin.closeBundle);
                    return closeBundle?.();
                })
            };
        }
        async callViteTransformIndexHtmlHook(resource, transformIndexHtmlHook, bundles) {
            const html = Buffer.from(resource.bytes).toString();
            const result = await transformIndexHtmlHook?.(html, {
                path: resource.name,
                filename: resource.name,
                server: bundles === undefined ? this._viteDevServer : undefined,
                bundle: bundles,
                chunk: _f_utils1.transformResourceInfo2RollupResource(resource)
            });
            if (result && typeof result !== 'string') {
                return _f_apply_html_transform.applyHtmlTransform(html, result);
            } else if (typeof result === 'string') {
                return result;
            }
        }
        static isFarmInternalVirtualModule(id) {
            return id.endsWith(_f_index.VIRTUAL_FARM_DYNAMIC_IMPORT_SUFFIX) || _f_utils.FARM_CSS_MODULES_SUFFIX.test(id);
        }
    }
}
,
"9f6bd6d5":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    var has = Object.prototype.hasOwnProperty, prefix = '~';
    function Events() {}
    if (Object.create) {
        Events.prototype = Object.create(null);
        if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
        this.fn = fn;
        this.context = context;
        this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
        if (typeof fn !== 'function') {
            throw new TypeError('The listener must be a function');
        }
        var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
        else emitter._events[evt] = [
            emitter._events[evt],
            listener
        ];
        return emitter;
    }
    function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0) emitter._events = new Events();
        else delete emitter._events[evt];
    }
    function EventEmitter() {
        this._events = new Events();
        this._eventsCount = 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
        var names = [], events, name;
        if (this._eventsCount === 0) return names;
        for(name in events = this._events){
            if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
        }
        if (Object.getOwnPropertySymbols) {
            return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
    };
    EventEmitter.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers) return [];
        if (handlers.fn) return [
            handlers.fn
        ];
        for(var i = 0, l = handlers.length, ee = new Array(l); i < l; i++){
            ee[i] = handlers[i].fn;
        }
        return ee;
    };
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners) return 0;
        if (listeners.fn) return 1;
        return listeners.length;
    };
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return false;
        var listeners = this._events[evt], len = arguments.length, args, i;
        if (listeners.fn) {
            if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
            switch(len){
                case 1:
                    return listeners.fn.call(listeners.context), true;
                case 2:
                    return listeners.fn.call(listeners.context, a1), true;
                case 3:
                    return listeners.fn.call(listeners.context, a1, a2), true;
                case 4:
                    return listeners.fn.call(listeners.context, a1, a2, a3), true;
                case 5:
                    return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
                case 6:
                    return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
            }
            for(i = 1, args = new Array(len - 1); i < len; i++){
                args[i - 1] = arguments[i];
            }
            listeners.fn.apply(listeners.context, args);
        } else {
            var length = listeners.length, j;
            for(i = 0; i < length; i++){
                if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
                switch(len){
                    case 1:
                        listeners[i].fn.call(listeners[i].context);
                        break;
                    case 2:
                        listeners[i].fn.call(listeners[i].context, a1);
                        break;
                    case 3:
                        listeners[i].fn.call(listeners[i].context, a1, a2);
                        break;
                    case 4:
                        listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                        break;
                    default:
                        if (!args) for(j = 1, args = new Array(len - 1); j < len; j++){
                            args[j - 1] = arguments[j];
                        }
                        listeners[i].fn.apply(listeners[i].context, args);
                }
            }
        }
        return true;
    };
    EventEmitter.prototype.on = function on(event, fn, context) {
        return addListener(this, event, fn, context, false);
    };
    EventEmitter.prototype.once = function once(event, fn, context) {
        return addListener(this, event, fn, context, true);
    };
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return this;
        if (!fn) {
            clearEvent(this, evt);
            return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
            if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
                clearEvent(this, evt);
            }
        } else {
            for(var i = 0, events = [], length = listeners.length; i < length; i++){
                if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
                    events.push(listeners[i]);
                }
            }
            if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
            else clearEvent(this, evt);
        }
        return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
            evt = prefix ? prefix + event : event;
            if (this._events[evt]) clearEvent(this, evt);
        } else {
            this._events = new Events();
            this._eventsCount = 0;
        }
        return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    EventEmitter.prefixed = prefix;
    EventEmitter.EventEmitter = EventEmitter;
    if ('undefined' !== typeof module) {
        module.exports = EventEmitter;
    }
}
,
"9f93fed5":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const mimicFn = (to, from)=>{
        for (const prop of Reflect.ownKeys(from)){
            Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
        }
        return to;
    };
    module.exports = mimicFn;
    module.exports.default = mimicFn;
}
,
"9ff09f2c":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
        module.exports = farmRequire("b6eaaf05", true);
    } else {
        module.exports = farmRequire("bb3d8063", true);
    }
}
,
"a041fd99":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "createWatcher", ()=>createWatcher);
    var _f_node_path = module.i(farmRequire('node:path'));
    var _f_chokidar = module.i(farmRequire('chokidar'));
    var _f_fast_glob = module.i(farmRequire("7da8dae6"));
    function resolveChokidarOptions(config, insideChokidarOptions) {
        const { ignored = [], ...userChokidarOptions } = config.server?.hmr?.watchOptions ?? {};
        let cacheDir = module.f(_f_node_path).resolve(config.root, 'node_modules', '.farm', 'cache');
        if (typeof config.compilation?.persistentCache === 'object' && config.compilation.persistentCache.cacheDir) {
            cacheDir = config.compilation.persistentCache.cacheDir;
            if (!module.f(_f_node_path).isAbsolute(cacheDir)) {
                cacheDir = module.f(_f_node_path).resolve(config.root, cacheDir);
            }
        }
        const options = {
            ignored: [
                '**/.git/**',
                '**/node_modules/**',
                '**/test-results/**',
                module.f(_f_fast_glob).escapePath(cacheDir) + '/**',
                module.f(_f_fast_glob).escapePath(module.f(_f_node_path).resolve(config.root, config.compilation.output.path)) + '/**',
                ...Array.isArray(ignored) ? ignored : [
                    ignored
                ]
            ],
            ignoreInitial: true,
            ignorePermissionErrors: true,
            awaitWriteFinish: process.platform === 'linux' ? undefined : {
                stabilityThreshold: 10,
                pollInterval: 10
            },
            ...userChokidarOptions,
            ...insideChokidarOptions
        };
        return options;
    }
    function createWatcher(config, files, chokidarOptions) {
        const options = resolveChokidarOptions(config, chokidarOptions);
        return module.f(_f_chokidar).watch(files, options);
    }
}
,
"a046a4f5":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "default", ()=>WsServer);
    var _f_ws = farmRequire("44dd1046");
    var _f_index = farmRequire("953dfae2");
    var _f_http = farmRequire("84a68c6c");
    const HMR_HEADER = 'farm_hmr';
    const wsServerEvents = [
        'connection',
        'error',
        'headers',
        'listening',
        'message'
    ];
    class WsServer {
        httpServer;
        config;
        hmrEngine;
        wss;
        customListeners;
        clientsMap;
        bufferedError;
        logger;
        hmrOrigins;
        constructor(httpServer, config, hmrEngine, logger){
            this.httpServer = httpServer;
            this.config = config;
            this.hmrEngine = hmrEngine;
            this.customListeners = new Map();
            this.clientsMap = new WeakMap();
            this.bufferedError = null;
            this.logger = logger ?? new _f_index.Logger();
            this.hmrOrigins = this.generateHMROrigins(config);
            this.createWebSocketServer();
        }
        generateHMROrigins(config) {
            const { protocol, hostname, port } = config;
            const origins = [];
            const urls = _f_http.resolveServerUrls(this.httpServer, config);
            const localUrls = [
                ...urls.local || [],
                ...urls.network || []
            ];
            for (const url of localUrls){
                origins.push(url);
            }
            const configuredOrigin = `${protocol}://${hostname.name}:${port}`;
            if (hostname && hostname.name && localUrls.every((url)=>url !== configuredOrigin)) {
                origins.push(configuredOrigin);
            }
            if (this.config.host !== this.config.hmr.host) {
                const hmrHostname = _f_http.resolveHostname(this.config.hmr.host);
                origins.push(`${this.config.hmr?.protocol || protocol}://${hmrHostname.name}:${this.config.hmr?.port || this.config.port}`);
            }
            return origins;
        }
        createWebSocketServer() {
            try {
                const WebSocketServer = process.versions.bun ? module.meta.require('ws').WebSocketServer : _f_ws.WebSocketServer;
                if (this.config.host === this.config.hmr.host) {
                    this.wss = new WebSocketServer({
                        noServer: true
                    });
                    this.connection();
                    this.httpServer.on('upgrade', this.upgradeWsServer.bind(this));
                } else {
                    const hmrHostname = _f_http.resolveHostname(this.config.hmr.host);
                    this.wss = new WebSocketServer({
                        host: hmrHostname.name,
                        port: this.config.hmr?.port || this.config.port
                    });
                    this.connection();
                }
            } catch (err) {
                this.handleSocketError(err);
            }
        }
        upgradeWsServer(request, socket, head) {
            if (this.isHMRRequest(request)) {
                this.handleHMRUpgrade(request, socket, head);
            } else {
                this.logger.error(`HMR upgrade failed because of invalid HMR path, header or host. The HMR connection is only allowed on hosts: ${this.hmrOrigins.join(', ')}. You can try set server.host or server.allowedHosts to allow the connection.`);
            }
        }
        listen() {}
        send(...args) {
            let payload;
            if (typeof args[0] === 'string') {
                payload = {
                    type: 'custom',
                    event: args[0],
                    data: args[1]
                };
            } else {
                payload = args[0];
            }
            if (payload.type === 'error' && !this.wss.clients.size) {
                this.bufferedError = payload;
                return;
            }
            const stringified = JSON.stringify(payload);
            this.wss.clients.forEach((client)=>{
                if (client.readyState === 1) {
                    client.send(stringified);
                }
            });
        }
        isHMRRequest(request) {
            return request.url === this.config.hmr.path && request.headers['sec-websocket-protocol'] === HMR_HEADER;
        }
        handleHMRUpgrade(request, socket, head) {
            this.wss.handleUpgrade(request, socket, head, (ws)=>{
                this.wss.emit('connection', ws, request);
            });
        }
        get clients() {
            return new Set(Array.from(this.wss.clients).map(this.getSocketClient.bind(this)));
        }
        sendCustomEvent(event, payload) {
            this.send({
                type: 'custom',
                event,
                data: payload
            });
        }
        on(event, listener) {
            if (wsServerEvents.includes(event)) {
                this.wss.on(event, listener);
            } else {
                this.addCustomEventListener(event, listener);
            }
        }
        off(event, listener) {
            if (wsServerEvents.includes(event)) {
                this.wss.off(event, listener);
            } else {
                this.removeCustomEventListener(event, listener);
            }
        }
        connection() {
            this.wss.on('connection', (socket)=>{
                socket.on('message', (raw)=>{
                    if (!this.customListeners.size) return;
                    let parsed;
                    try {
                        parsed = JSON.parse(String(raw));
                    } catch  {
                        this.logger.error('Failed to parse WebSocket message: ' + raw);
                    }
                    if (parsed?.type === 'js-update' && parsed?.path) {
                        this.hmrEngine.hmrUpdate(parsed.path, true);
                        return;
                    }
                    if (!parsed || parsed.type !== 'custom' || !parsed.event) return;
                    const listeners = this.customListeners.get(parsed.event);
                    if (!listeners?.size) return;
                    const client = this.getSocketClient(socket);
                    listeners.forEach((listener)=>listener(parsed.data, client));
                });
                socket.on('error', (err)=>{
                    return this.handleSocketError(err);
                });
                socket.send(JSON.stringify({
                    type: 'connected'
                }));
                if (this.bufferedError) {
                    socket.send(JSON.stringify(this.bufferedError));
                    this.bufferedError = null;
                }
            });
        }
        async close() {
            if (this.upgradeWsServer && this.httpServer) {
                this.httpServer.off('upgrade', this.upgradeWsServer);
            }
            await this.terminateAllClients();
            await this.closeWebSocketServer();
        }
        terminateAllClients() {
            const terminatePromises = Array.from(this.wss.clients).map((client)=>{
                return new Promise((resolve)=>{
                    if (client.readyState === _f_ws.WebSocket.OPEN) {
                        client.send(JSON.stringify({
                            type: 'closing'
                        }));
                        client.close(1000, 'Server shutdown');
                    }
                    client.once('close', ()=>resolve(true));
                });
            });
            return Promise.all(terminatePromises);
        }
        closeWebSocketServer() {
            return new Promise((resolve, reject)=>{
                this.wss.close((err)=>{
                    if (err) {
                        reject(err);
                    } else {
                        resolve(true);
                    }
                });
            });
        }
        addCustomEventListener(event, listener) {
            if (!this.customListeners.has(event)) {
                this.customListeners.set(event, new Set());
            }
            this.customListeners.get(event).add(listener);
        }
        removeCustomEventListener(event, listener) {
            this.customListeners.get(event)?.delete(listener);
        }
        getSocketClient(socket) {
            if (!this.clientsMap.has(socket)) {
                this.clientsMap.set(socket, {
                    send: (...args)=>this.sendMessage(socket, ...args),
                    socket,
                    rawSend: (str)=>socket.send(str)
                });
            }
            return this.clientsMap.get(socket);
        }
        sendMessage(socket, ...args) {
            let payload;
            if (typeof args[0] === 'string') {
                payload = {
                    type: 'custom',
                    event: args[0],
                    data: args[1]
                };
            } else {
                payload = args[0];
            }
            socket.send(JSON.stringify(payload));
        }
        handleSocketError(err) {
            if (err.code === 'EADDRINUSE') {
                this.logger.error(_f_index.red(`WebSocket server error: Port is already in use`), {
                    error: err
                });
            } else {
                this.logger.error(_f_index.red(`WebSocket server error:\n${err.stack || err.message}`), {
                    error: err
                });
            }
        }
    }
}
,
"a1177766":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "addPipeMethods", ()=>addPipeMethods);
    var _f_node_fs = farmRequire('node:fs');
    var _f_node_child_process = farmRequire('node:child_process');
    var _f_is_stream = farmRequire("e7253e09");
    const isExecaChildProcess = (target)=>target instanceof _f_node_child_process.ChildProcess && typeof target.then === 'function';
    const pipeToTarget = (spawned, streamName, target)=>{
        if (typeof target === 'string') {
            spawned[streamName].pipe(_f_node_fs.createWriteStream(target));
            return spawned;
        }
        if (_f_is_stream.isWritableStream(target)) {
            spawned[streamName].pipe(target);
            return spawned;
        }
        if (!isExecaChildProcess(target)) {
            throw new TypeError('The second argument must be a string, a stream or an Execa child process.');
        }
        if (!_f_is_stream.isWritableStream(target.stdin)) {
            throw new TypeError('The target child process\'s stdin must be available.');
        }
        spawned[streamName].pipe(target.stdin);
        return target;
    };
    var addPipeMethods = (spawned)=>{
        if (spawned.stdout !== null) {
            spawned.pipeStdout = pipeToTarget.bind(undefined, spawned, 'stdout');
        }
        if (spawned.stderr !== null) {
            spawned.pipeStderr = pipeToTarget.bind(undefined, spawned, 'stderr');
        }
        if (spawned.all !== undefined) {
            spawned.pipeAll = pipeToTarget.bind(undefined, spawned, 'all');
        }
    };
}
,
"a1439f88":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    module.exports = function required(port, protocol) {
        protocol = protocol.split(':')[0];
        port = +port;
        if (!port) return false;
        switch(protocol){
            case 'http':
            case 'ws':
                return port !== 80;
            case 'https':
            case 'wss':
                return port !== 443;
            case 'ftp':
                return port !== 21;
            case 'gopher':
                return port !== 70;
            case 'file':
                return false;
        }
        return port !== 0;
    };
}
,
"a29d9e0e":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const path = global.nodeRequire("path", true);
    const fsStat = farmRequire("be5cf725", true);
    const fs = farmRequire("601e56c0", true);
    class Settings {
        constructor(_options = {}){
            this._options = _options;
            this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
            this.fs = fs.createFileSystemAdapter(this._options.fs);
            this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);
            this.stats = this._getValue(this._options.stats, false);
            this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
            this.fsStatSettings = new fsStat.Settings({
                followSymbolicLink: this.followSymbolicLinks,
                fs: this.fs,
                throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
            });
        }
        _getValue(option, value) {
            return option !== null && option !== void 0 ? option : value;
        }
    }
    exports.default = Settings;
}
,
"a2a2844e":/*!
 * content-disposition
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    module.exports = contentDisposition;
    module.exports.parse = parse;
    var basename = global.nodeRequire('path', true).basename;
    var Buffer = farmRequire("e7d04bd9", true).Buffer;
    var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g;
    var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
    var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;
    var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;
    var QESC_REGEXP = /\\([\u0000-\u007f])/g;
    var QUOTE_REGEXP = /([\\"])/g;
    var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g;
    var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
    var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;
    var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;
    var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
    function contentDisposition(filename, options) {
        var opts = options || {};
        var type = opts.type || 'attachment';
        var params = createparams(filename, opts.fallback);
        return format(new ContentDisposition(type, params));
    }
    function createparams(filename, fallback) {
        if (filename === undefined) {
            return;
        }
        var params = {};
        if (typeof filename !== 'string') {
            throw new TypeError('filename must be a string');
        }
        if (fallback === undefined) {
            fallback = true;
        }
        if (typeof fallback !== 'string' && typeof fallback !== 'boolean') {
            throw new TypeError('fallback must be a string or boolean');
        }
        if (typeof fallback === 'string' && NON_LATIN1_REGEXP.test(fallback)) {
            throw new TypeError('fallback must be ISO-8859-1 string');
        }
        var name = basename(filename);
        var isQuotedString = TEXT_REGEXP.test(name);
        var fallbackName = typeof fallback !== 'string' ? fallback && getlatin1(name) : basename(fallback);
        var hasFallback = typeof fallbackName === 'string' && fallbackName !== name;
        if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) {
            params['filename*'] = name;
        }
        if (isQuotedString || hasFallback) {
            params.filename = hasFallback ? fallbackName : name;
        }
        return params;
    }
    function format(obj) {
        var parameters = obj.parameters;
        var type = obj.type;
        if (!type || typeof type !== 'string' || !TOKEN_REGEXP.test(type)) {
            throw new TypeError('invalid type');
        }
        var string = String(type).toLowerCase();
        if (parameters && typeof parameters === 'object') {
            var param;
            var params = Object.keys(parameters).sort();
            for(var i = 0; i < params.length; i++){
                param = params[i];
                var val = param.substr(-1) === '*' ? ustring(parameters[param]) : qstring(parameters[param]);
                string += '; ' + param + '=' + val;
            }
        }
        return string;
    }
    function decodefield(str) {
        var match = EXT_VALUE_REGEXP.exec(str);
        if (!match) {
            throw new TypeError('invalid extended field value');
        }
        var charset = match[1].toLowerCase();
        var encoded = match[2];
        var value;
        var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);
        switch(charset){
            case 'iso-8859-1':
                value = getlatin1(binary);
                break;
            case 'utf-8':
                value = Buffer.from(binary, 'binary').toString('utf8');
                break;
            default:
                throw new TypeError('unsupported charset in extended field');
        }
        return value;
    }
    function getlatin1(val) {
        return String(val).replace(NON_LATIN1_REGEXP, '?');
    }
    function parse(string) {
        if (!string || typeof string !== 'string') {
            throw new TypeError('argument string is required');
        }
        var match = DISPOSITION_TYPE_REGEXP.exec(string);
        if (!match) {
            throw new TypeError('invalid type format');
        }
        var index = match[0].length;
        var type = match[1].toLowerCase();
        var key;
        var names = [];
        var params = {};
        var value;
        index = PARAM_REGEXP.lastIndex = match[0].substr(-1) === ';' ? index - 1 : index;
        while(match = PARAM_REGEXP.exec(string)){
            if (match.index !== index) {
                throw new TypeError('invalid parameter format');
            }
            index += match[0].length;
            key = match[1].toLowerCase();
            value = match[2];
            if (names.indexOf(key) !== -1) {
                throw new TypeError('invalid duplicate parameter');
            }
            names.push(key);
            if (key.indexOf('*') + 1 === key.length) {
                key = key.slice(0, -1);
                value = decodefield(value);
                params[key] = value;
                continue;
            }
            if (typeof params[key] === 'string') {
                continue;
            }
            if (value[0] === '"') {
                value = value.substr(1, value.length - 2).replace(QESC_REGEXP, '$1');
            }
            params[key] = value;
        }
        if (index !== -1 && index !== string.length) {
            throw new TypeError('invalid parameter format');
        }
        return new ContentDisposition(type, params);
    }
    function pdecode(str, hex) {
        return String.fromCharCode(parseInt(hex, 16));
    }
    function pencode(char) {
        return '%' + String(char).charCodeAt(0).toString(16).toUpperCase();
    }
    function qstring(val) {
        var str = String(val);
        return '"' + str.replace(QUOTE_REGEXP, '\\$1') + '"';
    }
    function ustring(val) {
        var str = String(val);
        var encoded = encodeURIComponent(str).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);
        return 'UTF-8\'\'' + encoded;
    }
    function ContentDisposition(type, parameters) {
        this.type = type;
        this.parameters = parameters;
    }
}
,
"a2d7d647":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "headers", ()=>headers);
    function headers(devSeverContext) {
        const { config } = devSeverContext;
        if (!config.headers) return;
        return async (ctx, next)=>{
            if (config.headers) {
                for(const name in config.headers){
                    ctx.set(name, config.headers[name]);
                }
            }
            await next();
        };
    }
}
,
"a2f11397":/*!
 * fresh
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2016-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    var CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;
    module.exports = fresh;
    function fresh(reqHeaders, resHeaders) {
        var modifiedSince = reqHeaders['if-modified-since'];
        var noneMatch = reqHeaders['if-none-match'];
        if (!modifiedSince && !noneMatch) {
            return false;
        }
        var cacheControl = reqHeaders['cache-control'];
        if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {
            return false;
        }
        if (noneMatch && noneMatch !== '*') {
            var etag = resHeaders['etag'];
            if (!etag) {
                return false;
            }
            var etagStale = true;
            var matches = parseTokenList(noneMatch);
            for(var i = 0; i < matches.length; i++){
                var match = matches[i];
                if (match === etag || match === 'W/' + etag || 'W/' + match === etag) {
                    etagStale = false;
                    break;
                }
            }
            if (etagStale) {
                return false;
            }
        }
        if (modifiedSince) {
            var lastModified = resHeaders['last-modified'];
            var modifiedStale = !lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince));
            if (modifiedStale) {
                return false;
            }
        }
        return true;
    }
    function parseHttpDate(date) {
        var timestamp = date && Date.parse(date);
        return typeof timestamp === 'number' ? timestamp : NaN;
    }
    function parseTokenList(str) {
        var end = 0;
        var list = [];
        var start = 0;
        for(var i = 0, len = str.length; i < len; i++){
            switch(str.charCodeAt(i)){
                case 0x20:
                    if (start === end) {
                        start = end = i + 1;
                    }
                    break;
                case 0x2c:
                    list.push(str.substring(start, end));
                    start = end = i + 1;
                    break;
                default:
                    end = i + 1;
                    break;
            }
        }
        list.push(str.substring(start, end));
        return list;
    }
}
,
"a309845c":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    var _f_application = module.i(farmRequire("dfdc0c03"));
    exports.default = module.f(_f_application);
}
,
"a38475ea":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const stream_1 = global.nodeRequire("stream", true);
    const stream_2 = farmRequire("5a3e24d0", true);
    const provider_1 = farmRequire("ba3d9d5e", true);
    class ProviderStream extends provider_1.default {
        constructor(){
            super(...arguments);
            this._reader = new stream_2.default(this._settings);
        }
        read(task) {
            const root = this._getRootDirectory(task);
            const options = this._getReaderOptions(task);
            const source = this.api(root, task, options);
            const destination = new stream_1.Readable({
                objectMode: true,
                read: ()=>{}
            });
            source.once('error', (error)=>destination.emit('error', error)).on('data', (entry)=>destination.emit('data', options.transform(entry))).once('end', ()=>destination.emit('end'));
            destination.once('close', ()=>source.destroy());
            return destination;
        }
        api(root, task, options) {
            if (task.dynamic) {
                return this._reader.dynamic(root, options);
            }
            return this._reader.static(task.patterns, options);
        }
    }
    exports.default = ProviderStream;
}
,
"a4820a3f":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const fs = farmRequire("f2e2163e", true);
    const { checkPath } = farmRequire("aad46893", true);
    const getMode = (options)=>{
        const defaults = {
            mode: 0o777
        };
        if (typeof options === 'number') return options;
        return ({
            ...defaults,
            ...options
        }).mode;
    };
    module.exports.makeDir = async (dir, options)=>{
        checkPath(dir);
        return fs.mkdir(dir, {
            mode: getMode(options),
            recursive: true
        });
    };
    module.exports.makeDirSync = (dir, options)=>{
        checkPath(dir);
        return fs.mkdirSync(dir, {
            mode: getMode(options),
            recursive: true
        });
    };
}
,
"a4db3af6":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.isEmpty = exports.isString = void 0;
    function isString(input) {
        return typeof input === 'string';
    }
    exports.isString = isString;
    function isEmpty(input) {
        return input === '';
    }
    exports.isEmpty = isEmpty;
}
,
"a4f5e891":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const matcher_1 = farmRequire("d7234094", true);
    class PartialMatcher extends matcher_1.default {
        match(filepath) {
            const parts = filepath.split('/');
            const levels = parts.length;
            const patterns = this._storage.filter((info)=>!info.complete || info.segments.length > levels);
            for (const pattern of patterns){
                const section = pattern.sections[0];
                if (!pattern.complete && levels > section.length) {
                    return true;
                }
                const match = parts.every((part, index)=>{
                    const segment = pattern.segments[index];
                    if (segment.dynamic && segment.patternRe.test(part)) {
                        return true;
                    }
                    if (!segment.dynamic && segment.pattern === part) {
                        return true;
                    }
                    return false;
                });
                if (match) {
                    return true;
                }
            }
            return false;
        }
    }
    exports.default = PartialMatcher;
}
,
"a51b58e0":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const utils = farmRequire("781fd2fa", true);
    class ErrorFilter {
        constructor(_settings){
            this._settings = _settings;
        }
        getFilter() {
            return (error)=>this._isNonFatalError(error);
        }
        _isNonFatalError(error) {
            return utils.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
        }
    }
    exports.default = ErrorFilter;
}
,
"a575bc6d":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const { Writable } = global.nodeRequire('stream', true);
    const PerMessageDeflate = farmRequire("6e9f2004", true);
    const { BINARY_TYPES, EMPTY_BUFFER, kStatusCode, kWebSocket } = farmRequire("75844d1d", true);
    const { concat, toArrayBuffer, unmask } = farmRequire("2be17525", true);
    const { isValidStatusCode, isValidUTF8 } = farmRequire("9887cd18", true);
    const FastBuffer = Buffer[Symbol.species];
    const promise = Promise.resolve();
    const queueTask = typeof queueMicrotask === 'function' ? queueMicrotask : queueMicrotaskShim;
    const GET_INFO = 0;
    const GET_PAYLOAD_LENGTH_16 = 1;
    const GET_PAYLOAD_LENGTH_64 = 2;
    const GET_MASK = 3;
    const GET_DATA = 4;
    const INFLATING = 5;
    const WAIT_MICROTASK = 6;
    class Receiver extends Writable {
        constructor(options = {}){
            super();
            this._binaryType = options.binaryType || BINARY_TYPES[0];
            this._extensions = options.extensions || {};
            this._isServer = !!options.isServer;
            this._maxPayload = options.maxPayload | 0;
            this._skipUTF8Validation = !!options.skipUTF8Validation;
            this[kWebSocket] = undefined;
            this._bufferedBytes = 0;
            this._buffers = [];
            this._compressed = false;
            this._payloadLength = 0;
            this._mask = undefined;
            this._fragmented = 0;
            this._masked = false;
            this._fin = false;
            this._opcode = 0;
            this._totalPayloadLength = 0;
            this._messageLength = 0;
            this._fragments = [];
            this._state = GET_INFO;
            this._loop = false;
        }
        _write(chunk, encoding, cb) {
            if (this._opcode === 0x08 && this._state == GET_INFO) return cb();
            this._bufferedBytes += chunk.length;
            this._buffers.push(chunk);
            this.startLoop(cb);
        }
        consume(n) {
            this._bufferedBytes -= n;
            if (n === this._buffers[0].length) return this._buffers.shift();
            if (n < this._buffers[0].length) {
                const buf = this._buffers[0];
                this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
                return new FastBuffer(buf.buffer, buf.byteOffset, n);
            }
            const dst = Buffer.allocUnsafe(n);
            do {
                const buf = this._buffers[0];
                const offset = dst.length - n;
                if (n >= buf.length) {
                    dst.set(this._buffers.shift(), offset);
                } else {
                    dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
                    this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
                }
                n -= buf.length;
            }while (n > 0)
            return dst;
        }
        startLoop(cb) {
            let err;
            this._loop = true;
            do {
                switch(this._state){
                    case GET_INFO:
                        err = this.getInfo();
                        break;
                    case GET_PAYLOAD_LENGTH_16:
                        err = this.getPayloadLength16();
                        break;
                    case GET_PAYLOAD_LENGTH_64:
                        err = this.getPayloadLength64();
                        break;
                    case GET_MASK:
                        this.getMask();
                        break;
                    case GET_DATA:
                        err = this.getData(cb);
                        break;
                    case INFLATING:
                        this._loop = false;
                        return;
                    default:
                        this._loop = false;
                        queueTask(()=>{
                            this._state = GET_INFO;
                            this.startLoop(cb);
                        });
                        return;
                }
            }while (this._loop)
            cb(err);
        }
        getInfo() {
            if (this._bufferedBytes < 2) {
                this._loop = false;
                return;
            }
            const buf = this.consume(2);
            if ((buf[0] & 0x30) !== 0x00) {
                this._loop = false;
                return error(RangeError, 'RSV2 and RSV3 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_2_3');
            }
            const compressed = (buf[0] & 0x40) === 0x40;
            if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
                this._loop = false;
                return error(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');
            }
            this._fin = (buf[0] & 0x80) === 0x80;
            this._opcode = buf[0] & 0x0f;
            this._payloadLength = buf[1] & 0x7f;
            if (this._opcode === 0x00) {
                if (compressed) {
                    this._loop = false;
                    return error(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');
                }
                if (!this._fragmented) {
                    this._loop = false;
                    return error(RangeError, 'invalid opcode 0', true, 1002, 'WS_ERR_INVALID_OPCODE');
                }
                this._opcode = this._fragmented;
            } else if (this._opcode === 0x01 || this._opcode === 0x02) {
                if (this._fragmented) {
                    this._loop = false;
                    return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, 'WS_ERR_INVALID_OPCODE');
                }
                this._compressed = compressed;
            } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
                if (!this._fin) {
                    this._loop = false;
                    return error(RangeError, 'FIN must be set', true, 1002, 'WS_ERR_EXPECTED_FIN');
                }
                if (compressed) {
                    this._loop = false;
                    return error(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');
                }
                if (this._payloadLength > 0x7d || this._opcode === 0x08 && this._payloadLength === 1) {
                    this._loop = false;
                    return error(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, 'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH');
                }
            } else {
                this._loop = false;
                return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, 'WS_ERR_INVALID_OPCODE');
            }
            if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
            this._masked = (buf[1] & 0x80) === 0x80;
            if (this._isServer) {
                if (!this._masked) {
                    this._loop = false;
                    return error(RangeError, 'MASK must be set', true, 1002, 'WS_ERR_EXPECTED_MASK');
                }
            } else if (this._masked) {
                this._loop = false;
                return error(RangeError, 'MASK must be clear', true, 1002, 'WS_ERR_UNEXPECTED_MASK');
            }
            if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
            else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
            else return this.haveLength();
        }
        getPayloadLength16() {
            if (this._bufferedBytes < 2) {
                this._loop = false;
                return;
            }
            this._payloadLength = this.consume(2).readUInt16BE(0);
            return this.haveLength();
        }
        getPayloadLength64() {
            if (this._bufferedBytes < 8) {
                this._loop = false;
                return;
            }
            const buf = this.consume(8);
            const num = buf.readUInt32BE(0);
            if (num > Math.pow(2, 53 - 32) - 1) {
                this._loop = false;
                return error(RangeError, 'Unsupported WebSocket frame: payload length > 2^53 - 1', false, 1009, 'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH');
            }
            this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
            return this.haveLength();
        }
        haveLength() {
            if (this._payloadLength && this._opcode < 0x08) {
                this._totalPayloadLength += this._payloadLength;
                if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
                    this._loop = false;
                    return error(RangeError, 'Max payload size exceeded', false, 1009, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH');
                }
            }
            if (this._masked) this._state = GET_MASK;
            else this._state = GET_DATA;
        }
        getMask() {
            if (this._bufferedBytes < 4) {
                this._loop = false;
                return;
            }
            this._mask = this.consume(4);
            this._state = GET_DATA;
        }
        getData(cb) {
            let data = EMPTY_BUFFER;
            if (this._payloadLength) {
                if (this._bufferedBytes < this._payloadLength) {
                    this._loop = false;
                    return;
                }
                data = this.consume(this._payloadLength);
                if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
                    unmask(data, this._mask);
                }
            }
            if (this._opcode > 0x07) return this.controlMessage(data);
            if (this._compressed) {
                this._state = INFLATING;
                this.decompress(data, cb);
                return;
            }
            if (data.length) {
                this._messageLength = this._totalPayloadLength;
                this._fragments.push(data);
            }
            return this.dataMessage();
        }
        decompress(data, cb) {
            const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
            perMessageDeflate.decompress(data, this._fin, (err, buf)=>{
                if (err) return cb(err);
                if (buf.length) {
                    this._messageLength += buf.length;
                    if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
                        return cb(error(RangeError, 'Max payload size exceeded', false, 1009, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'));
                    }
                    this._fragments.push(buf);
                }
                const er = this.dataMessage();
                if (er) return cb(er);
                this.startLoop(cb);
            });
        }
        dataMessage() {
            if (this._fin) {
                const messageLength = this._messageLength;
                const fragments = this._fragments;
                this._totalPayloadLength = 0;
                this._messageLength = 0;
                this._fragmented = 0;
                this._fragments = [];
                if (this._opcode === 2) {
                    let data;
                    if (this._binaryType === 'nodebuffer') {
                        data = concat(fragments, messageLength);
                    } else if (this._binaryType === 'arraybuffer') {
                        data = toArrayBuffer(concat(fragments, messageLength));
                    } else {
                        data = fragments;
                    }
                    this.emit('message', data, true);
                } else {
                    const buf = concat(fragments, messageLength);
                    if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
                        this._loop = false;
                        return error(Error, 'invalid UTF-8 sequence', true, 1007, 'WS_ERR_INVALID_UTF8');
                    }
                    this.emit('message', buf, false);
                }
            }
            this._state = WAIT_MICROTASK;
        }
        controlMessage(data) {
            if (this._opcode === 0x08) {
                this._loop = false;
                if (data.length === 0) {
                    this.emit('conclude', 1005, EMPTY_BUFFER);
                    this.end();
                    this._state = GET_INFO;
                } else {
                    const code = data.readUInt16BE(0);
                    if (!isValidStatusCode(code)) {
                        return error(RangeError, `invalid status code ${code}`, true, 1002, 'WS_ERR_INVALID_CLOSE_CODE');
                    }
                    const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);
                    if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
                        return error(Error, 'invalid UTF-8 sequence', true, 1007, 'WS_ERR_INVALID_UTF8');
                    }
                    this.emit('conclude', code, buf);
                    this.end();
                    this._state = GET_INFO;
                }
            } else if (this._opcode === 0x09) {
                this.emit('ping', data);
                this._state = WAIT_MICROTASK;
            } else {
                this.emit('pong', data);
                this._state = WAIT_MICROTASK;
            }
        }
    }
    module.exports = Receiver;
    function error(ErrorCtor, message, prefix, statusCode, errorCode) {
        const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
        Error.captureStackTrace(err, error);
        err.code = errorCode;
        err[kStatusCode] = statusCode;
        return err;
    }
    function queueMicrotaskShim(cb) {
        promise.then(cb).catch(throwErrorNextTick);
    }
    function throwError(err) {
        throw err;
    }
    function throwErrorNextTick(err) {
        process.nextTick(throwError, err);
    }
}
,
"a62bfdde":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const { stringify } = farmRequire("22ca6445", true);
    const { outputFile } = farmRequire("f69bc856", true);
    async function outputJson(file, data, options = {}) {
        const str = stringify(data, options);
        await outputFile(file, str, options);
    }
    module.exports = outputJson;
}
,
"a785a22a":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const DOTENV_SUBSTITUTION_REGEX = /(\\)?(\$)(?!\()(\{?)([\w.]+)(?::?-((?:\$\{(?:\$\{(?:\$\{[^}]*\}|[^}])*}|[^}])*}|[^}])+))?(\}?)/gi;
    function _resolveEscapeSequences(value) {
        return value.replace(/\\\$/g, '$');
    }
    function interpolate(value, processEnv, parsed) {
        return value.replace(DOTENV_SUBSTITUTION_REGEX, (match, escaped, dollarSign, openBrace, key, defaultValue, closeBrace)=>{
            if (escaped === '\\') {
                return match.slice(1);
            } else {
                if (processEnv[key]) {
                    if (processEnv[key] === parsed[key]) {
                        return processEnv[key];
                    } else {
                        return interpolate(processEnv[key], processEnv, parsed);
                    }
                }
                if (parsed[key]) {
                    if (parsed[key] === value) {
                        return parsed[key];
                    } else {
                        return interpolate(parsed[key], processEnv, parsed);
                    }
                }
                if (defaultValue) {
                    if (defaultValue.startsWith('$')) {
                        return interpolate(defaultValue, processEnv, parsed);
                    } else {
                        return defaultValue;
                    }
                }
                return '';
            }
        });
    }
    function expand(options) {
        let processEnv = process.env;
        if (options && options.processEnv != null) {
            processEnv = options.processEnv;
        }
        for(const key in options.parsed){
            let value = options.parsed[key];
            const inProcessEnv = Object.prototype.hasOwnProperty.call(processEnv, key);
            if (inProcessEnv) {
                if (processEnv[key] === options.parsed[key]) {
                    value = interpolate(value, processEnv, options.parsed);
                } else {
                    value = processEnv[key];
                }
            } else {
                value = interpolate(value, processEnv, options.parsed);
            }
            options.parsed[key] = _resolveEscapeSequences(value);
        }
        for(const processKey in options.parsed){
            processEnv[processKey] = options.parsed[processKey];
        }
        return options;
    }
    module.exports.expand = expand;
}
,
"a91e6b44":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.createDirentFromStats = void 0;
    class DirentFromStats {
        constructor(name, stats){
            this.name = name;
            this.isBlockDevice = stats.isBlockDevice.bind(stats);
            this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
            this.isDirectory = stats.isDirectory.bind(stats);
            this.isFIFO = stats.isFIFO.bind(stats);
            this.isFile = stats.isFile.bind(stats);
            this.isSocket = stats.isSocket.bind(stats);
            this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
        }
    }
    function createDirentFromStats(name, stats) {
        return new DirentFromStats(name, stats);
    }
    exports.createDirentFromStats = createDirentFromStats;
}
,
"a9271465":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.fs = void 0;
    const fs = farmRequire("a91e6b44", true);
    exports.fs = fs;
}
,
"a9709252":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const path = global.nodeRequire('path', true);
    const childProcess = global.nodeRequire('child_process', true);
    const crossSpawn = farmRequire("8871c848", true);
    const stripFinalNewline = farmRequire("2ab36b81", true);
    const npmRunPath = farmRequire("cb79b35f", true);
    const onetime = farmRequire("2e00eeca", true);
    const makeError = farmRequire("d2f32a4d", true);
    const normalizeStdio = farmRequire("6f03e0ed", true);
    const { spawnedKill, spawnedCancel, setupTimeout, validateTimeout, setExitHandler } = farmRequire("37c97648", true);
    const { handleInput, getSpawnedResult, makeAllStream, validateInputSync } = farmRequire("1d931b02", true);
    const { mergePromise, getSpawnedPromise } = farmRequire("f6aa6113", true);
    const { joinCommand, parseCommand, getEscapedCommand } = farmRequire("922e32a0", true);
    const DEFAULT_MAX_BUFFER = 1000 * 1000 * 100;
    const getEnv = ({ env: envOption, extendEnv, preferLocal, localDir, execPath })=>{
        const env = extendEnv ? {
            ...process.env,
            ...envOption
        } : envOption;
        if (preferLocal) {
            return npmRunPath.env({
                env,
                cwd: localDir,
                execPath
            });
        }
        return env;
    };
    const handleArguments = (file, args, options = {})=>{
        const parsed = crossSpawn._parse(file, args, options);
        file = parsed.command;
        args = parsed.args;
        options = parsed.options;
        options = {
            maxBuffer: DEFAULT_MAX_BUFFER,
            buffer: true,
            stripFinalNewline: true,
            extendEnv: true,
            preferLocal: false,
            localDir: options.cwd || process.cwd(),
            execPath: process.execPath,
            encoding: 'utf8',
            reject: true,
            cleanup: true,
            all: false,
            windowsHide: true,
            ...options
        };
        options.env = getEnv(options);
        options.stdio = normalizeStdio(options);
        if (process.platform === 'win32' && path.basename(file, '.exe') === 'cmd') {
            args.unshift('/q');
        }
        return {
            file,
            args,
            options,
            parsed
        };
    };
    const handleOutput = (options, value, error)=>{
        if (typeof value !== 'string' && !Buffer.isBuffer(value)) {
            return error === undefined ? undefined : '';
        }
        if (options.stripFinalNewline) {
            return stripFinalNewline(value);
        }
        return value;
    };
    const execa = (file, args, options)=>{
        const parsed = handleArguments(file, args, options);
        const command = joinCommand(file, args);
        const escapedCommand = getEscapedCommand(file, args);
        validateTimeout(parsed.options);
        let spawned;
        try {
            spawned = childProcess.spawn(parsed.file, parsed.args, parsed.options);
        } catch (error) {
            const dummySpawned = new childProcess.ChildProcess();
            const errorPromise = Promise.reject(makeError({
                error,
                stdout: '',
                stderr: '',
                all: '',
                command,
                escapedCommand,
                parsed,
                timedOut: false,
                isCanceled: false,
                killed: false
            }));
            return mergePromise(dummySpawned, errorPromise);
        }
        const spawnedPromise = getSpawnedPromise(spawned);
        const timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);
        const processDone = setExitHandler(spawned, parsed.options, timedPromise);
        const context = {
            isCanceled: false
        };
        spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));
        spawned.cancel = spawnedCancel.bind(null, spawned, context);
        const handlePromise = async ()=>{
            const [{ error, exitCode, signal, timedOut }, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone);
            const stdout = handleOutput(parsed.options, stdoutResult);
            const stderr = handleOutput(parsed.options, stderrResult);
            const all = handleOutput(parsed.options, allResult);
            if (error || exitCode !== 0 || signal !== null) {
                const returnedError = makeError({
                    error,
                    exitCode,
                    signal,
                    stdout,
                    stderr,
                    all,
                    command,
                    escapedCommand,
                    parsed,
                    timedOut,
                    isCanceled: context.isCanceled,
                    killed: spawned.killed
                });
                if (!parsed.options.reject) {
                    return returnedError;
                }
                throw returnedError;
            }
            return {
                command,
                escapedCommand,
                exitCode: 0,
                stdout,
                stderr,
                all,
                failed: false,
                timedOut: false,
                isCanceled: false,
                killed: false
            };
        };
        const handlePromiseOnce = onetime(handlePromise);
        handleInput(spawned, parsed.options.input);
        spawned.all = makeAllStream(spawned, parsed.options);
        return mergePromise(spawned, handlePromiseOnce);
    };
    module.exports = execa;
    module.exports.sync = (file, args, options)=>{
        const parsed = handleArguments(file, args, options);
        const command = joinCommand(file, args);
        const escapedCommand = getEscapedCommand(file, args);
        validateInputSync(parsed.options);
        let result;
        try {
            result = childProcess.spawnSync(parsed.file, parsed.args, parsed.options);
        } catch (error) {
            throw makeError({
                error,
                stdout: '',
                stderr: '',
                all: '',
                command,
                escapedCommand,
                parsed,
                timedOut: false,
                isCanceled: false,
                killed: false
            });
        }
        const stdout = handleOutput(parsed.options, result.stdout, result.error);
        const stderr = handleOutput(parsed.options, result.stderr, result.error);
        if (result.error || result.status !== 0 || result.signal !== null) {
            const error = makeError({
                stdout,
                stderr,
                error: result.error,
                signal: result.signal,
                exitCode: result.status,
                command,
                escapedCommand,
                parsed,
                timedOut: result.error && result.error.code === 'ETIMEDOUT',
                isCanceled: false,
                killed: result.signal !== null
            });
            if (!parsed.options.reject) {
                return error;
            }
            throw error;
        }
        return {
            command,
            escapedCommand,
            exitCode: 0,
            stdout,
            stderr,
            failed: false,
            timedOut: false,
            isCanceled: false,
            killed: false
        };
    };
    module.exports.command = (command, options)=>{
        const [file, ...args] = parseCommand(command);
        return execa(file, args, options);
    };
    module.exports.commandSync = (command, options)=>{
        const [file, ...args] = parseCommand(command);
        return execa.sync(file, args, options);
    };
    module.exports.node = (scriptPath, args, options = {})=>{
        if (args && !Array.isArray(args) && typeof args === 'object') {
            options = args;
            args = [];
        }
        const stdio = normalizeStdio.node(options);
        const defaultExecArgv = process.execArgv.filter((arg)=>!arg.startsWith('--inspect'));
        const { nodePath = process.execPath, nodeOptions = defaultExecArgv } = options;
        return execa(nodePath, [
            ...nodeOptions,
            scriptPath,
            ...Array.isArray(args) ? args : []
        ], {
            ...options,
            stdin: undefined,
            stdout: undefined,
            stderr: undefined,
            stdio,
            shell: false
        });
    };
}
,
"aa04e221":function  (module, exports, farmRequire, farmDynamicRequire) {
    const tty = global.nodeRequire('tty', true);
    const util = global.nodeRequire('util', true);
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util.deprecate(()=>{}, 'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    exports.colors = [
        6,
        2,
        3,
        4,
        5,
        1
    ];
    try {
        const supportsColor = farmRequire("6d9407b3", true);
        if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
            exports.colors = [
                20,
                21,
                26,
                27,
                32,
                33,
                38,
                39,
                40,
                41,
                42,
                43,
                44,
                45,
                56,
                57,
                62,
                63,
                68,
                69,
                74,
                75,
                76,
                77,
                78,
                79,
                80,
                81,
                92,
                93,
                98,
                99,
                112,
                113,
                128,
                129,
                134,
                135,
                148,
                149,
                160,
                161,
                162,
                163,
                164,
                165,
                166,
                167,
                168,
                169,
                170,
                171,
                172,
                173,
                178,
                179,
                184,
                185,
                196,
                197,
                198,
                199,
                200,
                201,
                202,
                203,
                204,
                205,
                206,
                207,
                208,
                209,
                214,
                215,
                220,
                221
            ];
        }
    } catch (error) {}
    exports.inspectOpts = Object.keys(process.env).filter((key)=>{
        return /^debug_/i.test(key);
    }).reduce((obj, key)=>{
        const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k)=>{
            return k.toUpperCase();
        });
        let val = process.env[key];
        if (/^(yes|on|true|enabled)$/i.test(val)) {
            val = true;
        } else if (/^(no|off|false|disabled)$/i.test(val)) {
            val = false;
        } else if (val === 'null') {
            val = null;
        } else {
            val = Number(val);
        }
        obj[prop] = val;
        return obj;
    }, {});
    function useColors() {
        return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
        const { namespace: name, useColors } = this;
        if (useColors) {
            const c = this.color;
            const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
            const prefix = `  ${colorCode};1m${name} \u001B[0m`;
            args[0] = prefix + args[0].split('\n').join('\n' + prefix);
            args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
        } else {
            args[0] = getDate() + name + ' ' + args[0];
        }
    }
    function getDate() {
        if (exports.inspectOpts.hideDate) {
            return '';
        }
        return new Date().toISOString() + ' ';
    }
    function log(...args) {
        return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + '\n');
    }
    function save(namespaces) {
        if (namespaces) {
            process.env.DEBUG = namespaces;
        } else {
            delete process.env.DEBUG;
        }
    }
    function load() {
        return process.env.DEBUG;
    }
    function init(debug) {
        debug.inspectOpts = {};
        const keys = Object.keys(exports.inspectOpts);
        for(let i = 0; i < keys.length; i++){
            debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
        }
    }
    module.exports = farmRequire("1c65495a")(exports);
    const { formatters } = module.exports;
    formatters.o = function(v) {
        this.inspectOpts.colors = this.useColors;
        return util.inspect(v, this.inspectOpts).split('\n').map((str)=>str.trim()).join(' ');
    };
    formatters.O = function(v) {
        this.inspectOpts.colors = this.useColors;
        return util.inspect(v, this.inspectOpts);
    };
}
,
"aa096847":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "resourcesMiddleware", ()=>resourcesMiddleware);
    module.o(exports, "resources", ()=>resources);
    var _f_node_fs = farmRequire('node:fs');
    var _f_node_path = module.w(farmRequire('node:path'));
    var _f_koa_static = module.i(farmRequire("c0be1d25"));
    var _f_index = farmRequire("65ad6846");
    function normalizePathByPublicPath(publicPath, resourcePath) {
        const base = publicPath.match(/^https?:\/\//) ? '' : publicPath;
        let resourceWithoutPublicPath = resourcePath;
        if (base && resourcePath.startsWith(base)) {
            resourcePath = resourcePath.replace(new RegExp(`([^/]+)${base}`), '$1/');
            resourceWithoutPublicPath = resourcePath.slice(base.length);
        }
        return {
            resourceWithoutPublicPath,
            fullPath: resourcePath
        };
    }
    function outputFilesMiddleware(compiler) {
        return async (ctx, next)=>{
            if (ctx.path === '/_output_files') {
                const files = Object.keys(compiler.resources()).sort();
                const fileTree = _f_index.generateFileTree(files);
                ctx.type = '.html';
                ctx.body = _f_index.generateFileTreeHtml(fileTree);
            } else {
                await next();
            }
        };
    }
    function findResource(paths, compiler, publicPath) {
        for (const resourcePath of new Set(paths)){
            const { resourceWithoutPublicPath } = normalizePathByPublicPath(publicPath, resourcePath);
            const resource = compiler.resource(resourceWithoutPublicPath);
            if (resource) {
                return {
                    resource,
                    resourcePath: resourceWithoutPublicPath,
                    rawPath: resourcePath
                };
            }
        }
    }
    function resourcesMiddleware(compiler, serverContext) {
        return async (ctx, next)=>{
            await next();
            if (ctx.method !== 'HEAD' && ctx.method !== 'GET') return;
            const hasHtmlPathWithPublicDir = module.f(_f_node_path).resolve(serverContext.publicDir, 'index.html');
            let isSkipPublicHtml;
            if (ctx.body instanceof _f_node_fs.ReadStream) {
                const readStream = ctx.body;
                isSkipPublicHtml = readStream.path === hasHtmlPathWithPublicDir;
            }
            if ((ctx.body || ctx.status !== 404) && !isSkipPublicHtml) return;
            const { config, publicPath } = serverContext;
            if (compiler.compiling) {
                await new Promise((resolve)=>{
                    compiler.onUpdateFinish(()=>resolve(undefined));
                });
            }
            const url = ctx.url?.slice(1) || 'index.html';
            let stripQueryAndHashUrl = _f_index.stripQueryAndHash(url);
            const resourceResult = findResource([
                url,
                stripQueryAndHashUrl
            ], compiler, publicPath);
            if (resourceResult === true) {
                return;
            }
            if (resourceResult) {
                ctx.type = _f_node_path.extname(ctx?.path?.slice?.(1) || 'index.html');
                ctx.body = resourceResult.resource;
                return;
            }
            const { fullPath, resourceWithoutPublicPath } = normalizePathByPublicPath(publicPath, stripQueryAndHashUrl);
            {
                const absPath = module.f(_f_node_path).join(compiler.config.config.root, resourceWithoutPublicPath);
                if (_f_node_fs.existsSync(absPath) && _f_node_fs.statSync(absPath).isFile()) {
                    ctx.type = _f_node_path.extname(fullPath);
                    ctx.body = _f_node_fs.readFileSync(absPath);
                    return;
                }
                const absPathPublicDir = module.f(_f_node_path).resolve(compiler.config.config.root, compiler.config.config.assets.publicDir, resourceWithoutPublicPath);
                if (_f_node_fs.existsSync(absPathPublicDir) && _f_node_fs.statSync(absPathPublicDir).isFile()) {
                    ctx.type = _f_node_path.extname(fullPath);
                    ctx.body = _f_node_fs.readFileSync(absPathPublicDir);
                    return;
                }
            }
            {
                if (!ctx.accepts('html')) {
                    ctx.status = 404;
                } else if (config.spa !== false) {
                    const pathComps = resourceWithoutPublicPath.split('/');
                    while(pathComps.length > 0){
                        const pathStr = pathComps.join('/') + '.html';
                        const resource = compiler.resources()[pathStr];
                        if (resource) {
                            ctx.type = '.html';
                            ctx.body = resource;
                            return;
                        }
                        pathComps.pop();
                    }
                    const indexHtml = compiler.resources()['index.html'];
                    if (indexHtml) {
                        ctx.type = '.html';
                        ctx.body = indexHtml;
                        return;
                    }
                } else {
                    ctx.status = 404;
                }
            }
        };
    }
    function resources(devSeverContext) {
        const middlewares = [
            outputFilesMiddleware(devSeverContext.getCompiler())
        ];
        if (!devSeverContext.config.writeToDisk) {
            middlewares.push(resourcesMiddleware(devSeverContext.getCompiler(), devSeverContext));
        } else {
            middlewares.push(module.f(_f_koa_static)(devSeverContext.getCompiler().config.config.output.path, {
                extensions: [
                    'html'
                ]
            }));
        }
        middlewares.push(module.f(_f_koa_static)(devSeverContext.publicDir));
        return middlewares;
    }
}
,
"aad46893":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const path = global.nodeRequire('path', true);
    module.exports.checkPath = function checkPath(pth) {
        if (process.platform === 'win32') {
            const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path.parse(pth).root, ''));
            if (pathHasInvalidWinCharacters) {
                const error = new Error(`Path contains invalid characters: ${pth}`);
                error.code = 'EINVAL';
                throw error;
            }
        }
    };
}
,
"abc9f14f":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "getRealtimeSignals", ()=>getRealtimeSignals);
    module.o(exports, "SIGRTMAX", ()=>SIGRTMAX);
    var getRealtimeSignals = ()=>{
        const length = SIGRTMAX - SIGRTMIN + 1;
        return Array.from({
            length
        }, getRealtimeSignal);
    };
    const getRealtimeSignal = (value, index)=>({
            name: `SIGRT${index + 1}`,
            number: SIGRTMIN + index,
            action: "terminate",
            description: "Application-specific signal (realtime)",
            standard: "posix"
        });
    const SIGRTMIN = 34;
    var SIGRTMAX = 64;
}
,
"abdb8a71":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const u = farmRequire("712c2dd4", true).fromPromise;
    const { makeDir: _makeDir, makeDirSync } = farmRequire("a4820a3f", true);
    const makeDir = u(_makeDir);
    module.exports = {
        mkdirs: makeDir,
        mkdirsSync: makeDirSync,
        mkdirp: makeDir,
        mkdirpSync: makeDirSync,
        ensureDir: makeDir,
        ensureDirSync: makeDirSync
    };
}
,
"abea2f29":function  (module, exports, farmRequire, farmDynamicRequire) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (()=>{
        let warned = false;
        return ()=>{
            if (!warned) {
                warned = true;
                console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
            }
        };
    })();
    exports.colors = [
        '#0000CC',
        '#0000FF',
        '#0033CC',
        '#0033FF',
        '#0066CC',
        '#0066FF',
        '#0099CC',
        '#0099FF',
        '#00CC00',
        '#00CC33',
        '#00CC66',
        '#00CC99',
        '#00CCCC',
        '#00CCFF',
        '#3300CC',
        '#3300FF',
        '#3333CC',
        '#3333FF',
        '#3366CC',
        '#3366FF',
        '#3399CC',
        '#3399FF',
        '#33CC00',
        '#33CC33',
        '#33CC66',
        '#33CC99',
        '#33CCCC',
        '#33CCFF',
        '#6600CC',
        '#6600FF',
        '#6633CC',
        '#6633FF',
        '#66CC00',
        '#66CC33',
        '#9900CC',
        '#9900FF',
        '#9933CC',
        '#9933FF',
        '#99CC00',
        '#99CC33',
        '#CC0000',
        '#CC0033',
        '#CC0066',
        '#CC0099',
        '#CC00CC',
        '#CC00FF',
        '#CC3300',
        '#CC3333',
        '#CC3366',
        '#CC3399',
        '#CC33CC',
        '#CC33FF',
        '#CC6600',
        '#CC6633',
        '#CC9900',
        '#CC9933',
        '#CCCC00',
        '#CCCC33',
        '#FF0000',
        '#FF0033',
        '#FF0066',
        '#FF0099',
        '#FF00CC',
        '#FF00FF',
        '#FF3300',
        '#FF3333',
        '#FF3366',
        '#FF3399',
        '#FF33CC',
        '#FF33FF',
        '#FF6600',
        '#FF6633',
        '#FF9900',
        '#FF9933',
        '#FFCC00',
        '#FFCC33'
    ];
    function useColors() {
        if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
            return true;
        }
        if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
            return false;
        }
        let m;
        return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
        args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
        if (!this.useColors) {
            return;
        }
        const c = 'color: ' + this.color;
        args.splice(1, 0, c, 'color: inherit');
        let index = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match)=>{
            if (match === '%%') {
                return;
            }
            index++;
            if (match === '%c') {
                lastC = index;
            }
        });
        args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (()=>{});
    function save(namespaces) {
        try {
            if (namespaces) {
                exports.storage.setItem('debug', namespaces);
            } else {
                exports.storage.removeItem('debug');
            }
        } catch (error) {}
    }
    function load() {
        let r;
        try {
            r = exports.storage.getItem('debug');
        } catch (error) {}
        if (!r && typeof process !== 'undefined' && 'env' in process) {
            r = process.env.DEBUG;
        }
        return r;
    }
    function localstorage() {
        try {
            return localStorage;
        } catch (error) {}
    }
    module.exports = farmRequire("1c65495a")(exports);
    const { formatters } = module.exports;
    formatters.j = function(v) {
        try {
            return JSON.stringify(v);
        } catch (error) {
            return '[UnexpectedJSONParseError]: ' + error.message;
        }
    };
}
,
"ac30203e":function  (module, exports, farmRequire, farmDynamicRequire) {
    var debug;
    module.exports = function() {
        if (!debug) {
            try {
                debug = farmRequire("50d83445")("follow-redirects");
            } catch (error) {}
            if (typeof debug !== "function") {
                debug = function() {};
            }
        }
        debug.apply(null, arguments);
    };
}
,
"ac7fb814":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "default", ()=>titleize);
    function titleize(string) {
        if (typeof string !== 'string') {
            throw new TypeError('Expected a string');
        }
        return string.toLowerCase().replace(/(?:^|\s|-)\S/g, (x)=>x.toUpperCase());
    }
}
,
"ac9f1e68":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "generateFileTree", ()=>generateFileTree);
    module.o(exports, "buildFileTreeHtml", ()=>buildFileTreeHtml);
    module.o(exports, "generateFileTreeHtml", ()=>generateFileTreeHtml);
    module.o(exports, "ERR_SYMLINK_IN_RECURSIVE_READDIR", ()=>ERR_SYMLINK_IN_RECURSIVE_READDIR);
    module.o(exports, "recursiveReaddir", ()=>recursiveReaddir);
    var _f_fs = module.i(farmRequire('fs'));
    var _f_promises = module.i(farmRequire('node:fs/promises'));
    var _f_path = module.i(farmRequire('path'));
    var _f_share = farmRequire("bc6cc539");
    function generateFileTree(files) {
        const fileTree = [];
        for (const file of files){
            const parts = file.split('/');
            let currentNode = fileTree;
            for(let i = 0; i < parts.length; i++){
                const part = parts[i];
                const existingNode = currentNode.find((node)=>node.name === part);
                if (existingNode) {
                    currentNode = existingNode.children;
                } else {
                    const newNode = {
                        isLeaf: i === parts.length - 1,
                        name: part,
                        children: []
                    };
                    currentNode.push(newNode);
                    currentNode = newNode.children;
                }
            }
        }
        return fileTree;
    }
    function buildFileTreeHtml(node) {
        let html = '';
        for (const fileNode of node){
            const { isLeaf, name, children } = fileNode;
            const indent = isLeaf ? '- ' : '|---- ';
            const path = name.replace(/ /g, '%20');
            html += `<div>${indent}<a href="${path}">${name}</a></div>`;
            if (!isLeaf) {
                html += buildFileTreeHtml(children).replace(/^/gm, '&nbsp;&nbsp;&nbsp;&nbsp;');
            }
        }
        return html;
    }
    function generateFileTreeHtml(node) {
        return `
      <!DOCTYPE html>
      <html lang="">
        <head>
          <meta charset="utf-8">
          <meta http-equiv="X-UA-Compatible" content="IE=edge">
          <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">
          <title>Out Files</title>
        </head>
        <body>
          <!-- file tree-->
         <div>${buildFileTreeHtml(node)}</div>
        </body>
      </html>
      `;
    }
    var ERR_SYMLINK_IN_RECURSIVE_READDIR = 'ERR_SYMLINK_IN_RECURSIVE_READDIR';
    async function recursiveReaddir(dir) {
        if (!module.f(_f_fs).existsSync(dir)) {
            return [];
        }
        let directs;
        try {
            directs = await module.f(_f_promises).readdir(dir, {
                withFileTypes: true
            });
        } catch (e) {
            if (e.code === 'EACCES') {
                return [];
            }
            throw e;
        }
        if (directs.some((dirent)=>dirent.isSymbolicLink())) {
            const err = new Error('Symbolic links are not supported in recursiveReaddir');
            err.code = ERR_SYMLINK_IN_RECURSIVE_READDIR;
            throw err;
        }
        const files = await Promise.all(directs.map((dirent)=>{
            const res = module.f(_f_path).resolve(dir, dirent.name);
            return dirent.isDirectory() ? recursiveReaddir(res) : _f_share.normalizePath(res);
        }));
        return files.flat(1);
    }
}
,
"ace053e8":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.fixRequestBody = exports.responseInterceptor = void 0;
    var response_interceptor_1 = farmRequire("0da0eee3", true);
    Object.defineProperty(exports, "responseInterceptor", {
        enumerable: true,
        get: function() {
            return response_interceptor_1.responseInterceptor;
        }
    });
    var fix_request_body_1 = farmRequire("f3639a9d", true);
    Object.defineProperty(exports, "fixRequestBody", {
        enumerable: true,
        get: function() {
            return fix_request_body_1.fixRequestBody;
        }
    });
}
,
"ace5e05a":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "makeError", ()=>makeError);
    var _f_node_process = module.i(farmRequire('node:process'));
    var _f_human_signals = farmRequire("8aa22968");
    const getErrorPrefix = ({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled })=>{
        if (timedOut) {
            return `timed out after ${timeout} milliseconds`;
        }
        if (isCanceled) {
            return 'was canceled';
        }
        if (errorCode !== undefined) {
            return `failed with ${errorCode}`;
        }
        if (signal !== undefined) {
            return `was killed with ${signal} (${signalDescription})`;
        }
        if (exitCode !== undefined) {
            return `failed with exit code ${exitCode}`;
        }
        return 'failed';
    };
    var makeError = ({ stdout, stderr, all, error, signal, exitCode, command, escapedCommand, timedOut, isCanceled, killed, parsed: { options: { timeout, cwd = module.f(_f_node_process).cwd() } } })=>{
        exitCode = exitCode === null ? undefined : exitCode;
        signal = signal === null ? undefined : signal;
        const signalDescription = signal === undefined ? undefined : _f_human_signals.signalsByName[signal].description;
        const errorCode = error && error.code;
        const prefix = getErrorPrefix({
            timedOut,
            timeout,
            errorCode,
            signal,
            signalDescription,
            exitCode,
            isCanceled
        });
        const execaMessage = `Command ${prefix}: ${command}`;
        const isError = Object.prototype.toString.call(error) === '[object Error]';
        const shortMessage = isError ? `${execaMessage}\n${error.message}` : execaMessage;
        const message = [
            shortMessage,
            stderr,
            stdout
        ].filter(Boolean).join('\n');
        if (isError) {
            error.originalMessage = error.message;
            error.message = message;
        } else {
            error = new Error(message);
        }
        error.shortMessage = shortMessage;
        error.command = command;
        error.escapedCommand = escapedCommand;
        error.exitCode = exitCode;
        error.signal = signal;
        error.signalDescription = signalDescription;
        error.stdout = stdout;
        error.stderr = stderr;
        error.cwd = cwd;
        if (all !== undefined) {
            error.all = all;
        }
        if ('bufferedData' in error) {
            delete error.bufferedData;
        }
        error.failed = true;
        error.timedOut = Boolean(timedOut);
        error.isCanceled = isCanceled;
        error.killed = killed && !timedOut;
        return error;
    };
}
,
"acf9ef2b":/*!
 * ee-first
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    module.exports = first;
    function first(stuff, done) {
        if (!Array.isArray(stuff)) throw new TypeError('arg must be an array of [ee, events...] arrays');
        var cleanups = [];
        for(var i = 0; i < stuff.length; i++){
            var arr = stuff[i];
            if (!Array.isArray(arr) || arr.length < 2) throw new TypeError('each array member must be [ee, events...]');
            var ee = arr[0];
            for(var j = 1; j < arr.length; j++){
                var event = arr[j];
                var fn = listener(event, callback);
                ee.on(event, fn);
                cleanups.push({
                    ee: ee,
                    event: event,
                    fn: fn
                });
            }
        }
        function callback() {
            cleanup();
            done.apply(null, arguments);
        }
        function cleanup() {
            var x;
            for(var i = 0; i < cleanups.length; i++){
                x = cleanups[i];
                x.ee.removeListener(x.event, x.fn);
            }
        }
        function thunk(fn) {
            done = fn;
        }
        thunk.cancel = cleanup;
        return thunk;
    }
    function listener(event, done) {
        return function onevent(arg1) {
            var args = new Array(arguments.length);
            var ee = this;
            var err = event === 'error' ? arg1 : null;
            for(var i = 0; i < args.length; i++){
                args[i] = arguments[i];
            }
            done(err, ee, event, args);
        };
    }
}
,
"ae13b92b":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "farmUserConfigToViteConfig", ()=>farmUserConfigToViteConfig);
    module.o(exports, "proxyViteConfig", ()=>proxyViteConfig);
    module.o(exports, "viteConfigToFarmConfig", ()=>viteConfigToFarmConfig);
    var _f_merge = module.i(farmRequire("c074a41a"));
    var _f_constants = farmRequire("28e36a2d");
    var _f_utils = farmRequire("e60815f7");
    function farmUserConfigToViteConfig(config) {
        const vitePlugins = config.vitePlugins.filter(Boolean).map((plugin)=>{
            if (typeof plugin === 'function') {
                return plugin().vitePlugin;
            } else {
                return plugin;
            }
        });
        let sourcemap = true;
        if (config.compilation?.sourcemap !== undefined) {
            sourcemap = Boolean(config.compilation?.sourcemap);
        }
        const viteConfig = {
            root: config.root,
            base: config.compilation?.output?.publicPath ?? '/',
            publicDir: config.publicDir ?? 'public',
            mode: config.compilation?.mode,
            define: config.compilation?.define,
            command: config.compilation?.mode === 'production' ? 'build' : 'serve',
            resolve: {
                alias: config.compilation?.resolve?.alias,
                extensions: config.compilation?.resolve?.extensions,
                mainFields: config.compilation?.resolve?.mainFields,
                conditions: config.compilation?.resolve?.conditions,
                preserveSymlinks: config.compilation?.resolve?.symlinks === false,
                dedupe: config.compilation?.resolve?.dedupe
            },
            plugins: vitePlugins,
            server: {
                hmr: config.server?.hmr,
                port: config.server?.port,
                host: config.server?.host,
                strictPort: config.server?.strictPort,
                https: config.server?.https,
                proxy: config.server?.proxy,
                open: config.server?.open,
                watch: typeof config.server?.hmr === 'object' ? config.server.hmr?.watchOptions ?? {} : {}
            },
            isProduction: config.compilation?.mode === 'production',
            css: config.compilation?.css?._viteCssOptions ?? {},
            build: {
                outDir: config.compilation?.output?.path,
                sourcemap,
                minify: config.compilation?.minify !== undefined ? Boolean(config.compilation?.minify) : undefined,
                cssMinify: config.compilation?.minify !== undefined ? Boolean(config.compilation?.minify) : undefined,
                ssr: config.compilation?.output?.targetEnv === 'node',
                rollupOptions: {
                    output: {
                        assetFileNames: config.compilation?.output?.assetsFilename,
                        entryFileNames: config.compilation?.output?.entryFilename,
                        chunkFileNames: config.compilation?.output?.filename
                    }
                }
            },
            cacheDir: 'node_modules/.farm/cache',
            envDir: config.envDir,
            assetsInclude: [
                ..._f_constants.VITE_DEFAULT_ASSETS,
                ...config.compilation?.assets?.include ?? []
            ],
            experimental: {}
        };
        return viteConfig;
    }
    function getTargetField(target = {}, key, allowedKeys, contextInfo, getter) {
        if (typeof key !== 'string') {
            return target[key];
        }
        if (_f_constants.EXTERNAL_KEYS.includes(key)) {
            return target[key];
        }
        if (allowedKeys.includes(String(key))) {
            if (getter) {
                return getter(target, key);
            } else {
                return target[key];
            }
        }
        throw _f_utils.throwIncompatibleError(contextInfo.pluginName, contextInfo.keyName, allowedKeys, key);
    }
    function createProxyObj(pluginName, keyName, allowedKeys, obj = {}) {
        return new Proxy(obj || {}, {
            get (target, key) {
                return getTargetField(target, key, allowedKeys, {
                    pluginName,
                    keyName
                });
            }
        });
    }
    function mapResolve(pluginName, obj = {}) {
        const allowedResolveKeys = [
            'alias',
            'extensions',
            'mainFields',
            'conditions',
            'preserveSymlinks',
            'dedupe'
        ];
        return createProxyObj(pluginName, 'viteConfig.resolve', allowedResolveKeys, obj);
    }
    function mapServer(pluginName, obj = {}) {
        const allowedServerKeys = [
            'hmr',
            'port',
            'host',
            'strictPort',
            'https',
            'proxy',
            'open',
            'origin',
            'watch'
        ];
        return createProxyObj(pluginName, 'viteConfig.server', allowedServerKeys, obj);
    }
    function mapCss(pluginName, obj = {}) {
        const allowedCssKeys = [
            'devSourcemap',
            'transformer',
            'modules',
            'postcss',
            'preprocessorOptions'
        ];
        return createProxyObj(pluginName, 'viteConfig.css', allowedCssKeys, obj);
    }
    function mapBuild(pluginName, obj = {}) {
        const allowedBuildKeys = [
            'outDir',
            'sourcemap',
            'minify',
            'cssMinify',
            'ssr',
            'watch',
            'rollupOptions',
            'assetsDir'
        ];
        return createProxyObj(pluginName, 'viteConfig.build', allowedBuildKeys, obj);
    }
    function proxyViteConfig(viteConfig, pluginName, logger) {
        return new Proxy(viteConfig, {
            get (target, key) {
                const allowedKeys = [
                    'root',
                    'base',
                    'publicDir',
                    'mode',
                    'define',
                    'command',
                    'resolve',
                    'plugins',
                    'server',
                    'isProduction',
                    'css',
                    'build',
                    'logger',
                    'cacheDir',
                    'envDir',
                    'assetsInclude',
                    'legacy',
                    'optimizeDeps',
                    'ssr',
                    'logLevel',
                    'experimental',
                    'test',
                    'clearScreen',
                    'customLogger',
                    'configFile',
                    'inlineConfig'
                ];
                return getTargetField(target, key, allowedKeys, {
                    pluginName,
                    keyName: 'viteConfig'
                }, (target, key)=>{
                    const keyMapper = {
                        resolve: mapResolve,
                        server: mapServer,
                        css: mapCss,
                        build: mapBuild,
                        optimizeDeps: (pluginName, obj = {})=>{
                            return new Proxy(obj || {}, {
                                get (_, optimizeDepsKey) {
                                    logger.warnOnce(`[vite-plugin] ${pluginName}: config "optimizeDeps" is not needed in farm, all of its options will be ignored. Current ignored option is: "${String(optimizeDepsKey)}"`);
                                    if (optimizeDepsKey === 'esbuildOptions') {
                                        return {};
                                    }
                                    return undefined;
                                }
                            });
                        },
                        logger: ()=>{
                            return logger;
                        },
                        assetsInclude: ()=>{
                            return (filename)=>{
                                return viteConfig.assetsInclude?.some((r)=>{
                                    return new RegExp(r).test(filename);
                                }) ?? false;
                            };
                        }
                    };
                    return keyMapper[key] ? keyMapper[key](pluginName, target[key]) : target[key];
                });
            }
        });
    }
    function viteConfigToFarmConfig(config, origFarmConfig, _pluginName) {
        const farmConfig = {
            compilation: {}
        };
        if (config.root) {
            farmConfig.root = config.root;
        }
        if (config?.css) {
            farmConfig.compilation.css ??= {};
            farmConfig.compilation.css._viteCssOptions = config.css;
        }
        if (config.base) {
            farmConfig.compilation.output ??= {};
            farmConfig.compilation.output.publicPath = config.base;
        }
        if (config.publicDir) {
            farmConfig.publicDir = config.publicDir;
        }
        if (config.mode === 'development' || config.mode === 'production') {
            farmConfig.compilation.mode = config.mode;
        }
        if (config.define) {
            farmConfig.compilation.define = config.define;
        }
        if (config.resolve) {
            farmConfig.compilation.resolve ??= {};
            if (config.resolve.alias) {
                if (!Array.isArray(config.resolve.alias)) {
                    farmConfig.compilation.resolve.alias = config.resolve.alias;
                } else {
                    if (!farmConfig.compilation.resolve.alias) {
                        farmConfig.compilation.resolve.alias = {};
                    }
                    const farmRegexPrefix = '$__farm_regex:';
                    for (const { find, replacement } of config.resolve.alias){
                        if (find instanceof RegExp) {
                            const key = farmRegexPrefix + find.source;
                            farmConfig.compilation.resolve.alias[key] = replacement;
                        } else {
                            farmConfig.compilation.resolve.alias[find] = replacement;
                        }
                    }
                }
            }
            farmConfig.compilation.resolve.extensions = config.resolve.extensions;
            farmConfig.compilation.resolve.mainFields = config.resolve.mainFields;
            farmConfig.compilation.resolve.conditions = config.resolve.conditions;
            farmConfig.compilation.resolve.symlinks = config.resolve.preserveSymlinks != true;
        }
        if (config.server) {
            farmConfig.server ??= {};
            farmConfig.server.hmr = config.server.hmr;
            farmConfig.server.port = config.server.port;
            if (config.server.watch) {
                if (farmConfig.server?.hmr === true || farmConfig.server?.hmr === undefined) {
                    farmConfig.server.hmr = {
                        ...typeof origFarmConfig?.server?.hmr === 'object' ? origFarmConfig.server.hmr : {},
                        watchOptions: config.server.watch
                    };
                }
            }
            if (typeof config.server.host === 'string') {
                farmConfig.server.host = config.server.host;
            }
            farmConfig.server.strictPort = config.server.strictPort;
            farmConfig.server.https = typeof config.server.https === 'boolean' ? undefined : config.server.https;
            farmConfig.server.proxy = config.server.proxy;
            farmConfig.server.open = Boolean(config.server.open);
        }
        if (config.build) {
            farmConfig.compilation.output ??= {};
            farmConfig.compilation.output.path = config.build.outDir;
            if (config.build?.sourcemap !== undefined && origFarmConfig.compilation?.sourcemap === undefined) {
                farmConfig.compilation.sourcemap = Boolean(config.build.sourcemap);
            }
            if (config.build.ssr !== undefined && origFarmConfig.compilation?.lazyCompilation === undefined) {
                farmConfig.compilation.lazyCompilation = !config.build.ssr;
            }
            if (config.build.rollupOptions?.output !== undefined) {
                if (!Array.isArray(config.build.rollupOptions.output)) {
                    const keys = [
                        'assetFileNames',
                        'entryFilename',
                        'filename'
                    ];
                    for (const k of keys){
                        farmConfig.compilation.output[k] = config.build.rollupOptions.output[k];
                    }
                }
            }
        }
        _f_utils.deleteUndefinedPropertyDeeply(farmConfig);
        return module.f(_f_merge)({}, origFarmConfig, farmConfig);
    }
}
,
"aea2ea19":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "mergeConfig", ()=>mergeConfig);
    module.o(exports, "mergeFarmCliConfig", ()=>mergeFarmCliConfig);
    var _f_node_path = module.w(farmRequire('node:path'));
    var _f_utils = farmRequire("e60815f7");
    var _f_share = farmRequire("bc6cc539");
    function mergeConfig(userConfig, target) {
        const result = {
            ...userConfig
        };
        for (const key of Object.keys(target)){
            const left = result[key];
            const right = target[key];
            if (right === null || right === undefined) {
                continue;
            }
            if (left === null || left === undefined) {
                result[key] = right;
                continue;
            }
            if (_f_share.isArray(left) || _f_share.isArray(right)) {
                result[key] = [
                    ...new Set([
                        ..._f_share.isArray(left) ? left : [],
                        ..._f_share.isArray(right) ? right : []
                    ])
                ];
                continue;
            }
            if (_f_share.isObject(left) && _f_share.isObject(right)) {
                result[key] = mergeConfig(left, right);
                continue;
            }
            result[key] = right;
        }
        return result;
    }
    function mergeFarmCliConfig(cliOption, target) {
        let left = {};
        [
            'clearScreen',
            'compilation',
            'envDir',
            'envPrefix',
            'plugins',
            'publicDir',
            'server',
            'vitePlugins'
        ].forEach((key)=>{
            const value = cliOption[key];
            if (value || typeof value === 'boolean') {
                left = mergeConfig(left, {
                    [key]: cliOption[key]
                });
            }
        });
        {
            const configRootPath = target.root;
            if (cliOption.root) {
                const cliRoot = cliOption.root;
                if (!_f_node_path.isAbsolute(cliRoot)) {
                    target.root = module.f(_f_node_path).resolve(process.cwd(), cliRoot);
                } else {
                    target.root = cliRoot;
                }
            } else {
                target.root = process.cwd();
            }
            if (configRootPath) {
                target.root = configRootPath;
            }
            if (target.root && !_f_node_path.isAbsolute(target.root)) {
                const resolvedRoot = module.f(_f_node_path).resolve(cliOption.configPath, target.root);
                target.root = resolvedRoot;
            }
        }
        if (_f_utils.isString(cliOption.host) || typeof cliOption.host === 'boolean') {
            left = mergeConfig(left, {
                server: {
                    host: cliOption.host
                }
            });
        }
        if (typeof cliOption.minify === 'boolean') {
            left = mergeConfig(left, {
                compilation: {
                    minify: cliOption.minify
                }
            });
        }
        if (cliOption.outDir) {
            left = mergeConfig(left, {
                compilation: {
                    output: {
                        path: cliOption.outDir
                    }
                }
            });
        }
        if (cliOption.port) {
            left = mergeConfig(left, {
                server: {
                    port: cliOption.port
                }
            });
        }
        if (cliOption.mode) {
            left = mergeConfig(left, {
                compilation: {
                    mode: cliOption.mode
                }
            });
        }
        if (cliOption.https) {
            left = mergeConfig(left, {
                server: {
                    https: cliOption.https
                }
            });
        }
        if (cliOption.sourcemap) {
            left = mergeConfig(left, {
                compilation: {
                    sourcemap: cliOption.sourcemap
                }
            });
        }
        return mergeConfig(left, target);
    }
}
,
"af1cd816":function  (module, exports, farmRequire, farmDynamicRequire) {
    try {
        var util = global.nodeRequire('util', true);
        if (typeof util.inherits !== 'function') throw '';
        module.exports = util.inherits;
    } catch (e) {
        module.exports = farmRequire("f9eb5ea0", true);
    }
}
,
"b04b95dc":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    module.exports = preferredLanguages;
    module.exports.preferredLanguages = preferredLanguages;
    var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
    function parseAcceptLanguage(accept) {
        var accepts = accept.split(',');
        for(var i = 0, j = 0; i < accepts.length; i++){
            var language = parseLanguage(accepts[i].trim(), i);
            if (language) {
                accepts[j++] = language;
            }
        }
        accepts.length = j;
        return accepts;
    }
    function parseLanguage(str, i) {
        var match = simpleLanguageRegExp.exec(str);
        if (!match) return null;
        var prefix = match[1];
        var suffix = match[2];
        var full = prefix;
        if (suffix) full += "-" + suffix;
        var q = 1;
        if (match[3]) {
            var params = match[3].split(';');
            for(var j = 0; j < params.length; j++){
                var p = params[j].split('=');
                if (p[0] === 'q') q = parseFloat(p[1]);
            }
        }
        return {
            prefix: prefix,
            suffix: suffix,
            q: q,
            i: i,
            full: full
        };
    }
    function getLanguagePriority(language, accepted, index) {
        var priority = {
            o: -1,
            q: 0,
            s: 0
        };
        for(var i = 0; i < accepted.length; i++){
            var spec = specify(language, accepted[i], index);
            if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
                priority = spec;
            }
        }
        return priority;
    }
    function specify(language, spec, index) {
        var p = parseLanguage(language);
        if (!p) return null;
        var s = 0;
        if (spec.full.toLowerCase() === p.full.toLowerCase()) {
            s |= 4;
        } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
            s |= 2;
        } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
            s |= 1;
        } else if (spec.full !== '*') {
            return null;
        }
        return {
            i: index,
            o: spec.i,
            q: spec.q,
            s: s
        };
    }
    ;
    function preferredLanguages(accept, provided) {
        var accepts = parseAcceptLanguage(accept === undefined ? '*' : accept || '');
        if (!provided) {
            return accepts.filter(isQuality).sort(compareSpecs).map(getFullLanguage);
        }
        var priorities = provided.map(function getPriority(type, index) {
            return getLanguagePriority(type, accepts, index);
        });
        return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
            return provided[priorities.indexOf(priority)];
        });
    }
    function compareSpecs(a, b) {
        return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }
    function getFullLanguage(spec) {
        return spec.full;
    }
    function isQuality(spec) {
        return spec.q > 0;
    }
}
,
"b3526578":function  (module, exports, farmRequire, farmDynamicRequire) {
    var fs = global.nodeRequire('fs', true);
    var path = global.nodeRequire('path', true);
    var os = global.nodeRequire('os', true);
    var runtimeRequire = typeof __webpack_require__ === 'function' ? __non_webpack_require__ : require;
    var vars = process.config && process.config.variables || {};
    var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
    var abi = process.versions.modules;
    var runtime = isElectron() ? 'electron' : isNwjs() ? 'node-webkit' : 'node';
    var arch = process.env.npm_config_arch || os.arch();
    var platform = process.env.npm_config_platform || os.platform();
    var libc = process.env.LIBC || (isAlpine(platform) ? 'musl' : 'glibc');
    var armv = process.env.ARM_VERSION || (arch === 'arm64' ? '8' : vars.arm_version) || '';
    var uv = (process.versions.uv || '').split('.')[0];
    module.exports = load;
    function load(dir) {
        return runtimeRequire(load.resolve(dir));
    }
    load.resolve = load.path = function(dir) {
        dir = path.resolve(dir || '.');
        try {
            var name = runtimeRequire(path.join(dir, 'package.json')).name.toUpperCase().replace(/-/g, '_');
            if (process.env[name + '_PREBUILD']) dir = process.env[name + '_PREBUILD'];
        } catch (err) {}
        if (!prebuildsOnly) {
            var release = getFirst(path.join(dir, 'build/Release'), matchBuild);
            if (release) return release;
            var debug = getFirst(path.join(dir, 'build/Debug'), matchBuild);
            if (debug) return debug;
        }
        var prebuild = resolve(dir);
        if (prebuild) return prebuild;
        var nearby = resolve(path.dirname(process.execPath));
        if (nearby) return nearby;
        var target = [
            'platform=' + platform,
            'arch=' + arch,
            'runtime=' + runtime,
            'abi=' + abi,
            'uv=' + uv,
            armv ? 'armv=' + armv : '',
            'libc=' + libc,
            'node=' + process.versions.node,
            process.versions.electron ? 'electron=' + process.versions.electron : '',
            typeof __webpack_require__ === 'function' ? 'webpack=true' : ''
        ].filter(Boolean).join(' ');
        throw new Error('No native build was found for ' + target + '\n    loaded from: ' + dir + '\n');
        function resolve(dir) {
            var tuples = readdirSync(path.join(dir, 'prebuilds')).map(parseTuple);
            var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];
            if (!tuple) return;
            var prebuilds = path.join(dir, 'prebuilds', tuple.name);
            var parsed = readdirSync(prebuilds).map(parseTags);
            var candidates = parsed.filter(matchTags(runtime, abi));
            var winner = candidates.sort(compareTags(runtime))[0];
            if (winner) return path.join(prebuilds, winner.file);
        }
    };
    function readdirSync(dir) {
        try {
            return fs.readdirSync(dir);
        } catch (err) {
            return [];
        }
    }
    function getFirst(dir, filter) {
        var files = readdirSync(dir).filter(filter);
        return files[0] && path.join(dir, files[0]);
    }
    function matchBuild(name) {
        return /\.node$/.test(name);
    }
    function parseTuple(name) {
        var arr = name.split('-');
        if (arr.length !== 2) return;
        var platform = arr[0];
        var architectures = arr[1].split('+');
        if (!platform) return;
        if (!architectures.length) return;
        if (!architectures.every(Boolean)) return;
        return {
            name,
            platform,
            architectures
        };
    }
    function matchTuple(platform, arch) {
        return function(tuple) {
            if (tuple == null) return false;
            if (tuple.platform !== platform) return false;
            return tuple.architectures.includes(arch);
        };
    }
    function compareTuples(a, b) {
        return a.architectures.length - b.architectures.length;
    }
    function parseTags(file) {
        var arr = file.split('.');
        var extension = arr.pop();
        var tags = {
            file: file,
            specificity: 0
        };
        if (extension !== 'node') return;
        for(var i = 0; i < arr.length; i++){
            var tag = arr[i];
            if (tag === 'node' || tag === 'electron' || tag === 'node-webkit') {
                tags.runtime = tag;
            } else if (tag === 'napi') {
                tags.napi = true;
            } else if (tag.slice(0, 3) === 'abi') {
                tags.abi = tag.slice(3);
            } else if (tag.slice(0, 2) === 'uv') {
                tags.uv = tag.slice(2);
            } else if (tag.slice(0, 4) === 'armv') {
                tags.armv = tag.slice(4);
            } else if (tag === 'glibc' || tag === 'musl') {
                tags.libc = tag;
            } else {
                continue;
            }
            tags.specificity++;
        }
        return tags;
    }
    function matchTags(runtime, abi) {
        return function(tags) {
            if (tags == null) return false;
            if (tags.runtime !== runtime && !runtimeAgnostic(tags)) return false;
            if (tags.abi !== abi && !tags.napi) return false;
            if (tags.uv && tags.uv !== uv) return false;
            if (tags.armv && tags.armv !== armv) return false;
            if (tags.libc && tags.libc !== libc) return false;
            return true;
        };
    }
    function runtimeAgnostic(tags) {
        return tags.runtime === 'node' && tags.napi;
    }
    function compareTags(runtime) {
        return function(a, b) {
            if (a.runtime !== b.runtime) {
                return a.runtime === runtime ? -1 : 1;
            } else if (a.abi !== b.abi) {
                return a.abi ? -1 : 1;
            } else if (a.specificity !== b.specificity) {
                return a.specificity > b.specificity ? -1 : 1;
            } else {
                return 0;
            }
        };
    }
    function isNwjs() {
        return !!(process.versions && process.versions.nw);
    }
    function isElectron() {
        if (process.versions && process.versions.electron) return true;
        if (process.env.ELECTRON_RUN_AS_NODE) return true;
        return typeof window !== 'undefined' && window.process && window.process.type === 'renderer';
    }
    function isAlpine(platform) {
        return platform === 'linux' && fs.existsSync('/etc/alpine-release');
    }
    load.parseTags = parseTags;
    load.matchTags = matchTags;
    load.compareTags = compareTags;
    load.parseTuple = parseTuple;
    load.matchTuple = matchTuple;
    load.compareTuples = compareTuples;
}
,
"b3530deb":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.splitWhen = exports.flatten = void 0;
    function flatten(items) {
        return items.reduce((collection, item)=>[].concat(collection, item), []);
    }
    exports.flatten = flatten;
    function splitWhen(items, predicate) {
        const result = [
            []
        ];
        let groupIndex = 0;
        for (const item of items){
            if (predicate(item)) {
                groupIndex++;
                result[groupIndex] = [];
            } else {
                result[groupIndex].push(item);
            }
        }
        return result;
    }
    exports.splitWhen = splitWhen;
}
,
"b3cd9106":/**
 * @license MIT Copyright (c) 2019-present, Yuxi (Evan) You and Vite contributors.
 * This file is the same as https://github.com/vitejs/vite/blob/main/packages/vite/src/node/plugins/html.ts#L1185
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "applyHtmlTransform", ()=>applyHtmlTransform);
    function applyHtmlTransform(html, res) {
        let tags;
        if (Array.isArray(res)) {
            tags = res;
        } else {
            html = res.html || html;
            tags = res.tags;
        }
        let headTags;
        let headPrependTags;
        let bodyTags;
        let bodyPrependTags;
        for (const tag of tags){
            switch(tag.injectTo){
                case 'body':
                    (bodyTags ??= []).push(tag);
                    break;
                case 'body-prepend':
                    (bodyPrependTags ??= []).push(tag);
                    break;
                case 'head':
                    (headTags ??= []).push(tag);
                    break;
                default:
                    (headPrependTags ??= []).push(tag);
            }
        }
        if (headPrependTags) html = injectToHead(html, headPrependTags, true);
        if (headTags) html = injectToHead(html, headTags);
        if (bodyPrependTags) html = injectToBody(html, bodyPrependTags, true);
        if (bodyTags) html = injectToBody(html, bodyTags);
        return html;
    }
    const headInjectRE = /([ \t]*)<\/head>/i;
    const headPrependInjectRE = /([ \t]*)<head[^>]*>/i;
    const htmlInjectRE = /<\/html>/i;
    const htmlPrependInjectRE = /([ \t]*)<html[^>]*>/i;
    const bodyInjectRE = /([ \t]*)<\/body>/i;
    const bodyPrependInjectRE = /([ \t]*)<body[^>]*>/i;
    const doctypePrependInjectRE = /<!doctype html>/i;
    function injectToHead(html, tags, prepend = false) {
        if (tags.length === 0) return html;
        if (prepend) {
            if (headPrependInjectRE.test(html)) {
                return html.replace(headPrependInjectRE, (match, p1)=>`${match}\n${serializeTags(tags, incrementIndent(p1))}`);
            }
        } else {
            if (headInjectRE.test(html)) {
                return html.replace(headInjectRE, (match, p1)=>`${serializeTags(tags, incrementIndent(p1))}${match}`);
            }
            if (bodyPrependInjectRE.test(html)) {
                return html.replace(bodyPrependInjectRE, (match, p1)=>`${serializeTags(tags, p1)}\n${match}`);
            }
        }
        return prependInjectFallback(html, tags);
    }
    function injectToBody(html, tags, prepend = false) {
        if (tags.length === 0) return html;
        if (prepend) {
            if (bodyPrependInjectRE.test(html)) {
                return html.replace(bodyPrependInjectRE, (match, p1)=>`${match}\n${serializeTags(tags, incrementIndent(p1))}`);
            }
            if (headInjectRE.test(html)) {
                return html.replace(headInjectRE, (match, p1)=>`${match}\n${serializeTags(tags, p1)}`);
            }
            return prependInjectFallback(html, tags);
        } else {
            if (bodyInjectRE.test(html)) {
                return html.replace(bodyInjectRE, (match, p1)=>`${serializeTags(tags, incrementIndent(p1))}${match}`);
            }
            if (htmlInjectRE.test(html)) {
                return html.replace(htmlInjectRE, `${serializeTags(tags)}\n$&`);
            }
            return html + `\n` + serializeTags(tags);
        }
    }
    function prependInjectFallback(html, tags) {
        if (htmlPrependInjectRE.test(html)) {
            return html.replace(htmlPrependInjectRE, `$&\n${serializeTags(tags)}`);
        }
        if (doctypePrependInjectRE.test(html)) {
            return html.replace(doctypePrependInjectRE, `$&\n${serializeTags(tags)}`);
        }
        return serializeTags(tags) + html;
    }
    const unaryTags = new Set([
        'link',
        'meta',
        'base'
    ]);
    function serializeTag({ tag, attrs, children }, indent = '') {
        if (unaryTags.has(tag)) {
            return `<${tag}${serializeAttrs(attrs)}>`;
        } else {
            return `<${tag}${serializeAttrs(attrs)}>${serializeTags(children, incrementIndent(indent))}</${tag}>`;
        }
    }
    function serializeTags(tags, indent = '') {
        if (typeof tags === 'string') {
            return tags;
        } else if (tags && tags.length) {
            return tags.map((tag)=>`${indent}${serializeTag(tag, indent)}\n`).join('');
        }
        return '';
    }
    function serializeAttrs(attrs) {
        let res = '';
        for(const key in attrs){
            if (typeof attrs[key] === 'boolean') {
                res += attrs[key] ? ` ${key}` : ``;
            } else {
                res += ` ${key}=${JSON.stringify(attrs[key])}`;
            }
        }
        return res;
    }
    function incrementIndent(indent = '') {
        return `${indent}${indent[0] === '\t' ? '\t' : '  '}`;
    }
}
,
"b4cbd046":function  (module, exports, farmRequire, farmDynamicRequire) {
    module.exports = Object.setPrototypeOf || (({
        __proto__: []
    }) instanceof Array ? setProtoOf : mixinProperties);
    function setProtoOf(obj, proto) {
        obj.__proto__ = proto;
        return obj;
    }
    function mixinProperties(obj, proto) {
        for(var prop in proto){
            if (!obj.hasOwnProperty(prop)) {
                obj[prop] = proto[prop];
            }
        }
        return obj;
    }
}
,
"b59ced88":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const utils = farmRequire("781fd2fa", true);
    class EntryFilter {
        constructor(_settings, _micromatchOptions){
            this._settings = _settings;
            this._micromatchOptions = _micromatchOptions;
            this.index = new Map();
        }
        getFilter(positive, negative) {
            const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);
            const negativeRe = utils.pattern.convertPatternsToRe(negative, Object.assign(Object.assign({}, this._micromatchOptions), {
                dot: true
            }));
            return (entry)=>this._filter(entry, positiveRe, negativeRe);
        }
        _filter(entry, positiveRe, negativeRe) {
            const filepath = utils.path.removeLeadingDotSegment(entry.path);
            if (this._settings.unique && this._isDuplicateEntry(filepath)) {
                return false;
            }
            if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
                return false;
            }
            if (this._isSkippedByAbsoluteNegativePatterns(filepath, negativeRe)) {
                return false;
            }
            const isDirectory = entry.dirent.isDirectory();
            const isMatched = this._isMatchToPatterns(filepath, positiveRe, isDirectory) && !this._isMatchToPatterns(filepath, negativeRe, isDirectory);
            if (this._settings.unique && isMatched) {
                this._createIndexRecord(filepath);
            }
            return isMatched;
        }
        _isDuplicateEntry(filepath) {
            return this.index.has(filepath);
        }
        _createIndexRecord(filepath) {
            this.index.set(filepath, undefined);
        }
        _onlyFileFilter(entry) {
            return this._settings.onlyFiles && !entry.dirent.isFile();
        }
        _onlyDirectoryFilter(entry) {
            return this._settings.onlyDirectories && !entry.dirent.isDirectory();
        }
        _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
            if (!this._settings.absolute) {
                return false;
            }
            const fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);
            return utils.pattern.matchAny(fullpath, patternsRe);
        }
        _isMatchToPatterns(filepath, patternsRe, isDirectory) {
            const isMatched = utils.pattern.matchAny(filepath, patternsRe);
            if (!isMatched && isDirectory) {
                return utils.pattern.matchAny(filepath + '/', patternsRe);
            }
            return isMatched;
        }
    }
    exports.default = EntryFilter;
}
,
"b6e736ca":function  (module, exports, farmRequire, farmDynamicRequire) {
    const runtimeRequire = typeof __webpack_require__ === 'function' ? __non_webpack_require__ : require;
    if (typeof runtimeRequire.addon === 'function') {
        module.exports = runtimeRequire.addon.bind(runtimeRequire);
    } else {
        module.exports = farmRequire("b3526578", true);
    }
}
,
"b6eaaf05":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    function _typeof(obj) {
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof = function _typeof(obj) {
                return typeof obj;
            };
        } else {
            _typeof = function _typeof(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
        }
        return _typeof(obj);
    }
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.colors = [
        '#0000CC',
        '#0000FF',
        '#0033CC',
        '#0033FF',
        '#0066CC',
        '#0066FF',
        '#0099CC',
        '#0099FF',
        '#00CC00',
        '#00CC33',
        '#00CC66',
        '#00CC99',
        '#00CCCC',
        '#00CCFF',
        '#3300CC',
        '#3300FF',
        '#3333CC',
        '#3333FF',
        '#3366CC',
        '#3366FF',
        '#3399CC',
        '#3399FF',
        '#33CC00',
        '#33CC33',
        '#33CC66',
        '#33CC99',
        '#33CCCC',
        '#33CCFF',
        '#6600CC',
        '#6600FF',
        '#6633CC',
        '#6633FF',
        '#66CC00',
        '#66CC33',
        '#9900CC',
        '#9900FF',
        '#9933CC',
        '#9933FF',
        '#99CC00',
        '#99CC33',
        '#CC0000',
        '#CC0033',
        '#CC0066',
        '#CC0099',
        '#CC00CC',
        '#CC00FF',
        '#CC3300',
        '#CC3333',
        '#CC3366',
        '#CC3399',
        '#CC33CC',
        '#CC33FF',
        '#CC6600',
        '#CC6633',
        '#CC9900',
        '#CC9933',
        '#CCCC00',
        '#CCCC33',
        '#FF0000',
        '#FF0033',
        '#FF0066',
        '#FF0099',
        '#FF00CC',
        '#FF00FF',
        '#FF3300',
        '#FF3333',
        '#FF3366',
        '#FF3399',
        '#FF33CC',
        '#FF33FF',
        '#FF6600',
        '#FF6633',
        '#FF9900',
        '#FF9933',
        '#FFCC00',
        '#FFCC33'
    ];
    function useColors() {
        if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
            return true;
        }
        if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
            return false;
        }
        return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
        args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
        if (!this.useColors) {
            return;
        }
        var c = 'color: ' + this.color;
        args.splice(1, 0, c, 'color: inherit');
        var index = 0;
        var lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, function(match) {
            if (match === '%%') {
                return;
            }
            index++;
            if (match === '%c') {
                lastC = index;
            }
        });
        args.splice(lastC, 0, c);
    }
    function log() {
        var _console;
        return (typeof console === "undefined" ? "undefined" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);
    }
    function save(namespaces) {
        try {
            if (namespaces) {
                exports.storage.setItem('debug', namespaces);
            } else {
                exports.storage.removeItem('debug');
            }
        } catch (error) {}
    }
    function load() {
        var r;
        try {
            r = exports.storage.getItem('debug');
        } catch (error) {}
        if (!r && typeof process !== 'undefined' && 'env' in process) {
            r = process.env.DEBUG;
        }
        return r;
    }
    function localstorage() {
        try {
            return localStorage;
        } catch (error) {}
    }
    module.exports = farmRequire("d974ce93")(exports);
    var formatters = module.exports.formatters;
    formatters.j = function(v) {
        try {
            return JSON.stringify(v);
        } catch (error) {
            return '[UnexpectedJSONParseError]: ' + error.message;
        }
    };
}
,
"b7669e10":/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const isNumber = farmRequire("787884bd", true);
    const toRegexRange = (min, max, options)=>{
        if (isNumber(min) === false) {
            throw new TypeError('toRegexRange: expected the first argument to be a number');
        }
        if (max === void 0 || min === max) {
            return String(min);
        }
        if (isNumber(max) === false) {
            throw new TypeError('toRegexRange: expected the second argument to be a number.');
        }
        let opts = {
            relaxZeros: true,
            ...options
        };
        if (typeof opts.strictZeros === 'boolean') {
            opts.relaxZeros = opts.strictZeros === false;
        }
        let relax = String(opts.relaxZeros);
        let shorthand = String(opts.shorthand);
        let capture = String(opts.capture);
        let wrap = String(opts.wrap);
        let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;
        if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
            return toRegexRange.cache[cacheKey].result;
        }
        let a = Math.min(min, max);
        let b = Math.max(min, max);
        if (Math.abs(a - b) === 1) {
            let result = min + '|' + max;
            if (opts.capture) {
                return `(${result})`;
            }
            if (opts.wrap === false) {
                return result;
            }
            return `(?:${result})`;
        }
        let isPadded = hasPadding(min) || hasPadding(max);
        let state = {
            min,
            max,
            a,
            b
        };
        let positives = [];
        let negatives = [];
        if (isPadded) {
            state.isPadded = isPadded;
            state.maxLen = String(state.max).length;
        }
        if (a < 0) {
            let newMin = b < 0 ? Math.abs(b) : 1;
            negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
            a = state.a = 0;
        }
        if (b >= 0) {
            positives = splitToPatterns(a, b, state, opts);
        }
        state.negatives = negatives;
        state.positives = positives;
        state.result = collatePatterns(negatives, positives, opts);
        if (opts.capture === true) {
            state.result = `(${state.result})`;
        } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
            state.result = `(?:${state.result})`;
        }
        toRegexRange.cache[cacheKey] = state;
        return state.result;
    };
    function collatePatterns(neg, pos, options) {
        let onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];
        let onlyPositive = filterPatterns(pos, neg, '', false, options) || [];
        let intersected = filterPatterns(neg, pos, '-?', true, options) || [];
        let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
        return subpatterns.join('|');
    }
    function splitToRanges(min, max) {
        let nines = 1;
        let zeros = 1;
        let stop = countNines(min, nines);
        let stops = new Set([
            max
        ]);
        while(min <= stop && stop <= max){
            stops.add(stop);
            nines += 1;
            stop = countNines(min, nines);
        }
        stop = countZeros(max + 1, zeros) - 1;
        while(min < stop && stop <= max){
            stops.add(stop);
            zeros += 1;
            stop = countZeros(max + 1, zeros) - 1;
        }
        stops = [
            ...stops
        ];
        stops.sort(compare);
        return stops;
    }
    function rangeToPattern(start, stop, options) {
        if (start === stop) {
            return {
                pattern: start,
                count: [],
                digits: 0
            };
        }
        let zipped = zip(start, stop);
        let digits = zipped.length;
        let pattern = '';
        let count = 0;
        for(let i = 0; i < digits; i++){
            let [startDigit, stopDigit] = zipped[i];
            if (startDigit === stopDigit) {
                pattern += startDigit;
            } else if (startDigit !== '0' || stopDigit !== '9') {
                pattern += toCharacterClass(startDigit, stopDigit, options);
            } else {
                count++;
            }
        }
        if (count) {
            pattern += options.shorthand === true ? '\\d' : '[0-9]';
        }
        return {
            pattern,
            count: [
                count
            ],
            digits
        };
    }
    function splitToPatterns(min, max, tok, options) {
        let ranges = splitToRanges(min, max);
        let tokens = [];
        let start = min;
        let prev;
        for(let i = 0; i < ranges.length; i++){
            let max = ranges[i];
            let obj = rangeToPattern(String(start), String(max), options);
            let zeros = '';
            if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
                if (prev.count.length > 1) {
                    prev.count.pop();
                }
                prev.count.push(obj.count[0]);
                prev.string = prev.pattern + toQuantifier(prev.count);
                start = max + 1;
                continue;
            }
            if (tok.isPadded) {
                zeros = padZeros(max, tok, options);
            }
            obj.string = zeros + obj.pattern + toQuantifier(obj.count);
            tokens.push(obj);
            start = max + 1;
            prev = obj;
        }
        return tokens;
    }
    function filterPatterns(arr, comparison, prefix, intersection, options) {
        let result = [];
        for (let ele of arr){
            let { string } = ele;
            if (!intersection && !contains(comparison, 'string', string)) {
                result.push(prefix + string);
            }
            if (intersection && contains(comparison, 'string', string)) {
                result.push(prefix + string);
            }
        }
        return result;
    }
    function zip(a, b) {
        let arr = [];
        for(let i = 0; i < a.length; i++)arr.push([
            a[i],
            b[i]
        ]);
        return arr;
    }
    function compare(a, b) {
        return a > b ? 1 : b > a ? -1 : 0;
    }
    function contains(arr, key, val) {
        return arr.some((ele)=>ele[key] === val);
    }
    function countNines(min, len) {
        return Number(String(min).slice(0, -len) + '9'.repeat(len));
    }
    function countZeros(integer, zeros) {
        return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
        let [start = 0, stop = ''] = digits;
        if (stop || start > 1) {
            return `{${start + (stop ? ',' + stop : '')}}`;
        }
        return '';
    }
    function toCharacterClass(a, b, options) {
        return `[${a}${b - a === 1 ? '' : '-'}${b}]`;
    }
    function hasPadding(str) {
        return /^-?(0+)\d/.test(str);
    }
    function padZeros(value, tok, options) {
        if (!tok.isPadded) {
            return value;
        }
        let diff = Math.abs(tok.maxLen - String(value).length);
        let relax = options.relaxZeros !== false;
        switch(diff){
            case 0:
                return '';
            case 1:
                return relax ? '0?' : '0';
            case 2:
                return relax ? '0{0,2}' : '00';
            default:
                {
                    return relax ? `0{0,${diff}}` : `0{${diff}}`;
                }
        }
    }
    toRegexRange.cache = {};
    toRegexRange.clearCache = ()=>toRegexRange.cache = {};
    module.exports = toRegexRange;
}
,
"b82d8e6c":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    var _f_ValidationError = farmRequire("0d38b53d");
    module._(exports, "fromZodError", _f_ValidationError);
}
,
"b949c668":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "default", ()=>isDocker);
    var _f_node_fs = module.i(farmRequire('node:fs'));
    let isDockerCached;
    function hasDockerEnv() {
        try {
            module.f(_f_node_fs).statSync('/.dockerenv');
            return true;
        } catch  {
            return false;
        }
    }
    function hasDockerCGroup() {
        try {
            return module.f(_f_node_fs).readFileSync('/proc/self/cgroup', 'utf8').includes('docker');
        } catch  {
            return false;
        }
    }
    function isDocker() {
        if (isDockerCached === undefined) {
            isDockerCached = hasDockerEnv() || hasDockerCGroup();
        }
        return isDockerCached;
    }
}
,
"b96c39dc":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const fill = farmRequire("4278e518", true);
    const stringify = farmRequire("f4086ed0", true);
    const utils = farmRequire("29769a7a", true);
    const append = (queue = '', stash = '', enclose = false)=>{
        let result = [];
        queue = [].concat(queue);
        stash = [].concat(stash);
        if (!stash.length) return queue;
        if (!queue.length) {
            return enclose ? utils.flatten(stash).map((ele)=>`{${ele}}`) : stash;
        }
        for (let item of queue){
            if (Array.isArray(item)) {
                for (let value of item){
                    result.push(append(value, stash, enclose));
                }
            } else {
                for (let ele of stash){
                    if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;
                    result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
                }
            }
        }
        return utils.flatten(result);
    };
    const expand = (ast, options = {})=>{
        let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;
        let walk = (node, parent = {})=>{
            node.queue = [];
            let p = parent;
            let q = parent.queue;
            while(p.type !== 'brace' && p.type !== 'root' && p.parent){
                p = p.parent;
                q = p.queue;
            }
            if (node.invalid || node.dollar) {
                q.push(append(q.pop(), stringify(node, options)));
                return;
            }
            if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {
                q.push(append(q.pop(), [
                    '{}'
                ]));
                return;
            }
            if (node.nodes && node.ranges > 0) {
                let args = utils.reduce(node.nodes);
                if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
                    throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');
                }
                let range = fill(...args, options);
                if (range.length === 0) {
                    range = stringify(node, options);
                }
                q.push(append(q.pop(), range));
                node.nodes = [];
                return;
            }
            let enclose = utils.encloseBrace(node);
            let queue = node.queue;
            let block = node;
            while(block.type !== 'brace' && block.type !== 'root' && block.parent){
                block = block.parent;
                queue = block.queue;
            }
            for(let i = 0; i < node.nodes.length; i++){
                let child = node.nodes[i];
                if (child.type === 'comma' && node.type === 'brace') {
                    if (i === 1) queue.push('');
                    queue.push('');
                    continue;
                }
                if (child.type === 'close') {
                    q.push(append(q.pop(), queue, enclose));
                    continue;
                }
                if (child.value && child.type !== 'open') {
                    queue.push(append(queue.pop(), child.value));
                    continue;
                }
                if (child.nodes) {
                    walk(child, node);
                }
            }
            return queue;
        };
        return utils.flatten(walk(ast));
    };
    module.exports = expand;
}
,
"b972f34f":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const utils = farmRequire("781fd2fa", true);
    const partial_1 = farmRequire("a4f5e891", true);
    class DeepFilter {
        constructor(_settings, _micromatchOptions){
            this._settings = _settings;
            this._micromatchOptions = _micromatchOptions;
        }
        getFilter(basePath, positive, negative) {
            const matcher = this._getMatcher(positive);
            const negativeRe = this._getNegativePatternsRe(negative);
            return (entry)=>this._filter(basePath, entry, matcher, negativeRe);
        }
        _getMatcher(patterns) {
            return new partial_1.default(patterns, this._settings, this._micromatchOptions);
        }
        _getNegativePatternsRe(patterns) {
            const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);
            return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
        }
        _filter(basePath, entry, matcher, negativeRe) {
            if (this._isSkippedByDeep(basePath, entry.path)) {
                return false;
            }
            if (this._isSkippedSymbolicLink(entry)) {
                return false;
            }
            const filepath = utils.path.removeLeadingDotSegment(entry.path);
            if (this._isSkippedByPositivePatterns(filepath, matcher)) {
                return false;
            }
            return this._isSkippedByNegativePatterns(filepath, negativeRe);
        }
        _isSkippedByDeep(basePath, entryPath) {
            if (this._settings.deep === Infinity) {
                return false;
            }
            return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
        }
        _getEntryLevel(basePath, entryPath) {
            const entryPathDepth = entryPath.split('/').length;
            if (basePath === '') {
                return entryPathDepth;
            }
            const basePathDepth = basePath.split('/').length;
            return entryPathDepth - basePathDepth;
        }
        _isSkippedSymbolicLink(entry) {
            return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
        }
        _isSkippedByPositivePatterns(entryPath, matcher) {
            return !this._settings.baseNameMatch && !matcher.match(entryPath);
        }
        _isSkippedByNegativePatterns(entryPath, patternsRe) {
            return !utils.pattern.matchAny(entryPath, patternsRe);
        }
    }
    exports.default = DeepFilter;
}
,
"b9d7fcb5":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const os = global.nodeRequire('os', true);
    const fs = global.nodeRequire('fs', true);
    const isDocker = farmRequire("e144cb35", true);
    const isWsl = ()=>{
        if (process.platform !== 'linux') {
            return false;
        }
        if (os.release().toLowerCase().includes('microsoft')) {
            if (isDocker()) {
                return false;
            }
            return true;
        }
        try {
            return fs.readFileSync('/proc/version', 'utf8').toLowerCase().includes('microsoft') ? !isDocker() : false;
        } catch (_) {
            return false;
        }
    };
    if (process.env.__IS_WSL_TEST__) {
        module.exports = isWsl;
    } else {
        module.exports = isWsl();
    }
}
,
"ba3d9d5e":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const path = global.nodeRequire("path", true);
    const deep_1 = farmRequire("b972f34f", true);
    const entry_1 = farmRequire("b59ced88", true);
    const error_1 = farmRequire("a51b58e0", true);
    const entry_2 = farmRequire("74fe7e72", true);
    class Provider {
        constructor(_settings){
            this._settings = _settings;
            this.errorFilter = new error_1.default(this._settings);
            this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
            this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
            this.entryTransformer = new entry_2.default(this._settings);
        }
        _getRootDirectory(task) {
            return path.resolve(this._settings.cwd, task.base);
        }
        _getReaderOptions(task) {
            const basePath = task.base === '.' ? '' : task.base;
            return {
                basePath,
                pathSegmentSeparator: '/',
                concurrency: this._settings.concurrency,
                deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
                entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
                errorFilter: this.errorFilter.getFilter(),
                followSymbolicLinks: this._settings.followSymbolicLinks,
                fs: this._settings.fs,
                stats: this._settings.stats,
                throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
                transform: this.entryTransformer.getTransformer()
            };
        }
        _getMicromatchOptions() {
            return {
                dot: this._settings.dot,
                matchBase: this._settings.baseNameMatch,
                nobrace: !this._settings.braceExpansion,
                nocase: !this._settings.caseSensitiveMatch,
                noext: !this._settings.extglob,
                noglobstar: !this._settings.globstar,
                posix: true,
                strictSlashes: false
            };
        }
    }
    exports.default = Provider;
}
,
"ba69a156":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const pathKey = (options = {})=>{
        const environment = options.env || process.env;
        const platform = options.platform || process.platform;
        if (platform !== 'win32') {
            return 'PATH';
        }
        return Object.keys(environment).reverse().find((key)=>key.toUpperCase() === 'PATH') || 'Path';
    };
    module.exports = pathKey;
    module.exports.default = pathKey;
}
,
"bb24cb57":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const stringify = farmRequire("f4086ed0", true);
    const { MAX_LENGTH, CHAR_BACKSLASH, CHAR_BACKTICK, CHAR_COMMA, CHAR_DOT, CHAR_LEFT_PARENTHESES, CHAR_RIGHT_PARENTHESES, CHAR_LEFT_CURLY_BRACE, CHAR_RIGHT_CURLY_BRACE, CHAR_LEFT_SQUARE_BRACKET, CHAR_RIGHT_SQUARE_BRACKET, CHAR_DOUBLE_QUOTE, CHAR_SINGLE_QUOTE, CHAR_NO_BREAK_SPACE, CHAR_ZERO_WIDTH_NOBREAK_SPACE } = farmRequire("fbafd9e4", true);
    const parse = (input, options = {})=>{
        if (typeof input !== 'string') {
            throw new TypeError('Expected a string');
        }
        let opts = options || {};
        let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
        if (input.length > max) {
            throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
        }
        let ast = {
            type: 'root',
            input,
            nodes: []
        };
        let stack = [
            ast
        ];
        let block = ast;
        let prev = ast;
        let brackets = 0;
        let length = input.length;
        let index = 0;
        let depth = 0;
        let value;
        let memo = {};
        const advance = ()=>input[index++];
        const push = (node)=>{
            if (node.type === 'text' && prev.type === 'dot') {
                prev.type = 'text';
            }
            if (prev && prev.type === 'text' && node.type === 'text') {
                prev.value += node.value;
                return;
            }
            block.nodes.push(node);
            node.parent = block;
            node.prev = prev;
            prev = node;
            return node;
        };
        push({
            type: 'bos'
        });
        while(index < length){
            block = stack[stack.length - 1];
            value = advance();
            if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
                continue;
            }
            if (value === CHAR_BACKSLASH) {
                push({
                    type: 'text',
                    value: (options.keepEscaping ? value : '') + advance()
                });
                continue;
            }
            if (value === CHAR_RIGHT_SQUARE_BRACKET) {
                push({
                    type: 'text',
                    value: '\\' + value
                });
                continue;
            }
            if (value === CHAR_LEFT_SQUARE_BRACKET) {
                brackets++;
                let closed = true;
                let next;
                while(index < length && (next = advance())){
                    value += next;
                    if (next === CHAR_LEFT_SQUARE_BRACKET) {
                        brackets++;
                        continue;
                    }
                    if (next === CHAR_BACKSLASH) {
                        value += advance();
                        continue;
                    }
                    if (next === CHAR_RIGHT_SQUARE_BRACKET) {
                        brackets--;
                        if (brackets === 0) {
                            break;
                        }
                    }
                }
                push({
                    type: 'text',
                    value
                });
                continue;
            }
            if (value === CHAR_LEFT_PARENTHESES) {
                block = push({
                    type: 'paren',
                    nodes: []
                });
                stack.push(block);
                push({
                    type: 'text',
                    value
                });
                continue;
            }
            if (value === CHAR_RIGHT_PARENTHESES) {
                if (block.type !== 'paren') {
                    push({
                        type: 'text',
                        value
                    });
                    continue;
                }
                block = stack.pop();
                push({
                    type: 'text',
                    value
                });
                block = stack[stack.length - 1];
                continue;
            }
            if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
                let open = value;
                let next;
                if (options.keepQuotes !== true) {
                    value = '';
                }
                while(index < length && (next = advance())){
                    if (next === CHAR_BACKSLASH) {
                        value += next + advance();
                        continue;
                    }
                    if (next === open) {
                        if (options.keepQuotes === true) value += next;
                        break;
                    }
                    value += next;
                }
                push({
                    type: 'text',
                    value
                });
                continue;
            }
            if (value === CHAR_LEFT_CURLY_BRACE) {
                depth++;
                let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;
                let brace = {
                    type: 'brace',
                    open: true,
                    close: false,
                    dollar,
                    depth,
                    commas: 0,
                    ranges: 0,
                    nodes: []
                };
                block = push(brace);
                stack.push(block);
                push({
                    type: 'open',
                    value
                });
                continue;
            }
            if (value === CHAR_RIGHT_CURLY_BRACE) {
                if (block.type !== 'brace') {
                    push({
                        type: 'text',
                        value
                    });
                    continue;
                }
                let type = 'close';
                block = stack.pop();
                block.close = true;
                push({
                    type,
                    value
                });
                depth--;
                block = stack[stack.length - 1];
                continue;
            }
            if (value === CHAR_COMMA && depth > 0) {
                if (block.ranges > 0) {
                    block.ranges = 0;
                    let open = block.nodes.shift();
                    block.nodes = [
                        open,
                        {
                            type: 'text',
                            value: stringify(block)
                        }
                    ];
                }
                push({
                    type: 'comma',
                    value
                });
                block.commas++;
                continue;
            }
            if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
                let siblings = block.nodes;
                if (depth === 0 || siblings.length === 0) {
                    push({
                        type: 'text',
                        value
                    });
                    continue;
                }
                if (prev.type === 'dot') {
                    block.range = [];
                    prev.value += value;
                    prev.type = 'range';
                    if (block.nodes.length !== 3 && block.nodes.length !== 5) {
                        block.invalid = true;
                        block.ranges = 0;
                        prev.type = 'text';
                        continue;
                    }
                    block.ranges++;
                    block.args = [];
                    continue;
                }
                if (prev.type === 'range') {
                    siblings.pop();
                    let before = siblings[siblings.length - 1];
                    before.value += prev.value + value;
                    prev = before;
                    block.ranges--;
                    continue;
                }
                push({
                    type: 'dot',
                    value
                });
                continue;
            }
            push({
                type: 'text',
                value
            });
        }
        do {
            block = stack.pop();
            if (block.type !== 'root') {
                block.nodes.forEach((node)=>{
                    if (!node.nodes) {
                        if (node.type === 'open') node.isOpen = true;
                        if (node.type === 'close') node.isClose = true;
                        if (!node.nodes) node.type = 'text';
                        node.invalid = true;
                    }
                });
                let parent = stack[stack.length - 1];
                let index = parent.nodes.indexOf(block);
                parent.nodes.splice(index, 1, ...block.nodes);
            }
        }while (stack.length > 0)
        push({
            type: 'eos'
        });
        return ast;
    };
    module.exports = parse;
}
,
"bb3d8063":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    var tty = global.nodeRequire('tty', true);
    var util = global.nodeRequire('util', true);
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.colors = [
        6,
        2,
        3,
        4,
        5,
        1
    ];
    try {
        var supportsColor = farmRequire("6d9407b3", true);
        if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
            exports.colors = [
                20,
                21,
                26,
                27,
                32,
                33,
                38,
                39,
                40,
                41,
                42,
                43,
                44,
                45,
                56,
                57,
                62,
                63,
                68,
                69,
                74,
                75,
                76,
                77,
                78,
                79,
                80,
                81,
                92,
                93,
                98,
                99,
                112,
                113,
                128,
                129,
                134,
                135,
                148,
                149,
                160,
                161,
                162,
                163,
                164,
                165,
                166,
                167,
                168,
                169,
                170,
                171,
                172,
                173,
                178,
                179,
                184,
                185,
                196,
                197,
                198,
                199,
                200,
                201,
                202,
                203,
                204,
                205,
                206,
                207,
                208,
                209,
                214,
                215,
                220,
                221
            ];
        }
    } catch (error) {}
    exports.inspectOpts = Object.keys(process.env).filter(function(key) {
        return /^debug_/i.test(key);
    }).reduce(function(obj, key) {
        var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
            return k.toUpperCase();
        });
        var val = process.env[key];
        if (/^(yes|on|true|enabled)$/i.test(val)) {
            val = true;
        } else if (/^(no|off|false|disabled)$/i.test(val)) {
            val = false;
        } else if (val === 'null') {
            val = null;
        } else {
            val = Number(val);
        }
        obj[prop] = val;
        return obj;
    }, {});
    function useColors() {
        return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
        var name = this.namespace, useColors = this.useColors;
        if (useColors) {
            var c = this.color;
            var colorCode = "\x1B[3" + (c < 8 ? c : '8;5;' + c);
            var prefix = "  ".concat(colorCode, ";1m").concat(name, " \x1B[0m");
            args[0] = prefix + args[0].split('\n').join('\n' + prefix);
            args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + "\x1B[0m");
        } else {
            args[0] = getDate() + name + ' ' + args[0];
        }
    }
    function getDate() {
        if (exports.inspectOpts.hideDate) {
            return '';
        }
        return new Date().toISOString() + ' ';
    }
    function log() {
        return process.stderr.write(util.format.apply(util, arguments) + '\n');
    }
    function save(namespaces) {
        if (namespaces) {
            process.env.DEBUG = namespaces;
        } else {
            delete process.env.DEBUG;
        }
    }
    function load() {
        return process.env.DEBUG;
    }
    function init(debug) {
        debug.inspectOpts = {};
        var keys = Object.keys(exports.inspectOpts);
        for(var i = 0; i < keys.length; i++){
            debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
        }
    }
    module.exports = farmRequire("d974ce93")(exports);
    var formatters = module.exports.formatters;
    formatters.o = function(v) {
        this.inspectOpts.colors = this.useColors;
        return util.inspect(v, this.inspectOpts).split('\n').map(function(str) {
            return str.trim();
        }).join(' ');
    };
    formatters.O = function(v) {
        this.inspectOpts.colors = this.useColors;
        return util.inspect(v, this.inspectOpts);
    };
}
,
"bb66ff9f":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    var reusify = farmRequire("598071d1", true);
    function fastqueue(context, worker, concurrency) {
        if (typeof context === 'function') {
            concurrency = worker;
            worker = context;
            context = null;
        }
        if (concurrency < 1) {
            throw new Error('fastqueue concurrency must be greater than 1');
        }
        var cache = reusify(Task);
        var queueHead = null;
        var queueTail = null;
        var _running = 0;
        var errorHandler = null;
        var self = {
            push: push,
            drain: noop,
            saturated: noop,
            pause: pause,
            paused: false,
            concurrency: concurrency,
            running: running,
            resume: resume,
            idle: idle,
            length: length,
            getQueue: getQueue,
            unshift: unshift,
            empty: noop,
            kill: kill,
            killAndDrain: killAndDrain,
            error: error
        };
        return self;
        function running() {
            return _running;
        }
        function pause() {
            self.paused = true;
        }
        function length() {
            var current = queueHead;
            var counter = 0;
            while(current){
                current = current.next;
                counter++;
            }
            return counter;
        }
        function getQueue() {
            var current = queueHead;
            var tasks = [];
            while(current){
                tasks.push(current.value);
                current = current.next;
            }
            return tasks;
        }
        function resume() {
            if (!self.paused) return;
            self.paused = false;
            for(var i = 0; i < self.concurrency; i++){
                _running++;
                release();
            }
        }
        function idle() {
            return _running === 0 && self.length() === 0;
        }
        function push(value, done) {
            var current = cache.get();
            current.context = context;
            current.release = release;
            current.value = value;
            current.callback = done || noop;
            current.errorHandler = errorHandler;
            if (_running === self.concurrency || self.paused) {
                if (queueTail) {
                    queueTail.next = current;
                    queueTail = current;
                } else {
                    queueHead = current;
                    queueTail = current;
                    self.saturated();
                }
            } else {
                _running++;
                worker.call(context, current.value, current.worked);
            }
        }
        function unshift(value, done) {
            var current = cache.get();
            current.context = context;
            current.release = release;
            current.value = value;
            current.callback = done || noop;
            if (_running === self.concurrency || self.paused) {
                if (queueHead) {
                    current.next = queueHead;
                    queueHead = current;
                } else {
                    queueHead = current;
                    queueTail = current;
                    self.saturated();
                }
            } else {
                _running++;
                worker.call(context, current.value, current.worked);
            }
        }
        function release(holder) {
            if (holder) {
                cache.release(holder);
            }
            var next = queueHead;
            if (next) {
                if (!self.paused) {
                    if (queueTail === queueHead) {
                        queueTail = null;
                    }
                    queueHead = next.next;
                    next.next = null;
                    worker.call(context, next.value, next.worked);
                    if (queueTail === null) {
                        self.empty();
                    }
                } else {
                    _running--;
                }
            } else if (--_running === 0) {
                self.drain();
            }
        }
        function kill() {
            queueHead = null;
            queueTail = null;
            self.drain = noop;
        }
        function killAndDrain() {
            queueHead = null;
            queueTail = null;
            self.drain();
            self.drain = noop;
        }
        function error(handler) {
            errorHandler = handler;
        }
    }
    function noop() {}
    function Task() {
        this.value = null;
        this.callback = noop;
        this.next = null;
        this.release = noop;
        this.context = null;
        this.errorHandler = null;
        var self = this;
        this.worked = function worked(err, result) {
            var callback = self.callback;
            var errorHandler = self.errorHandler;
            var val = self.value;
            self.value = null;
            self.callback = noop;
            if (self.errorHandler) {
                errorHandler(err, val);
            }
            callback.call(self.context, err, result);
            self.release(self);
        };
    }
    function queueAsPromised(context, worker, concurrency) {
        if (typeof context === 'function') {
            concurrency = worker;
            worker = context;
            context = null;
        }
        function asyncWrapper(arg, cb) {
            worker.call(this, arg).then(function(res) {
                cb(null, res);
            }, cb);
        }
        var queue = fastqueue(context, asyncWrapper, concurrency);
        var pushCb = queue.push;
        var unshiftCb = queue.unshift;
        queue.push = push;
        queue.unshift = unshift;
        queue.drained = drained;
        return queue;
        function push(value) {
            var p = new Promise(function(resolve, reject) {
                pushCb(value, function(err, result) {
                    if (err) {
                        reject(err);
                        return;
                    }
                    resolve(result);
                });
            });
            p.catch(noop);
            return p;
        }
        function unshift(value) {
            var p = new Promise(function(resolve, reject) {
                unshiftCb(value, function(err, result) {
                    if (err) {
                        reject(err);
                        return;
                    }
                    resolve(result);
                });
            });
            p.catch(noop);
            return p;
        }
        function drained() {
            if (queue.idle()) {
                return new Promise(function(resolve) {
                    resolve();
                });
            }
            var previousDrain = queue.drain;
            var p = new Promise(function(resolve) {
                queue.drain = function() {
                    previousDrain();
                    resolve();
                };
            });
            return p;
        }
    }
    module.exports = fastqueue;
    module.exports.promise = queueAsPromised;
}
,
"bbe0ad7e":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.errorResponsePlugin = void 0;
    const status_code_1 = farmRequire("624c14bf", true);
    const errorResponsePlugin = (proxyServer, options)=>{
        proxyServer.on('error', (err, req, res, target)=>{
            if (!req && !res) {
                throw err;
            }
            if ('writeHead' in res && !res.headersSent) {
                const statusCode = (0, status_code_1.getStatusCode)(err.code);
                res.writeHead(statusCode);
            }
            const host = req.headers && req.headers.host;
            res.end(`Error occurred while trying to proxy: ${host}${req.url}`);
        });
    };
    exports.errorResponsePlugin = errorResponsePlugin;
}
,
"bc6cc539":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "FARM_TARGET_NODE_ENVS", ()=>FARM_TARGET_NODE_ENVS);
    module.o(exports, "FARM_TARGET_BROWSER_ENVS", ()=>FARM_TARGET_BROWSER_ENVS);
    module.o(exports, "FARM_TARGET_LIBRARY_ENVS", ()=>FARM_TARGET_LIBRARY_ENVS);
    module.o(exports, "isObject", ()=>isObject);
    module.o(exports, "isArray", ()=>isArray);
    module.o(exports, "isEmptyObject", ()=>isEmptyObject);
    module.o(exports, "isUndefined", ()=>isUndefined);
    module.o(exports, "isString", ()=>isString);
    module.o(exports, "isNumber", ()=>isNumber);
    module.o(exports, "isEmpty", ()=>isEmpty);
    module.o(exports, "isSymbol", ()=>isSymbol);
    module.o(exports, "isWindows", ()=>isWindows);
    module.o(exports, "pad", ()=>pad);
    module.o(exports, "clearScreen", ()=>clearScreen);
    module.o(exports, "version", ()=>version);
    module.o(exports, "normalizePath", ()=>normalizePath);
    module.o(exports, "normalizeBasePath", ()=>normalizeBasePath);
    module.o(exports, "arraify", ()=>arraify);
    module.o(exports, "getFileSystemStats", ()=>getFileSystemStats);
    module.o(exports, "toArray", ()=>toArray);
    module.o(exports, "mergeObjects", ()=>mergeObjects);
    module.o(exports, "asyncFlatten", ()=>asyncFlatten);
    module.o(exports, "sleep", ()=>sleep);
    module.o(exports, "preventExperimentalWarning", ()=>preventExperimentalWarning);
    module.o(exports, "mapTargetEnvValue", ()=>mapTargetEnvValue);
    module.o(exports, "tryStatSync", ()=>tryStatSync);
    module.o(exports, "isNodeEnv", ()=>isNodeEnv);
    var _f_node_fs = module.i(farmRequire('node:fs'));
    var _f_node_os = module.i(farmRequire('node:os'));
    var _f_node_path = module.w(farmRequire('node:path'));
    var _f_node_readline = module.i(farmRequire('node:readline'));
    var _f_node_url = farmRequire('node:url');
    const __dirname = _f_node_path.dirname(_f_node_url.fileURLToPath(module.meta.url));
    const splitRE = /\r?\n/;
    var FARM_TARGET_NODE_ENVS = [
        'node',
        'node16',
        'node-legacy',
        'node-next'
    ];
    var FARM_TARGET_BROWSER_ENVS = [
        'browser',
        'browser-legacy',
        'browser-es2015',
        'browser-es2017',
        'browser-esnext'
    ];
    var FARM_TARGET_LIBRARY_ENVS = [
        'library',
        'library-node',
        'library-browser'
    ];
    function isObject(value) {
        return Object.prototype.toString.call(value) === '[object Object]';
    }
    function isArray(value) {
        return Array.isArray(value);
    }
    function isEmptyObject(obj) {
        if (!obj) return true;
        return Reflect.ownKeys(obj).length === 0;
    }
    var isUndefined = (obj)=>typeof obj === 'undefined';
    var isString = (val)=>typeof val === 'string';
    var isNumber = (val)=>typeof val === 'number';
    var isEmpty = (array)=>!(array && array.length > 0);
    var isSymbol = (val)=>typeof val === 'symbol';
    var isWindows = module.f(_f_node_os).platform() === 'win32';
    function pad(source, n = 2) {
        const lines = source.split(splitRE);
        return lines.map((l)=>` `.repeat(n) + l).join(`\n`);
    }
    function clearScreen() {
        try {
            const repeatCount = process.stdout.rows - 2;
            const blank = repeatCount > 0 ? '\n'.repeat(repeatCount) : '';
            console.log(blank);
            module.f(_f_node_readline).cursorTo(process.stdout, 0, 0);
            module.f(_f_node_readline).clearScreenDown(process.stdout);
        } catch (error) {
            console.error('Failed to clear screen:', error);
        }
    }
    var version = JSON.parse(module.f(_f_node_fs).readFileSync(module.f(_f_node_path).resolve(__dirname, '../../package.json')).toString()).version;
    function normalizePath(id) {
        return module.f(_f_node_path).posix.normalize(id);
    }
    function normalizeBasePath(basePath) {
        return module.f(_f_node_path).posix.normalize(isWindows ? basePath.replace(/\\/g, '/') : basePath);
    }
    function arraify(target) {
        return Array.isArray(target) ? target : [
            target
        ];
    }
    function getFileSystemStats(file) {
        try {
            return module.f(_f_node_fs).statSync(file, {
                throwIfNoEntry: false
            });
        } catch (error) {
            console.error(`Error accessing file ${file}:`, error);
            return undefined;
        }
    }
    function toArray(array) {
        return array ? Array.isArray(array) ? array : [
            array
        ] : [];
    }
    function mergeObjects(obj1, obj2) {
        const merged = {
            ...obj1
        };
        Object.keys(obj2).forEach((key)=>{
            if (Object.prototype.hasOwnProperty.call(obj2, key)) {
                if (merged.hasOwnProperty(key) && typeof obj2[key] === 'object' && !Array.isArray(obj2[key])) {
                    merged[key] = mergeObjects(merged[key], obj2[key]);
                } else {
                    merged[key] = obj2[key];
                }
            }
        });
        return merged;
    }
    async function asyncFlatten(arr) {
        do {
            arr = (await Promise.all(arr)).flat(Infinity);
        }while (arr.some((v)=>v?.then))
        return arr;
    }
    function sleep(ms) {
        return new Promise((resolve)=>setTimeout(resolve, ms));
    }
    function preventExperimentalWarning() {
        const defaultEmit = process.emit;
        process.emit = function(...args) {
            if (args[1].name === 'ExperimentalWarning') {
                return undefined;
            }
            return defaultEmit.call(this, ...args);
        };
    }
    function mapTargetEnvValue(config) {
        if (FARM_TARGET_NODE_ENVS.includes(config.output.targetEnv)) {
            config.output.targetEnv = 'node';
        } else if (FARM_TARGET_BROWSER_ENVS.includes(config.output.targetEnv)) {
            config.output.targetEnv = 'browser';
        } else {
            if (FARM_TARGET_LIBRARY_ENVS.includes(config.output.targetEnv)) {
                return;
            }
            config.output.targetEnv = 'library-browser';
        }
    }
    function tryStatSync(file) {
        try {
            return module.f(_f_node_fs).statSync(file, {
                throwIfNoEntry: false
            });
        } catch  {}
    }
    function isNodeEnv(env) {
        return /^(node|library)(?!-browser)/.test(env);
    }
}
,
"bd075d6a":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "Server", ()=>Server);
    var _f_node_http = module.i(farmRequire('node:http'));
    var _f_node_http2 = module.i(farmRequire('node:http2'));
    var _f_node_https = module.w(farmRequire('node:https'));
    var httpsServer = _f_node_https;
    var _f_koa = module.i(farmRequire("a309845c"));
    var _f_koa_compress = module.i(farmRequire("587b96f0"));
    var _f_node_path = module.i(farmRequire('node:path'));
    var _f_node_util = farmRequire('node:util');
    var _f__global = farmRequire("93658e5a");
    var _f_index = farmRequire("491ca098");
    var _f_normalize_output = farmRequire("ca85d3ee");
    var _f_http = farmRequire("84a68c6c");
    var _f_index1 = farmRequire("65ad6846");
    var _f_error = farmRequire("972397d2");
    var _f_hmr_engine = farmRequire("7bf476fc");
    var _f_hmrPing = farmRequire("d8ec500a");
    var _f_index2 = farmRequire("5da88193");
    var _f_open = farmRequire("5506fbab");
    var _f_ws = module.i(farmRequire("a046a4f5"));
    class Server {
        _app;
        restart_promise = null;
        compiler;
        logger;
        ws;
        config;
        hmrEngine;
        server;
        publicDir;
        publicPath;
        resolvedUrls;
        watcher;
        constructor({ compiler = null, logger }){
            this.compiler = compiler;
            this.logger = logger ?? new _f_index1.Logger();
            this.initializeKoaServer();
            if (!compiler) return;
            this.publicDir = _f_index.normalizePublicDir(compiler?.config.config.root);
            this.publicPath = _f_normalize_output.normalizePublicPath(compiler.config.config.output.targetEnv, compiler.config.config.output.publicPath, logger, false) || '/';
        }
        getCompiler() {
            return this.compiler;
        }
        app() {
            return this._app;
        }
        async listen() {
            if (!this.server) {
                this.logger.error('HTTP server is not created yet');
                return;
            }
            const { port, open, protocol, hostname } = this.config;
            const start = Date.now();
            await this.compile();
            this.watcher?.watchExtraFiles?.();
            _f_index1.bootstrap(Date.now() - start, this.compiler.config);
            await this.startServer(this.config);
            !_f__global.__FARM_GLOBAL__.__FARM_RESTART_DEV_SERVER__ && await this.displayServerUrls();
            if (open) {
                let publicPath = _f_normalize_output.getValidPublicPath(this.publicPath) || '/';
                const serverUrl = `${protocol}://${hostname.name}:${port}${publicPath}`;
                _f_open.openBrowser(serverUrl);
            }
        }
        async compile() {
            try {
                await this.compiler.compile();
            } catch (err) {
                throw new Error(_f_error.logError(err));
            }
            if (this.config.writeToDisk) {
                this.compiler.writeResourcesToDisk();
            } else {
                this.compiler.callWriteResourcesHook();
            }
        }
        async startServer(serverOptions) {
            const { port, hostname } = serverOptions;
            const listen = _f_node_util.promisify(this.server.listen).bind(this.server);
            try {
                await listen(port, hostname.host);
            } catch (error) {
                this.handleServerError(error, port, hostname.host);
            }
        }
        handleServerError(error, port, host) {
            const errorMap = {
                EACCES: `Permission denied to use port ${port} `,
                EADDRNOTAVAIL: `The IP address host: ${host} is not available on this machine.`
            };
            const errorMessage = errorMap[error.code] || `An error occurred: ${error.stack} `;
            this.logger.error(errorMessage);
        }
        async close() {
            if (!this.server) {
                this.logger.error('HTTP server is not created yet');
            }
            if (!this.server.listening) {
                return;
            }
            const promises = [];
            if (this.ws) {
                promises.push(this.ws.close());
            }
            if (this.server) {
                promises.push(new Promise((resolve)=>this.server.close(resolve)));
            }
            await Promise.all(promises);
        }
        async restart(promise) {
            if (!this.restart_promise) {
                this.restart_promise = promise();
            }
            return this.restart_promise;
        }
        initializeKoaServer() {
            this._app = new (module.f(_f_koa))();
        }
        createServer(options) {
            const { https, host } = options;
            const protocol = https ? 'https' : 'http';
            const hostname = _f_http.resolveHostname(host);
            const publicPath = _f_normalize_output.getValidPublicPath(this.compiler?.config.config.output?.publicPath ?? options?.output.publicPath);
            const hmrPath = _f_index1.normalizeBasePath(module.f(_f_node_path).join(publicPath, options.hmr.path ?? _f_index.DEFAULT_HMR_OPTIONS.path));
            this.config = {
                ...options,
                port: Number(process.env.FARM_DEV_SERVER_PORT || options.port),
                hmr: {
                    ...options.hmr,
                    path: hmrPath
                },
                protocol,
                hostname
            };
            const isProxy = Object.keys(options.proxy).length;
            if (https) {
                if (isProxy) {
                    this.server = httpsServer.createServer(https, this._app.callback());
                } else {
                    this.server = module.f(_f_node_http2).createSecureServer({
                        maxSessionMemory: 1000,
                        ...https,
                        allowHTTP1: true
                    }, this._app.callback());
                }
            } else {
                this.server = module.f(_f_node_http).createServer(this._app.callback());
            }
        }
        createWebSocket() {
            if (!this.server) {
                throw new Error('Websocket requires a server.');
            }
            this.ws = new (module.f(_f_ws))(this.server, this.config, this.hmrEngine);
        }
        invalidateVite() {
            this.ws.on('vite:invalidate', ({ path, message })=>{
                this.logger.info(`HMR invalidate: ${path}. ${message ?? ''} `);
                const parentFiles = this.compiler.getParentFiles(path);
                this.hmrEngine.hmrUpdate(parentFiles, true);
            });
        }
        async createPreviewServer(options) {
            this.createServer(options);
            this.applyPreviewServerMiddlewares(this.config.middlewares);
            await this.startServer(this.config);
            await this.displayServerUrls(true);
        }
        async createDevServer(options) {
            if (!this.compiler) {
                throw new Error('DevServer requires a compiler for development mode.');
            }
            this.createServer(options);
            this.hmrEngine = new _f_hmr_engine.HmrEngine(this.compiler, this, this.logger);
            this.createWebSocket();
            this.invalidateVite();
            this.applyServerMiddlewares(options.middlewares);
        }
        static async resolvePortConflict(normalizedDevConfig, logger) {
            let devPort = normalizedDevConfig.port;
            let hmrPort = normalizedDevConfig.hmr.port;
            const { strictPort, host } = normalizedDevConfig;
            const httpServer = module.f(_f_node_http).createServer();
            const isPortAvailable = (portToCheck)=>{
                return new Promise((resolve, reject)=>{
                    const onError = async (error)=>{
                        if (error.code === 'EADDRINUSE') {
                            _f_index1.clearScreen();
                            if (strictPort) {
                                httpServer.removeListener('error', onError);
                                reject(new Error(`Port ${devPort} is already in use`));
                            } else {
                                logger.warn(`Port ${devPort} is in use, trying another one...`);
                                httpServer.removeListener('error', onError);
                                resolve(false);
                            }
                        } else {
                            logger.error(`Error in httpServer: ${error} `);
                            reject(true);
                        }
                    };
                    httpServer.on('error', onError);
                    httpServer.on('listening', ()=>{
                        httpServer.close();
                        resolve(true);
                    });
                    httpServer.listen(portToCheck, host);
                });
            };
            let isPortAvailableResult = await isPortAvailable(devPort);
            while(isPortAvailableResult === false){
                if (typeof normalizedDevConfig.hmr === 'object') {
                    normalizedDevConfig.hmr.port = ++hmrPort;
                }
                normalizedDevConfig.port = ++devPort;
                isPortAvailableResult = await isPortAvailable(devPort);
            }
        }
        addWatchFile(root, deps) {
            this.getCompiler().addExtraWatchFile(root, deps);
        }
        applyMiddlewares(internalMiddlewares) {
            internalMiddlewares.forEach((middleware)=>{
                const middlewareImpl = middleware(this);
                if (middlewareImpl) {
                    if (Array.isArray(middlewareImpl)) {
                        middlewareImpl.forEach((m)=>{
                            this._app.use(m);
                        });
                    } else {
                        this._app.use(middlewareImpl);
                    }
                }
            });
        }
        setCompiler(compiler) {
            this.compiler = compiler;
        }
        applyPreviewServerMiddlewares(middlewares) {
            const internalMiddlewares = [
                ...middlewares || [],
                module.f(_f_koa_compress),
                _f_index2.proxy,
                _f_index2.staticMiddleware
            ];
            this.applyMiddlewares(internalMiddlewares);
        }
        applyServerMiddlewares(middlewares) {
            const internalMiddlewares = [
                ...middlewares || [],
                _f_hmrPing.hmrPing,
                _f_index2.headers,
                _f_index2.lazyCompilation,
                _f_index2.cors,
                _f_index2.resources,
                _f_index2.proxy
            ];
            this.applyMiddlewares(internalMiddlewares);
        }
        async displayServerUrls(showPreviewFlag = false) {
            let publicPath = _f_normalize_output.getValidPublicPath(this.compiler ? this.compiler.config.config.output?.publicPath : this.config.output.publicPath);
            this.resolvedUrls = _f_http.resolveServerUrls(this.server, this.config, publicPath);
            if (this.resolvedUrls) {
                _f_index1.printServerUrls(this.resolvedUrls, this.logger, showPreviewFlag);
            } else {
                throw new Error('cannot print server URLs with Server Error.');
            }
        }
    }
}
,
"bdb95f7e":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const { tokenChars } = farmRequire("9887cd18", true);
    function parse(header) {
        const protocols = new Set();
        let start = -1;
        let end = -1;
        let i = 0;
        for(i; i < header.length; i++){
            const code = header.charCodeAt(i);
            if (end === -1 && tokenChars[code] === 1) {
                if (start === -1) start = i;
            } else if (i !== 0 && (code === 0x20 || code === 0x09)) {
                if (end === -1 && start !== -1) end = i;
            } else if (code === 0x2c) {
                if (start === -1) {
                    throw new SyntaxError(`Unexpected character at index ${i}`);
                }
                if (end === -1) end = i;
                const protocol = header.slice(start, end);
                if (protocols.has(protocol)) {
                    throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
                }
                protocols.add(protocol);
                start = end = -1;
            } else {
                throw new SyntaxError(`Unexpected character at index ${i}`);
            }
        }
        if (start === -1 || end !== -1) {
            throw new SyntaxError('Unexpected end of input');
        }
        const protocol = header.slice(start, i);
        if (protocols.has(protocol)) {
            throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
        }
        protocols.add(protocol);
        return protocols;
    }
    module.exports = {
        parse
    };
}
,
"be5cf725":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.statSync = exports.stat = exports.Settings = void 0;
    const async = farmRequire("e07bf137", true);
    const sync = farmRequire("d12f57da", true);
    const settings_1 = farmRequire("9b4982dd", true);
    exports.Settings = settings_1.default;
    function stat(path, optionsOrSettingsOrCallback, callback) {
        if (typeof optionsOrSettingsOrCallback === 'function') {
            async.read(path, getSettings(), optionsOrSettingsOrCallback);
            return;
        }
        async.read(path, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports.stat = stat;
    function statSync(path, optionsOrSettings) {
        const settings = getSettings(optionsOrSettings);
        return sync.read(path, settings);
    }
    exports.statSync = statSync;
    function getSettings(settingsOrOptions = {}) {
        if (settingsOrOptions instanceof settings_1.default) {
            return settingsOrOptions;
        }
        return new settings_1.default(settingsOrOptions);
    }
}
,
"be796aa1":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.signalsByNumber = exports.signalsByName = void 0;
    var _os = global.nodeRequire("os", true);
    var _signals = farmRequire("0f80e9b2", true);
    var _realtime = farmRequire("54541ffb", true);
    const getSignalsByName = function() {
        const signals = (0, _signals.getSignals)();
        return signals.reduce(getSignalByName, {});
    };
    const getSignalByName = function(signalByNameMemo, { name, number, description, supported, action, forced, standard }) {
        return {
            ...signalByNameMemo,
            [name]: {
                name,
                number,
                description,
                supported,
                action,
                forced,
                standard
            }
        };
    };
    const signalsByName = getSignalsByName();
    exports.signalsByName = signalsByName;
    const getSignalsByNumber = function() {
        const signals = (0, _signals.getSignals)();
        const length = _realtime.SIGRTMAX + 1;
        const signalsA = Array.from({
            length
        }, (value, number)=>getSignalByNumber(number, signals));
        return Object.assign({}, ...signalsA);
    };
    const getSignalByNumber = function(number, signals) {
        const signal = findSignalByNumber(number, signals);
        if (signal === undefined) {
            return {};
        }
        const { name, description, supported, action, forced, standard } = signal;
        return {
            [number]: {
                name,
                number,
                description,
                supported,
                action,
                forced,
                standard
            }
        };
    };
    const findSignalByNumber = function(number, signals) {
        const signal = signals.find(({ name })=>_os.constants.signals[name] === number);
        if (signal !== undefined) {
            return signal;
        }
        return signals.find((signalA)=>signalA.number === number);
    };
    const signalsByNumber = getSignalsByNumber();
    exports.signalsByNumber = signalsByNumber;
}
,
"bf50199b":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "VIRTUAL_FARM_DYNAMIC_IMPORT_SUFFIX", ()=>VIRTUAL_FARM_DYNAMIC_IMPORT_SUFFIX);
    module.o(exports, "Compiler", ()=>Compiler);
    var _f_node_fs = farmRequire('node:fs');
    var _f_node_path = module.i(farmRequire('node:path'));
    var _f_index = farmRequire("1594525d");
    var _f_logger = farmRequire("8c2028dc");
    var VIRTUAL_FARM_DYNAMIC_IMPORT_SUFFIX = '.farm_dynamic_import_virtual_module';
    class Compiler {
        config;
        logger;
        _bindingCompiler;
        _updateQueue;
        _onUpdateFinishQueue;
        compiling;
        constructor(config, logger = new _f_logger.Logger()){
            this.config = config;
            this.logger = logger;
            this._updateQueue = [];
            this._onUpdateFinishQueue = [];
            this.compiling = false;
            this._bindingCompiler = new _f_index.Compiler(this.config);
        }
        async traceDependencies() {
            return this._bindingCompiler.traceDependencies();
        }
        async traceModuleGraph() {
            return this._bindingCompiler.traceModuleGraph();
        }
        async compile() {
            if (this.compiling) {
                this.logger.error('Already compiling', {
                    exit: true
                });
            }
            this.compiling = true;
            if (process.env.FARM_PROFILE) {
                this._bindingCompiler.compileSync();
            } else {
                await this._bindingCompiler.compile();
            }
            this.compiling = false;
        }
        compileSync() {
            if (this.compiling) {
                this.logger.error('Already compiling', {
                    exit: true
                });
            }
            this.compiling = true;
            this._bindingCompiler.compileSync();
            this.compiling = false;
        }
        async update(paths, sync = false, ignoreCompilingCheck = false, generateUpdateResource = true) {
            let resolve;
            const promise = new Promise((r)=>{
                resolve = r;
            });
            if (this.compiling && !ignoreCompilingCheck) {
                this._updateQueue.push({
                    paths,
                    resolve
                });
                return promise;
            }
            this.compiling = true;
            try {
                const res = await this._bindingCompiler.update(paths, async ()=>{
                    const next = this._updateQueue.shift();
                    if (next) {
                        await this.update(next.paths, true, true, generateUpdateResource).then(next.resolve);
                    } else {
                        this.compiling = false;
                        while(this._onUpdateFinishQueue.length){
                            if (this.compiling) {
                                break;
                            }
                            const cb = this._onUpdateFinishQueue.shift();
                            await cb();
                        }
                    }
                }, sync, generateUpdateResource);
                return res;
            } catch (e) {
                this.compiling = false;
                throw e;
            }
        }
        hasModule(resolvedPath) {
            return this._bindingCompiler.hasModule(resolvedPath);
        }
        getParentFiles(idOrResolvedPath) {
            return this._bindingCompiler.getParentFiles(idOrResolvedPath);
        }
        resources() {
            return this._bindingCompiler.resources();
        }
        resource(path) {
            return this._bindingCompiler.resource(path);
        }
        resourcesMap() {
            return this._bindingCompiler.resourcesMap();
        }
        writeResourcesToDisk() {
            const resources = this.resources();
            const configOutputPath = this.config.config.output.path;
            const outputPath = module.f(_f_node_path).isAbsolute(configOutputPath) ? configOutputPath : module.f(_f_node_path).join(this.config.config.root, configOutputPath);
            for (const [name, resource] of Object.entries(resources)){
                const nameWithoutQuery = name.split('?')[0];
                const nameWithoutHash = nameWithoutQuery.split('#')[0];
                let filePath = module.f(_f_node_path).join(outputPath, nameWithoutHash);
                if (!_f_node_fs.existsSync(module.f(_f_node_path).dirname(filePath))) {
                    _f_node_fs.mkdirSync(module.f(_f_node_path).dirname(filePath), {
                        recursive: true
                    });
                }
                _f_node_fs.writeFileSync(filePath, resource);
            }
            this.callWriteResourcesHook();
        }
        callWriteResourcesHook() {
            for (const jsPlugin of this.config.jsPlugins ?? []){
                jsPlugin.writeResources?.executor?.({
                    resourcesMap: this._bindingCompiler.resourcesMap(),
                    config: this.config.config
                });
            }
        }
        removeOutputPathDir() {
            const outputPath = this.outputPath();
            if (_f_node_fs.existsSync(outputPath)) {
                _f_node_fs.rmSync(outputPath, {
                    recursive: true
                });
            }
        }
        resolvedWatchPaths() {
            return this._bindingCompiler.watchModules();
        }
        resolvedModulePaths(root) {
            return this._bindingCompiler.relativeModulePaths().map((p)=>this.transformModulePath(root, p));
        }
        transformModulePath(root, p) {
            if (p.endsWith(VIRTUAL_FARM_DYNAMIC_IMPORT_SUFFIX)) {
                p = p.slice(0, -VIRTUAL_FARM_DYNAMIC_IMPORT_SUFFIX.length);
            }
            if (module.f(_f_node_path).isAbsolute(p)) {
                return p;
            }
            if (p.includes('?')) {
                return module.f(_f_node_path).join(root, p.split('?')[0]);
            }
            return module.f(_f_node_path).join(root, p);
        }
        onUpdateFinish(cb) {
            this._onUpdateFinishQueue.push(cb);
        }
        outputPath() {
            const { output, root } = this.config.config;
            const configOutputPath = output.path;
            const outputPath = module.f(_f_node_path).isAbsolute(configOutputPath) ? configOutputPath : module.f(_f_node_path).join(root, configOutputPath);
            return outputPath;
        }
        addExtraWatchFile(root, paths) {
            this._bindingCompiler.addWatchFiles(root, paths);
        }
        stats() {
            return this._bindingCompiler.stats();
        }
        invalidateModule(moduleId) {
            this._bindingCompiler.invalidateModule(moduleId);
        }
    }
}
,
"c074a41a":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "default", ()=>merge);
    var _f_deepmerge = module.i(farmRequire("2b4138b2"));
    var _f_is_plain_object = farmRequire("2da46d7c");
    var _f_share = farmRequire("bc6cc539");
    function isValueSameDeep(target, source) {
        if (target === source) {
            return true;
        }
        if (!isMergeableObject(target) || !isMergeableObject(source)) {
            return false;
        }
        if (Object.keys(target).length !== Object.keys(source).length) {
            return false;
        }
        for(const key in source){
            if (!isValueSameDeep(target[key], source[key])) {
                return false;
            }
        }
        return true;
    }
    function isMergeableObject(obj) {
        return _f_is_plain_object.isPlainObject(obj) || Array.isArray(obj);
    }
    const arrayMerge = (target, source, options)=>{
        const destination = target.slice();
        source.forEach((item, index)=>{
            if (typeof destination[index] === 'undefined') {
                destination[index] = options.cloneUnlessOtherwiseSpecified(item, options);
            } else if (!destination.find((dest)=>isValueSameDeep(dest, item))) {
                destination.push(item);
            }
        });
        return destination.filter((item)=>item !== undefined);
    };
    const options = {
        arrayMerge,
        isMergeableObject
    };
    function merge(target, ...sources) {
        let destination = {
            ...target
        };
        for (const source of sources){
            if (!source) continue;
            if (_f_is_plain_object.isPlainObject(destination) && _f_is_plain_object.isPlainObject(source)) {
                for (const key of Object.keys(source)){
                    const sourceValue = source[key];
                    if (sourceValue === undefined) {
                        continue;
                    } else if (isMergeableObject(destination[key]) && isMergeableObject(sourceValue)) {
                        destination[key] = module.f(_f_deepmerge)(destination[key], sourceValue, options);
                    } else {
                        if (_f_is_plain_object.isPlainObject(sourceValue)) {
                            destination[key] = module.f(_f_deepmerge)({}, sourceValue, options);
                        } else if (_f_share.isArray(sourceValue)) {
                            destination[key] = module.f(_f_deepmerge)([], sourceValue, options);
                        } else {
                            destination[key] = sourceValue;
                        }
                    }
                }
            } else {
                destination = module.f(_f_deepmerge)(destination, source, options);
            }
        }
        return destination;
    }
}
,
"c0be1d25":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const debug = farmRequire("9ff09f2c")('koa-static');
    const { resolve } = global.nodeRequire('path', true);
    const assert = global.nodeRequire('assert', true);
    const send = farmRequire("0403cc2d", true);
    module.exports = serve;
    function serve(root, opts) {
        opts = Object.assign({}, opts);
        assert(root, 'root directory is required to serve files');
        debug('static "%s" %j', root, opts);
        opts.root = resolve(root);
        if (opts.index !== false) opts.index = opts.index || 'index.html';
        if (!opts.defer) {
            return async function serve(ctx, next) {
                let done = false;
                if (ctx.method === 'HEAD' || ctx.method === 'GET') {
                    try {
                        done = await send(ctx, ctx.path, opts);
                    } catch (err) {
                        if (err.status !== 404) {
                            throw err;
                        }
                    }
                }
                if (!done) {
                    await next();
                }
            };
        }
        return async function serve(ctx, next) {
            await next();
            if (ctx.method !== 'HEAD' && ctx.method !== 'GET') return;
            if (ctx.body != null || ctx.status !== 404) return;
            try {
                await send(ctx, ctx.path, opts);
            } catch (err) {
                if (err.status !== 404) {
                    throw err;
                }
            }
        };
    }
}
,
"c0f10885":function  (module, exports, farmRequire, farmDynamicRequire) {
    if (typeof Object.create === 'function') {
        module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                    value: ctor,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
        };
    } else {
        module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {};
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
        };
    }
}
,
"c3831ec6":function  (module, exports, farmRequire, farmDynamicRequire) {
    var pSlice = Array.prototype.slice;
    var objectKeys = farmRequire("40c7ffaa", true);
    var isArguments = farmRequire("8276c222", true);
    var deepEqual = module.exports = function(actual, expected, opts) {
        if (!opts) opts = {};
        if (actual === expected) {
            return true;
        } else if (actual instanceof Date && expected instanceof Date) {
            return actual.getTime() === expected.getTime();
        } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
            return opts.strict ? actual === expected : actual == expected;
        } else {
            return objEquiv(actual, expected, opts);
        }
    };
    function isUndefinedOrNull(value) {
        return value === null || value === undefined;
    }
    function isBuffer(x) {
        if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
        if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
            return false;
        }
        if (x.length > 0 && typeof x[0] !== 'number') return false;
        return true;
    }
    function objEquiv(a, b, opts) {
        var i, key;
        if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) return false;
        if (a.prototype !== b.prototype) return false;
        if (isArguments(a)) {
            if (!isArguments(b)) {
                return false;
            }
            a = pSlice.call(a);
            b = pSlice.call(b);
            return deepEqual(a, b, opts);
        }
        if (isBuffer(a)) {
            if (!isBuffer(b)) {
                return false;
            }
            if (a.length !== b.length) return false;
            for(i = 0; i < a.length; i++){
                if (a[i] !== b[i]) return false;
            }
            return true;
        }
        try {
            var ka = objectKeys(a), kb = objectKeys(b);
        } catch (e) {
            return false;
        }
        if (ka.length != kb.length) return false;
        ka.sort();
        kb.sort();
        for(i = ka.length - 1; i >= 0; i--){
            if (ka[i] != kb[i]) return false;
        }
        for(i = ka.length - 1; i >= 0; i--){
            key = ka[i];
            if (!deepEqual(a[key], b[key], opts)) return false;
        }
        return typeof a === typeof b;
    }
}
,
"c39a2a9f":/*!
 * media-typer
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
    var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/;
    var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/;
    var qescRegExp = /\\([\u0000-\u007f])/g;
    var quoteRegExp = /([\\"])/g;
    var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
    var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
    var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
    exports.format = format;
    exports.parse = parse;
    function format(obj) {
        if (!obj || typeof obj !== 'object') {
            throw new TypeError('argument obj is required');
        }
        var parameters = obj.parameters;
        var subtype = obj.subtype;
        var suffix = obj.suffix;
        var type = obj.type;
        if (!type || !typeNameRegExp.test(type)) {
            throw new TypeError('invalid type');
        }
        if (!subtype || !subtypeNameRegExp.test(subtype)) {
            throw new TypeError('invalid subtype');
        }
        var string = type + '/' + subtype;
        if (suffix) {
            if (!typeNameRegExp.test(suffix)) {
                throw new TypeError('invalid suffix');
            }
            string += '+' + suffix;
        }
        if (parameters && typeof parameters === 'object') {
            var param;
            var params = Object.keys(parameters).sort();
            for(var i = 0; i < params.length; i++){
                param = params[i];
                if (!tokenRegExp.test(param)) {
                    throw new TypeError('invalid parameter name');
                }
                string += '; ' + param + '=' + qstring(parameters[param]);
            }
        }
        return string;
    }
    function parse(string) {
        if (!string) {
            throw new TypeError('argument string is required');
        }
        if (typeof string === 'object') {
            string = getcontenttype(string);
        }
        if (typeof string !== 'string') {
            throw new TypeError('argument string is required to be a string');
        }
        var index = string.indexOf(';');
        var type = index !== -1 ? string.substr(0, index) : string;
        var key;
        var match;
        var obj = splitType(type);
        var params = {};
        var value;
        paramRegExp.lastIndex = index;
        while(match = paramRegExp.exec(string)){
            if (match.index !== index) {
                throw new TypeError('invalid parameter format');
            }
            index += match[0].length;
            key = match[1].toLowerCase();
            value = match[2];
            if (value[0] === '"') {
                value = value.substr(1, value.length - 2).replace(qescRegExp, '$1');
            }
            params[key] = value;
        }
        if (index !== -1 && index !== string.length) {
            throw new TypeError('invalid parameter format');
        }
        obj.parameters = params;
        return obj;
    }
    function getcontenttype(obj) {
        if (typeof obj.getHeader === 'function') {
            return obj.getHeader('content-type');
        }
        if (typeof obj.headers === 'object') {
            return obj.headers && obj.headers['content-type'];
        }
    }
    function qstring(val) {
        var str = String(val);
        if (tokenRegExp.test(str)) {
            return str;
        }
        if (str.length > 0 && !textRegExp.test(str)) {
            throw new TypeError('invalid parameter value');
        }
        return '"' + str.replace(quoteRegExp, '\\$1') + '"';
    }
    function splitType(string) {
        var match = typeRegExp.exec(string.toLowerCase());
        if (!match) {
            throw new TypeError('invalid media type');
        }
        var type = match[1];
        var subtype = match[2];
        var suffix;
        var index = subtype.lastIndexOf('+');
        if (index !== -1) {
            suffix = subtype.substr(index + 1);
            subtype = subtype.substr(0, index);
        }
        var obj = {
            type: type,
            subtype: subtype,
            suffix: suffix
        };
        return obj;
    }
}
,
"c3ca2b6a":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    var isGlob = farmRequire("d0830e44", true);
    var pathPosixDirname = global.nodeRequire('path', true).posix.dirname;
    var isWin32 = global.nodeRequire('os', true).platform() === 'win32';
    var slash = '/';
    var backslash = /\\/g;
    var enclosure = /[\{\[].*[\}\]]$/;
    var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
    var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
    module.exports = function globParent(str, opts) {
        var options = Object.assign({
            flipBackslashes: true
        }, opts);
        if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
            str = str.replace(backslash, slash);
        }
        if (enclosure.test(str)) {
            str += slash;
        }
        str += 'a';
        do {
            str = pathPosixDirname(str);
        }while (isGlob(str) || globby.test(str))
        return str.replace(escaped, '$1');
    };
}
,
"c43cfb2b":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    var hasSymbols = farmRequire("16fd7f8c", true);
    module.exports = function hasToStringTagShams() {
        return hasSymbols() && !!Symbol.toStringTag;
    };
}
,
"c43e8a2b":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "default", ()=>defaultBrowser);
    var _f_node_process = module.i(farmRequire('node:process'));
    var _f_default_browser_id = module.i(farmRequire("69f658c7"));
    var _f_bundle_name = module.i(farmRequire("f3d69eed"));
    var _f_titleize = module.i(farmRequire("ac7fb814"));
    var _f_execa = farmRequire("1bdb2cdd");
    var _f_windows = module.i(farmRequire("ecdcd3ff"));
    async function defaultBrowser() {
        if (module.f(_f_node_process).platform === 'linux') {
            const { stdout } = await _f_execa.execa('xdg-mime', [
                'query',
                'default',
                'x-scheme-handler/http'
            ]);
            const name = module.f(_f_titleize)(stdout.trim().replace(/.desktop$/, '').replace('-', ' '));
            return {
                name,
                id: stdout
            };
        }
        if (module.f(_f_node_process).platform === 'darwin') {
            const id = await module.f(_f_default_browser_id)();
            const name = await module.f(_f_bundle_name)(id);
            return {
                name,
                id
            };
        }
        if (module.f(_f_node_process).platform === 'win32') {
            return module.f(_f_windows)();
        }
        throw new Error('Only macOS, Linux, and Windows are supported');
    }
}
,
"c658a5ad":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const os = global.nodeRequire('os', true);
    const homeDirectory = os.homedir();
    module.exports = (pathWithTilde)=>{
        if (typeof pathWithTilde !== 'string') {
            throw new TypeError(`Expected a string, got ${typeof pathWithTilde}`);
        }
        return homeDirectory ? pathWithTilde.replace(/^~(?=$|\/|\\)/, homeDirectory) : pathWithTilde;
    };
}
,
"c834c407":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const fs = farmRequire("ffc819a8", true);
    const path = global.nodeRequire('path', true);
    const copySync = farmRequire("d1ce3aa3", true).copySync;
    const removeSync = farmRequire("4ffdf2a8", true).removeSync;
    const mkdirpSync = farmRequire("abdb8a71", true).mkdirpSync;
    const stat = farmRequire("9c9fbd11", true);
    function moveSync(src, dest, opts) {
        opts = opts || {};
        const overwrite = opts.overwrite || opts.clobber || false;
        const { srcStat, isChangingCase = false } = stat.checkPathsSync(src, dest, 'move', opts);
        stat.checkParentPathsSync(src, srcStat, dest, 'move');
        if (!isParentRoot(dest)) mkdirpSync(path.dirname(dest));
        return doRename(src, dest, overwrite, isChangingCase);
    }
    function isParentRoot(dest) {
        const parent = path.dirname(dest);
        const parsedPath = path.parse(parent);
        return parsedPath.root === parent;
    }
    function doRename(src, dest, overwrite, isChangingCase) {
        if (isChangingCase) return rename(src, dest, overwrite);
        if (overwrite) {
            removeSync(dest);
            return rename(src, dest, overwrite);
        }
        if (fs.existsSync(dest)) throw new Error('dest already exists.');
        return rename(src, dest, overwrite);
    }
    function rename(src, dest, overwrite) {
        try {
            fs.renameSync(src, dest);
        } catch (err) {
            if (err.code !== 'EXDEV') throw err;
            return moveAcrossDevice(src, dest, overwrite);
        }
    }
    function moveAcrossDevice(src, dest, overwrite) {
        const opts = {
            overwrite,
            errorOnExist: true,
            preserveTimestamps: true
        };
        copySync(src, dest, opts);
        return removeSync(src);
    }
    module.exports = moveSync;
}
,
"c919b93f":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const utils = farmRequire("48dceba4", true);
    const { CHAR_ASTERISK, CHAR_AT, CHAR_BACKWARD_SLASH, CHAR_COMMA, CHAR_DOT, CHAR_EXCLAMATION_MARK, CHAR_FORWARD_SLASH, CHAR_LEFT_CURLY_BRACE, CHAR_LEFT_PARENTHESES, CHAR_LEFT_SQUARE_BRACKET, CHAR_PLUS, CHAR_QUESTION_MARK, CHAR_RIGHT_CURLY_BRACE, CHAR_RIGHT_PARENTHESES, CHAR_RIGHT_SQUARE_BRACKET } = farmRequire("685edf14", true);
    const isPathSeparator = (code)=>{
        return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    const depth = (token)=>{
        if (token.isPrefix !== true) {
            token.depth = token.isGlobstar ? Infinity : 1;
        }
    };
    const scan = (input, options)=>{
        const opts = options || {};
        const length = input.length - 1;
        const scanToEnd = opts.parts === true || opts.scanToEnd === true;
        const slashes = [];
        const tokens = [];
        const parts = [];
        let str = input;
        let index = -1;
        let start = 0;
        let lastIndex = 0;
        let isBrace = false;
        let isBracket = false;
        let isGlob = false;
        let isExtglob = false;
        let isGlobstar = false;
        let braceEscaped = false;
        let backslashes = false;
        let negated = false;
        let negatedExtglob = false;
        let finished = false;
        let braces = 0;
        let prev;
        let code;
        let token = {
            value: '',
            depth: 0,
            isGlob: false
        };
        const eos = ()=>index >= length;
        const peek = ()=>str.charCodeAt(index + 1);
        const advance = ()=>{
            prev = code;
            return str.charCodeAt(++index);
        };
        while(index < length){
            code = advance();
            let next;
            if (code === CHAR_BACKWARD_SLASH) {
                backslashes = token.backslashes = true;
                code = advance();
                if (code === CHAR_LEFT_CURLY_BRACE) {
                    braceEscaped = true;
                }
                continue;
            }
            if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
                braces++;
                while(eos() !== true && (code = advance())){
                    if (code === CHAR_BACKWARD_SLASH) {
                        backslashes = token.backslashes = true;
                        advance();
                        continue;
                    }
                    if (code === CHAR_LEFT_CURLY_BRACE) {
                        braces++;
                        continue;
                    }
                    if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
                        isBrace = token.isBrace = true;
                        isGlob = token.isGlob = true;
                        finished = true;
                        if (scanToEnd === true) {
                            continue;
                        }
                        break;
                    }
                    if (braceEscaped !== true && code === CHAR_COMMA) {
                        isBrace = token.isBrace = true;
                        isGlob = token.isGlob = true;
                        finished = true;
                        if (scanToEnd === true) {
                            continue;
                        }
                        break;
                    }
                    if (code === CHAR_RIGHT_CURLY_BRACE) {
                        braces--;
                        if (braces === 0) {
                            braceEscaped = false;
                            isBrace = token.isBrace = true;
                            finished = true;
                            break;
                        }
                    }
                }
                if (scanToEnd === true) {
                    continue;
                }
                break;
            }
            if (code === CHAR_FORWARD_SLASH) {
                slashes.push(index);
                tokens.push(token);
                token = {
                    value: '',
                    depth: 0,
                    isGlob: false
                };
                if (finished === true) continue;
                if (prev === CHAR_DOT && index === start + 1) {
                    start += 2;
                    continue;
                }
                lastIndex = index + 1;
                continue;
            }
            if (opts.noext !== true) {
                const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
                if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
                    isGlob = token.isGlob = true;
                    isExtglob = token.isExtglob = true;
                    finished = true;
                    if (code === CHAR_EXCLAMATION_MARK && index === start) {
                        negatedExtglob = true;
                    }
                    if (scanToEnd === true) {
                        while(eos() !== true && (code = advance())){
                            if (code === CHAR_BACKWARD_SLASH) {
                                backslashes = token.backslashes = true;
                                code = advance();
                                continue;
                            }
                            if (code === CHAR_RIGHT_PARENTHESES) {
                                isGlob = token.isGlob = true;
                                finished = true;
                                break;
                            }
                        }
                        continue;
                    }
                    break;
                }
            }
            if (code === CHAR_ASTERISK) {
                if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
                isGlob = token.isGlob = true;
                finished = true;
                if (scanToEnd === true) {
                    continue;
                }
                break;
            }
            if (code === CHAR_QUESTION_MARK) {
                isGlob = token.isGlob = true;
                finished = true;
                if (scanToEnd === true) {
                    continue;
                }
                break;
            }
            if (code === CHAR_LEFT_SQUARE_BRACKET) {
                while(eos() !== true && (next = advance())){
                    if (next === CHAR_BACKWARD_SLASH) {
                        backslashes = token.backslashes = true;
                        advance();
                        continue;
                    }
                    if (next === CHAR_RIGHT_SQUARE_BRACKET) {
                        isBracket = token.isBracket = true;
                        isGlob = token.isGlob = true;
                        finished = true;
                        break;
                    }
                }
                if (scanToEnd === true) {
                    continue;
                }
                break;
            }
            if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
                negated = token.negated = true;
                start++;
                continue;
            }
            if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
                isGlob = token.isGlob = true;
                if (scanToEnd === true) {
                    while(eos() !== true && (code = advance())){
                        if (code === CHAR_LEFT_PARENTHESES) {
                            backslashes = token.backslashes = true;
                            code = advance();
                            continue;
                        }
                        if (code === CHAR_RIGHT_PARENTHESES) {
                            finished = true;
                            break;
                        }
                    }
                    continue;
                }
                break;
            }
            if (isGlob === true) {
                finished = true;
                if (scanToEnd === true) {
                    continue;
                }
                break;
            }
        }
        if (opts.noext === true) {
            isExtglob = false;
            isGlob = false;
        }
        let base = str;
        let prefix = '';
        let glob = '';
        if (start > 0) {
            prefix = str.slice(0, start);
            str = str.slice(start);
            lastIndex -= start;
        }
        if (base && isGlob === true && lastIndex > 0) {
            base = str.slice(0, lastIndex);
            glob = str.slice(lastIndex);
        } else if (isGlob === true) {
            base = '';
            glob = str;
        } else {
            base = str;
        }
        if (base && base !== '' && base !== '/' && base !== str) {
            if (isPathSeparator(base.charCodeAt(base.length - 1))) {
                base = base.slice(0, -1);
            }
        }
        if (opts.unescape === true) {
            if (glob) glob = utils.removeBackslashes(glob);
            if (base && backslashes === true) {
                base = utils.removeBackslashes(base);
            }
        }
        const state = {
            prefix,
            input,
            start,
            base,
            glob,
            isBrace,
            isBracket,
            isGlob,
            isExtglob,
            isGlobstar,
            negated,
            negatedExtglob
        };
        if (opts.tokens === true) {
            state.maxDepth = 0;
            if (!isPathSeparator(code)) {
                tokens.push(token);
            }
            state.tokens = tokens;
        }
        if (opts.parts === true || opts.tokens === true) {
            let prevIndex;
            for(let idx = 0; idx < slashes.length; idx++){
                const n = prevIndex ? prevIndex + 1 : start;
                const i = slashes[idx];
                const value = input.slice(n, i);
                if (opts.tokens) {
                    if (idx === 0 && start !== 0) {
                        tokens[idx].isPrefix = true;
                        tokens[idx].value = prefix;
                    } else {
                        tokens[idx].value = value;
                    }
                    depth(tokens[idx]);
                    state.maxDepth += tokens[idx].depth;
                }
                if (idx !== 0 || value !== '') {
                    parts.push(value);
                }
                prevIndex = i;
            }
            if (prevIndex && prevIndex + 1 < input.length) {
                const value = input.slice(prevIndex + 1);
                parts.push(value);
                if (opts.tokens) {
                    tokens[tokens.length - 1].value = value;
                    depth(tokens[tokens.length - 1]);
                    state.maxDepth += tokens[tokens.length - 1].depth;
                }
            }
            state.slashes = slashes;
            state.parts = parts;
        }
        return state;
    };
    module.exports = scan;
}
,
"c9770ed1":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const fs = farmRequire("ffc819a8", true);
    const path = global.nodeRequire('path', true);
    const mkdirsSync = farmRequire("abdb8a71", true).mkdirsSync;
    const utimesMillisSync = farmRequire("69e53775", true).utimesMillisSync;
    const stat = farmRequire("9c9fbd11", true);
    function copySync(src, dest, opts) {
        if (typeof opts === 'function') {
            opts = {
                filter: opts
            };
        }
        opts = opts || {};
        opts.clobber = 'clobber' in opts ? !!opts.clobber : true;
        opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber;
        if (opts.preserveTimestamps && process.arch === 'ia32') {
            process.emitWarning('Using the preserveTimestamps option in 32-bit node is not recommended;\n\n' + '\tsee https://github.com/jprichardson/node-fs-extra/issues/269', 'Warning', 'fs-extra-WARN0002');
        }
        const { srcStat, destStat } = stat.checkPathsSync(src, dest, 'copy', opts);
        stat.checkParentPathsSync(src, srcStat, dest, 'copy');
        if (opts.filter && !opts.filter(src, dest)) return;
        const destParent = path.dirname(dest);
        if (!fs.existsSync(destParent)) mkdirsSync(destParent);
        return getStats(destStat, src, dest, opts);
    }
    function getStats(destStat, src, dest, opts) {
        const statSync = opts.dereference ? fs.statSync : fs.lstatSync;
        const srcStat = statSync(src);
        if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts);
        else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts);
        else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts);
        else if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`);
        else if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`);
        throw new Error(`Unknown file: ${src}`);
    }
    function onFile(srcStat, destStat, src, dest, opts) {
        if (!destStat) return copyFile(srcStat, src, dest, opts);
        return mayCopyFile(srcStat, src, dest, opts);
    }
    function mayCopyFile(srcStat, src, dest, opts) {
        if (opts.overwrite) {
            fs.unlinkSync(dest);
            return copyFile(srcStat, src, dest, opts);
        } else if (opts.errorOnExist) {
            throw new Error(`'${dest}' already exists`);
        }
    }
    function copyFile(srcStat, src, dest, opts) {
        fs.copyFileSync(src, dest);
        if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest);
        return setDestMode(dest, srcStat.mode);
    }
    function handleTimestamps(srcMode, src, dest) {
        if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode);
        return setDestTimestamps(src, dest);
    }
    function fileIsNotWritable(srcMode) {
        return (srcMode & 0o200) === 0;
    }
    function makeFileWritable(dest, srcMode) {
        return setDestMode(dest, srcMode | 0o200);
    }
    function setDestMode(dest, srcMode) {
        return fs.chmodSync(dest, srcMode);
    }
    function setDestTimestamps(src, dest) {
        const updatedSrcStat = fs.statSync(src);
        return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
    }
    function onDir(srcStat, destStat, src, dest, opts) {
        if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts);
        return copyDir(src, dest, opts);
    }
    function mkDirAndCopy(srcMode, src, dest, opts) {
        fs.mkdirSync(dest);
        copyDir(src, dest, opts);
        return setDestMode(dest, srcMode);
    }
    function copyDir(src, dest, opts) {
        fs.readdirSync(src).forEach((item)=>copyDirItem(item, src, dest, opts));
    }
    function copyDirItem(item, src, dest, opts) {
        const srcItem = path.join(src, item);
        const destItem = path.join(dest, item);
        if (opts.filter && !opts.filter(srcItem, destItem)) return;
        const { destStat } = stat.checkPathsSync(srcItem, destItem, 'copy', opts);
        return getStats(destStat, srcItem, destItem, opts);
    }
    function onLink(destStat, src, dest, opts) {
        let resolvedSrc = fs.readlinkSync(src);
        if (opts.dereference) {
            resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
        }
        if (!destStat) {
            return fs.symlinkSync(resolvedSrc, dest);
        } else {
            let resolvedDest;
            try {
                resolvedDest = fs.readlinkSync(dest);
            } catch (err) {
                if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest);
                throw err;
            }
            if (opts.dereference) {
                resolvedDest = path.resolve(process.cwd(), resolvedDest);
            }
            if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
                throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
            }
            if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
                throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
            }
            return copyLink(resolvedSrc, dest);
        }
    }
    function copyLink(resolvedSrc, dest) {
        fs.unlinkSync(dest);
        return fs.symlinkSync(resolvedSrc, dest);
    }
    module.exports = copySync;
}
,
"c9805378":function  (module, exports, farmRequire, farmDynamicRequire) {
    module.exports = isexe;
    isexe.sync = sync;
    var fs = global.nodeRequire('fs', true);
    function isexe(path, options, cb) {
        fs.stat(path, function(er, stat) {
            cb(er, er ? false : checkStat(stat, options));
        });
    }
    function sync(path, options) {
        return checkStat(fs.statSync(path), options);
    }
    function checkStat(stat, options) {
        return stat.isFile() && checkMode(stat, options);
    }
    function checkMode(stat, options) {
        var mod = stat.mode;
        var uid = stat.uid;
        var gid = stat.gid;
        var myUid = options.uid !== undefined ? options.uid : process.getuid && process.getuid();
        var myGid = options.gid !== undefined ? options.gid : process.getgid && process.getgid();
        var u = parseInt('100', 8);
        var g = parseInt('010', 8);
        var o = parseInt('001', 8);
        var ug = u | g;
        var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
        return ret;
    }
}
,
"ca85d3ee":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "normalizeOutput", ()=>normalizeOutput);
    module.o(exports, "normalizePublicPath", ()=>normalizePublicPath);
    module.o(exports, "getValidPublicPath", ()=>getValidPublicPath);
    var _f_farm_browserslist_generator = farmRequire('farm-browserslist-generator');
    var _f_node_path = module.w(farmRequire('node:path'));
    var _f_http = farmRequire("84a68c6c");
    var _f_share = farmRequire("bc6cc539");
    var _f_constants = farmRequire("97f6a66c");
    function normalizeOutput(config, isProduction, logger) {
        if (!config.output) {
            config.output = {};
        }
        if (!config.output.targetEnv) {
            config.output.targetEnv = 'browser';
        }
        if (isProduction) {
            if (!config.output.filename) {
                config.output.filename = '[resourceName].[contentHash].[ext]';
            }
            if (!config.output.assetsFilename) {
                config.output.assetsFilename = '[resourceName].[contentHash].[ext]';
            }
        }
        if (config.output.clean === undefined) {
            config.output.clean = true;
        }
        config.custom = {
            ...config.custom || {},
            [_f_constants.CUSTOM_KEYS.output_ascii_only]: `${!!config.output.asciiOnly}`
        };
        if (isProduction) {
            normalizeTargetEnv(config);
        }
        _f_share.mapTargetEnvValue(config);
        config.output.publicPath = normalizePublicPath(config.output.targetEnv, config.output?.publicPath, logger);
    }
    const es2015Browsers = _f_farm_browserslist_generator.browsersWithSupportForFeatures('es6');
    const es2017Browsers = _f_farm_browserslist_generator.browsersWithSupportForFeatures('async-functions');
    const LEGACY_BROWSERS = [
        'ie >= 9'
    ];
    const targetsMap = {
        node16: {
            scriptTargets: [
                'node 16'
            ],
            cssTargets: null
        },
        'node-legacy': {
            scriptTargets: [
                'node 10'
            ],
            cssTargets: null
        },
        'node-next': null,
        'browser-legacy': {
            scriptTargets: LEGACY_BROWSERS,
            cssTargets: LEGACY_BROWSERS,
            scriptGenTarget: 'es5'
        },
        'browser-es2015': {
            scriptTargets: es2015Browsers,
            cssTargets: es2015Browsers,
            scriptGenTarget: 'es2015'
        },
        'browser-es2017': {
            scriptTargets: es2017Browsers,
            cssTargets: es2017Browsers,
            scriptGenTarget: 'es2017'
        },
        'browser-esnext': null,
        library: null,
        'library-browser': null,
        'library-node': null
    };
    function normalizeTargetEnv(config) {
        const aliasMap = {
            node: 'node16',
            browser: 'browser-es2017'
        };
        const targetEnv = aliasMap[config.output.targetEnv] ?? config.output.targetEnv;
        if (targetsMap[targetEnv]) {
            const { scriptTargets, cssTargets, scriptGenTarget } = targetsMap[targetEnv];
            if (config.presetEnv !== false) {
                if (scriptTargets == null) {
                    config.presetEnv = false;
                } else if (typeof config.presetEnv === 'object') {
                    config.presetEnv.options ??= {};
                    if (!config.presetEnv.options.targets) {
                        config.presetEnv.options.targets = scriptTargets;
                    }
                } else {
                    if (_f_share.FARM_TARGET_BROWSER_ENVS.includes(targetEnv) && config.input && Object.values(config.input).some((v)=>v?.endsWith('.html'))) {
                        config.presetEnv = {
                            options: {
                                targets: scriptTargets
                            }
                        };
                    } else {
                        config.presetEnv = false;
                    }
                }
            }
            config.script ??= {
                plugins: []
            };
            config.script.target = config.script.target ?? scriptGenTarget ?? 'esnext';
            if (!config) {
                if (config.css?.prefixer !== null) {
                    if (cssTargets == null) {
                        config.css ??= {};
                        config.css.prefixer = null;
                    } else if (typeof config.css?.prefixer === 'object') {
                        if (!config.css.prefixer.targets) {
                            config.css.prefixer.targets = cssTargets;
                        }
                    } else {
                        config.css ??= {};
                        config.css.prefixer = {
                            targets: cssTargets
                        };
                    }
                }
            }
        } else {
            config.presetEnv = false;
            config.script ??= {
                plugins: []
            };
            config.script.target = 'esnext';
            config.css ??= {};
            config.css.prefixer = null;
        }
    }
    function tryGetDefaultPublicPath(targetEnv, publicPath, logger) {
        if (!targetEnv) {
            return publicPath;
        }
        if (publicPath) {
            if (_f_http.urlRegex.test(publicPath)) {
                return publicPath;
            }
            if (publicPath) {
                return publicPath;
            }
            if (targetEnv === 'node' && _f_node_path.isAbsolute(publicPath)) {
                const relativePath = './' + module.f(_f_node_path).posix.normalize(publicPath).slice(1);
                logger.warn(`publicPath can't support absolute path in NodeJs, will be transform "${publicPath}" to "${relativePath}".`);
                return relativePath;
            }
            return publicPath;
        }
        if ([
            'node',
            'browser'
        ].includes(targetEnv)) {
            return targetEnv === 'node' ? './' : '/';
        }
    }
    function normalizePublicPath(targetEnv, publicPath, logger, isPrefixNeeded = true) {
        let defaultPublicPath = tryGetDefaultPublicPath(targetEnv, publicPath, logger) ?? '/';
        let warning = false;
        if (defaultPublicPath.startsWith('..')) {
            warning = true;
        }
        if (!defaultPublicPath.endsWith('/')) {
            if (!_f_http.urlRegex.test(defaultPublicPath)) {
                warning = true;
            }
            defaultPublicPath = defaultPublicPath + '/';
        }
        if (defaultPublicPath.startsWith('/') && !_f_http.urlRegex.test(defaultPublicPath) && !isPrefixNeeded) {
            defaultPublicPath = defaultPublicPath.slice(1);
        }
        warning && isPrefixNeeded && logger.warn(` (!) Irregular 'publicPath' options: '${publicPath}', it should only be an absolute path like '/publicPath/', './', an url or an empty string.`);
        return defaultPublicPath;
    }
    function getValidPublicPath(publicPath = '/') {
        let validPublicPath = '';
        if (publicPath.startsWith('/')) {
            validPublicPath = publicPath;
        } else if (publicPath.startsWith('.')) {
            validPublicPath = _f_share.normalizeBasePath(module.f(_f_node_path).join('/', publicPath));
        }
        return validPublicPath;
    }
}
,
"cb79b35f":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const path = global.nodeRequire('path', true);
    const pathKey = farmRequire("ba69a156", true);
    const npmRunPath = (options)=>{
        options = {
            cwd: process.cwd(),
            path: process.env[pathKey()],
            execPath: process.execPath,
            ...options
        };
        let previous;
        let cwdPath = path.resolve(options.cwd);
        const result = [];
        while(previous !== cwdPath){
            result.push(path.join(cwdPath, 'node_modules/.bin'));
            previous = cwdPath;
            cwdPath = path.resolve(cwdPath, '..');
        }
        const execPathDir = path.resolve(options.cwd, options.execPath, '..');
        result.push(execPathDir);
        return result.concat(options.path).join(path.delimiter);
    };
    module.exports = npmRunPath;
    module.exports.default = npmRunPath;
    module.exports.env = (options)=>{
        options = {
            env: process.env,
            ...options
        };
        const env = {
            ...options.env
        };
        const path = pathKey({
            env
        });
        options.path = env[path];
        env[path] = module.exports(options);
        return env;
    };
}
,
"cbf7c3bf":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "lazyCompilation", ()=>lazyCompilation);
    var _f_node_path = farmRequire('node:path');
    var _f_index = farmRequire("953dfae2");
    var _f_node_fs = farmRequire('node:fs');
    var _f_normalize_output = farmRequire("ca85d3ee");
    var _f_error = farmRequire("972397d2");
    function lazyCompilation(devSeverContext) {
        const compiler = devSeverContext.getCompiler();
        if (!compiler.config.config?.lazyCompilation) {
            return;
        }
        return async (ctx, next)=>{
            const publicPath = _f_normalize_output.getValidPublicPath(compiler.config.config?.output?.publicPath);
            if (ctx.path === `${publicPath || '/'}__lazy_compile`) {
                const paths = ctx.query.paths.split(',');
                const pathsStr = paths.map((p)=>{
                    if (p.startsWith('/') && !p.endsWith(_f_index.VIRTUAL_FARM_DYNAMIC_IMPORT_SUFFIX) && !_f_node_fs.existsSync(p)) {
                        return p;
                    }
                    const resolvedPath = compiler.transformModulePath(compiler.config.config.root, p);
                    return _f_node_path.relative(compiler.config.config.root, resolvedPath);
                }).join(', ');
                _f_index.checkClearScreen(compiler.config.config);
                devSeverContext.logger.info(`Lazy compiling ${_f_index.bold(_f_index.cyan(pathsStr))}`);
                const start = Date.now();
                let result;
                try {
                    result = await compiler.update(paths, true, false, false);
                } catch (e) {
                    _f_error.logError(e);
                }
                if (!result) {
                    return;
                }
                if (ctx.query.node || devSeverContext.config.writeToDisk) {
                    compiler.writeResourcesToDisk();
                }
                devSeverContext.logger.info(`${_f_index.bold(_f_index.green(``))} Lazy compilation done(${_f_index.bold(_f_index.cyan(pathsStr))}) in ${_f_index.bold(_f_index.green(`${Date.now() - start}ms`))}.`);
                if (result) {
                    const { dynamicResources, dynamicModuleResourcesMap } = _f_index.getDynamicResources(result.dynamicResourcesMap);
                    const returnObj = `{
          "dynamicResources": ${JSON.stringify(dynamicResources)},
          "dynamicModuleResourcesMap": ${JSON.stringify(dynamicModuleResourcesMap)}
        }`;
                    const code = !ctx.query.node ? `export default ${returnObj}` : returnObj;
                    ctx.type = !ctx.query.node ? 'application/javascript' : 'application/json';
                    ctx.body = code;
                    ctx.set('Access-Control-Allow-Origin', '*');
                    ctx.set('Access-Control-Allow-Methods', '*');
                    ctx.set('Access-Control-Allow-Headers', '*');
                } else {
                    throw new Error(`Lazy compilation result not found for paths ${paths}`);
                }
            } else {
                await next();
            }
        };
    }
}
,
"ccfc2d75":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "reset", ()=>reset);
    module.o(exports, "bold", ()=>bold);
    module.o(exports, "dim", ()=>dim);
    module.o(exports, "italic", ()=>italic);
    module.o(exports, "underline", ()=>underline);
    module.o(exports, "inverse", ()=>inverse);
    module.o(exports, "hidden", ()=>hidden);
    module.o(exports, "strikethrough", ()=>strikethrough);
    module.o(exports, "debugColor", ()=>debugColor);
    module.o(exports, "brandColor", ()=>brandColor);
    module.o(exports, "black", ()=>black);
    module.o(exports, "red", ()=>red);
    module.o(exports, "green", ()=>green);
    module.o(exports, "yellow", ()=>yellow);
    module.o(exports, "blue", ()=>blue);
    module.o(exports, "magenta", ()=>magenta);
    module.o(exports, "purple", ()=>purple);
    module.o(exports, "orange", ()=>orange);
    module.o(exports, "cyan", ()=>cyan);
    module.o(exports, "white", ()=>white);
    module.o(exports, "bgBlack", ()=>bgBlack);
    module.o(exports, "bgRed", ()=>bgRed);
    module.o(exports, "bgGreen", ()=>bgGreen);
    module.o(exports, "bgYellow", ()=>bgYellow);
    module.o(exports, "bgBlue", ()=>bgBlue);
    module.o(exports, "bgMagenta", ()=>bgMagenta);
    module.o(exports, "bgCyan", ()=>bgCyan);
    module.o(exports, "bgWhite", ()=>bgWhite);
    module.o(exports, "gradientString", ()=>gradientString);
    module.o(exports, "interpolateColor", ()=>interpolateColor);
    module.o(exports, "PersistentCacheBrand", ()=>PersistentCacheBrand);
    module.o(exports, "handleBrandText", ()=>handleBrandText);
    module.o(exports, "BrandText", ()=>BrandText);
    module.o(exports, "colors", ()=>colors);
    var _f_node_module = farmRequire('node:module');
    const require = _f_node_module.createRequire(module.meta.url);
    const gradientPurpleColor = [
        176,
        106,
        179
    ];
    const gradientPinkColor = [
        198,
        66,
        110
    ];
    const brandGradientColors = [
        255,
        182,
        193
    ];
    const brandGradientColors2 = [
        128,
        0,
        128
    ];
    const argv = process.argv || [], env = process.env;
    const enabled = !('NO_COLOR' in env || argv.includes('--no-color')) && ('FORCE_COLOR' in env || argv.includes('--color') || process.platform === 'win32' || require != null && global.nodeRequire('tty').isatty(1) && env.TERM !== 'dumb' || 'CI' in env);
    const createFormatter = (open, close, replace = open)=>(input)=>{
            const string = '' + input;
            const index = string.indexOf(close, open.length);
            return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
        };
    const replaceClose = (string, close, replace, index)=>{
        const start = string.substring(0, index) + replace;
        const end = string.substring(index + close.length);
        const nextIndex = end.indexOf(close);
        return ~nextIndex ? start + replaceClose(end, close, replace, nextIndex) : start + end;
    };
    var reset = enabled ? (s)=>`\x1b[0m${s}\x1b[0m` : String;
    var bold = enabled ? createFormatter('\x1b[1m', '\x1b[22m', '\x1b[22m\x1b[1m') : String;
    var dim = enabled ? createFormatter('\x1b[2m', '\x1b[22m', '\x1b[22m\x1b[2m') : String;
    var italic = enabled ? createFormatter('\x1b[3m', '\x1b[23m') : String;
    var underline = enabled ? createFormatter('\x1b[4m', '\x1b[24m') : String;
    var inverse = enabled ? createFormatter('\x1b[7m', '\x1b[27m') : String;
    var hidden = enabled ? createFormatter('\x1b[8m', '\x1b[28m') : String;
    var strikethrough = enabled ? createFormatter('\x1b[9m', '\x1b[29m') : String;
    var debugColor = createFormatter('\x1b[38;2;255;140;0m', '\x1b[39m');
    var brandColor = enabled ? createFormatter('\x1b[38;2;113;26;95m', '\x1b[39m') : String;
    var black = enabled ? createFormatter('\x1b[38;2;0;0;0m', '\x1b[39m') : String;
    var red = enabled ? createFormatter('\x1b[38;2;219;90;107m', '\x1b[39m') : String;
    var green = enabled ? createFormatter('\x1b[32m', '\x1b[39m') : String;
    var yellow = enabled ? createFormatter('\x1b[33m', '\x1b[39m') : String;
    var blue = enabled ? createFormatter('\x1b[38;2;68;206;246m', '\x1b[39m') : String;
    var magenta = enabled ? createFormatter('\x1b[38;2;180;0;100m', '\x1b[39m') : String;
    var purple = enabled ? createFormatter('\x1b[38;2;140;67;86m', '\x1b[39m') : String;
    var orange = enabled ? createFormatter('\x1b[38;2;255;137;54m', '\x1b[39m') : String;
    var cyan = enabled ? createFormatter('\x1b[36m', '\x1b[39m') : String;
    var white = enabled ? createFormatter('\x1b[37m', '\x1b[39m') : String;
    var bgBlack = enabled ? createFormatter('\x1b[40m', '\x1b[49m') : String;
    var bgRed = enabled ? createFormatter('\x1b[41m', '\x1b[49m') : String;
    var bgGreen = enabled ? createFormatter('\x1b[42m', '\x1b[49m') : String;
    var bgYellow = enabled ? createFormatter('\x1b[43m', '\x1b[49m') : String;
    var bgBlue = enabled ? createFormatter('\x1b[44m', '\x1b[49m') : String;
    var bgMagenta = enabled ? createFormatter('\x1b[45m', '\x1b[49m') : String;
    var bgCyan = enabled ? createFormatter('\x1b[46m', '\x1b[49m') : String;
    var bgWhite = enabled ? createFormatter('\x1b[47m', '\x1b[49m') : String;
    function gradientString(text, colors) {
        const steps = text.length;
        const gradient = colors.map((color)=>`\x1b[38;2;${color[0]};${color[1]};${color[2]}m`);
        let output = '';
        for(let i = 0; i < steps; i++){
            const colorIndex = Math.floor(i / steps * (colors.length - 1));
            output += `${gradient[colorIndex]}${text[i]}`;
        }
        output += '\x1b[0m';
        return output;
    }
    function interpolateColor(color1, color2, factor) {
        return [
            Math.round(color1[0] + (color2[0] - color1[0]) * factor),
            Math.round(color1[1] + (color2[1] - color1[1]) * factor),
            Math.round(color1[2] + (color2[2] - color1[2]) * factor)
        ];
    }
    var PersistentCacheBrand = brandColor('') + gradientString(`FULL EXTREME!`, [
        gradientPurpleColor,
        interpolateColor(gradientPurpleColor, gradientPinkColor, 0.1),
        interpolateColor(gradientPurpleColor, gradientPinkColor, 0.2),
        interpolateColor(gradientPurpleColor, gradientPinkColor, 0.3),
        interpolateColor(gradientPurpleColor, gradientPinkColor, 0.4),
        interpolateColor(gradientPurpleColor, gradientPinkColor, 0.5),
        interpolateColor(gradientPurpleColor, gradientPinkColor, 0.6),
        interpolateColor(gradientPurpleColor, gradientPinkColor, 0.7),
        interpolateColor(gradientPurpleColor, gradientPinkColor, 0.8),
        interpolateColor(gradientPurpleColor, gradientPinkColor, 0.9),
        gradientPinkColor
    ]);
    function handleBrandText(text) {
        console.log(gradientString(text, [
            brandGradientColors,
            interpolateColor(brandGradientColors, brandGradientColors2, 0.2),
            interpolateColor(brandGradientColors, brandGradientColors2, 0.4),
            interpolateColor(brandGradientColors, brandGradientColors2, 0.6),
            interpolateColor(brandGradientColors, brandGradientColors2, 0.8),
            brandGradientColors2
        ]));
    }
    var BrandText = (text)=>gradientString(`\n${text} \n`, [
            brandGradientColors,
            interpolateColor(brandGradientColors, brandGradientColors2, 0.2),
            interpolateColor(brandGradientColors, brandGradientColors2, 0.4),
            interpolateColor(brandGradientColors, brandGradientColors2, 0.6),
            interpolateColor(brandGradientColors, brandGradientColors2, 0.8),
            brandGradientColors2
        ]);
    var colors = {
        reset,
        bold,
        dim,
        italic,
        underline,
        inverse,
        hidden,
        strikethrough,
        black,
        red,
        green,
        yellow,
        blue,
        magenta,
        purple,
        orange,
        cyan,
        white,
        bgBlack,
        bgRed,
        bgGreen,
        bgYellow,
        bgBlue,
        bgMagenta,
        bgCyan,
        bgWhite,
        debugColor,
        brandColor,
        handleBrandText,
        BrandText
    };
}
,
"ce7af38f":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.getPlugins = void 0;
    const default_1 = farmRequire("31748dff", true);
    function getPlugins(options) {
        const maybeErrorResponsePlugin = !!options.on?.error ? [] : [
            default_1.errorResponsePlugin
        ];
        const defaultPlugins = !!options.ejectPlugins ? [] : [
            default_1.debugProxyErrorsPlugin,
            default_1.proxyEventsPlugin,
            default_1.loggerPlugin,
            ...maybeErrorResponsePlugin
        ];
        const userPlugins = options.plugins ?? [];
        return [
            ...defaultPlugins,
            ...userPlugins
        ];
    }
    exports.getPlugins = getPlugins;
}
,
"cea679ec":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const path = global.nodeRequire("path", true);
    const fsScandir = farmRequire("001be097", true);
    class Settings {
        constructor(_options = {}){
            this._options = _options;
            this.basePath = this._getValue(this._options.basePath, undefined);
            this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);
            this.deepFilter = this._getValue(this._options.deepFilter, null);
            this.entryFilter = this._getValue(this._options.entryFilter, null);
            this.errorFilter = this._getValue(this._options.errorFilter, null);
            this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);
            this.fsScandirSettings = new fsScandir.Settings({
                followSymbolicLinks: this._options.followSymbolicLinks,
                fs: this._options.fs,
                pathSegmentSeparator: this._options.pathSegmentSeparator,
                stats: this._options.stats,
                throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
            });
        }
        _getValue(option, value) {
            return option !== null && option !== void 0 ? option : value;
        }
    }
    exports.default = Settings;
}
,
"ceabc55b":/*!
 * depd
 * Copyright(c) 2014-2018 Douglas Christopher Wilson
 * MIT Licensed
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    var relative = global.nodeRequire('path', true).relative;
    module.exports = depd;
    var basePath = process.cwd();
    function containsNamespace(str, namespace) {
        var vals = str.split(/[ ,]+/);
        var ns = String(namespace).toLowerCase();
        for(var i = 0; i < vals.length; i++){
            var val = vals[i];
            if (val && (val === '*' || val.toLowerCase() === ns)) {
                return true;
            }
        }
        return false;
    }
    function convertDataDescriptorToAccessor(obj, prop, message) {
        var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
        var value = descriptor.value;
        descriptor.get = function getter() {
            return value;
        };
        if (descriptor.writable) {
            descriptor.set = function setter(val) {
                return value = val;
            };
        }
        delete descriptor.value;
        delete descriptor.writable;
        Object.defineProperty(obj, prop, descriptor);
        return descriptor;
    }
    function createArgumentsString(arity) {
        var str = '';
        for(var i = 0; i < arity; i++){
            str += ', arg' + i;
        }
        return str.substr(2);
    }
    function createStackString(stack) {
        var str = this.name + ': ' + this.namespace;
        if (this.message) {
            str += ' deprecated ' + this.message;
        }
        for(var i = 0; i < stack.length; i++){
            str += '\n    at ' + stack[i].toString();
        }
        return str;
    }
    function depd(namespace) {
        if (!namespace) {
            throw new TypeError('argument namespace is required');
        }
        var stack = getStack();
        var site = callSiteLocation(stack[1]);
        var file = site[0];
        function deprecate(message) {
            log.call(deprecate, message);
        }
        deprecate._file = file;
        deprecate._ignored = isignored(namespace);
        deprecate._namespace = namespace;
        deprecate._traced = istraced(namespace);
        deprecate._warned = Object.create(null);
        deprecate.function = wrapfunction;
        deprecate.property = wrapproperty;
        return deprecate;
    }
    function eehaslisteners(emitter, type) {
        var count = typeof emitter.listenerCount !== 'function' ? emitter.listeners(type).length : emitter.listenerCount(type);
        return count > 0;
    }
    function isignored(namespace) {
        if (process.noDeprecation) {
            return true;
        }
        var str = process.env.NO_DEPRECATION || '';
        return containsNamespace(str, namespace);
    }
    function istraced(namespace) {
        if (process.traceDeprecation) {
            return true;
        }
        var str = process.env.TRACE_DEPRECATION || '';
        return containsNamespace(str, namespace);
    }
    function log(message, site) {
        var haslisteners = eehaslisteners(process, 'deprecation');
        if (!haslisteners && this._ignored) {
            return;
        }
        var caller;
        var callFile;
        var callSite;
        var depSite;
        var i = 0;
        var seen = false;
        var stack = getStack();
        var file = this._file;
        if (site) {
            depSite = site;
            callSite = callSiteLocation(stack[1]);
            callSite.name = depSite.name;
            file = callSite[0];
        } else {
            i = 2;
            depSite = callSiteLocation(stack[i]);
            callSite = depSite;
        }
        for(; i < stack.length; i++){
            caller = callSiteLocation(stack[i]);
            callFile = caller[0];
            if (callFile === file) {
                seen = true;
            } else if (callFile === this._file) {
                file = this._file;
            } else if (seen) {
                break;
            }
        }
        var key = caller ? depSite.join(':') + '__' + caller.join(':') : undefined;
        if (key !== undefined && key in this._warned) {
            return;
        }
        this._warned[key] = true;
        var msg = message;
        if (!msg) {
            msg = callSite === depSite || !callSite.name ? defaultMessage(depSite) : defaultMessage(callSite);
        }
        if (haslisteners) {
            var err = DeprecationError(this._namespace, msg, stack.slice(i));
            process.emit('deprecation', err);
            return;
        }
        var format = process.stderr.isTTY ? formatColor : formatPlain;
        var output = format.call(this, msg, caller, stack.slice(i));
        process.stderr.write(output + '\n', 'utf8');
    }
    function callSiteLocation(callSite) {
        var file = callSite.getFileName() || '<anonymous>';
        var line = callSite.getLineNumber();
        var colm = callSite.getColumnNumber();
        if (callSite.isEval()) {
            file = callSite.getEvalOrigin() + ', ' + file;
        }
        var site = [
            file,
            line,
            colm
        ];
        site.callSite = callSite;
        site.name = callSite.getFunctionName();
        return site;
    }
    function defaultMessage(site) {
        var callSite = site.callSite;
        var funcName = site.name;
        if (!funcName) {
            funcName = '<anonymous@' + formatLocation(site) + '>';
        }
        var context = callSite.getThis();
        var typeName = context && callSite.getTypeName();
        if (typeName === 'Object') {
            typeName = undefined;
        }
        if (typeName === 'Function') {
            typeName = context.name || typeName;
        }
        return typeName && callSite.getMethodName() ? typeName + '.' + funcName : funcName;
    }
    function formatPlain(msg, caller, stack) {
        var timestamp = new Date().toUTCString();
        var formatted = timestamp + ' ' + this._namespace + ' deprecated ' + msg;
        if (this._traced) {
            for(var i = 0; i < stack.length; i++){
                formatted += '\n    at ' + stack[i].toString();
            }
            return formatted;
        }
        if (caller) {
            formatted += ' at ' + formatLocation(caller);
        }
        return formatted;
    }
    function formatColor(msg, caller, stack) {
        var formatted = '\x1b[36;1m' + this._namespace + '\x1b[22;39m' + ' \x1b[33;1mdeprecated\x1b[22;39m' + ' \x1b[0m' + msg + '\x1b[39m';
        if (this._traced) {
            for(var i = 0; i < stack.length; i++){
                formatted += '\n    \x1b[36mat ' + stack[i].toString() + '\x1b[39m';
            }
            return formatted;
        }
        if (caller) {
            formatted += ' \x1b[36m' + formatLocation(caller) + '\x1b[39m';
        }
        return formatted;
    }
    function formatLocation(callSite) {
        return relative(basePath, callSite[0]) + ':' + callSite[1] + ':' + callSite[2];
    }
    function getStack() {
        var limit = Error.stackTraceLimit;
        var obj = {};
        var prep = Error.prepareStackTrace;
        Error.prepareStackTrace = prepareObjectStackTrace;
        Error.stackTraceLimit = Math.max(10, limit);
        Error.captureStackTrace(obj);
        var stack = obj.stack.slice(1);
        Error.prepareStackTrace = prep;
        Error.stackTraceLimit = limit;
        return stack;
    }
    function prepareObjectStackTrace(obj, stack) {
        return stack;
    }
    function wrapfunction(fn, message) {
        if (typeof fn !== 'function') {
            throw new TypeError('argument fn must be a function');
        }
        var args = createArgumentsString(fn.length);
        var stack = getStack();
        var site = callSiteLocation(stack[1]);
        site.name = fn.name;
        var deprecatedfn = new Function('fn', 'log', 'deprecate', 'message', 'site', '"use strict"\n' + 'return function (' + args + ') {' + 'log.call(deprecate, message, site)\n' + 'return fn.apply(this, arguments)\n' + '}')(fn, log, this, message, site);
        return deprecatedfn;
    }
    function wrapproperty(obj, prop, message) {
        if (!obj || typeof obj !== 'object' && typeof obj !== 'function') {
            throw new TypeError('argument obj must be object');
        }
        var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
        if (!descriptor) {
            throw new TypeError('must call property on owner object');
        }
        if (!descriptor.configurable) {
            throw new TypeError('property must be configurable');
        }
        var deprecate = this;
        var stack = getStack();
        var site = callSiteLocation(stack[1]);
        site.name = prop;
        if ('value' in descriptor) {
            descriptor = convertDataDescriptorToAccessor(obj, prop, message);
        }
        var get = descriptor.get;
        var set = descriptor.set;
        if (typeof get === 'function') {
            descriptor.get = function getter() {
                log.call(deprecate, message, site);
                return get.apply(this, arguments);
            };
        }
        if (typeof set === 'function') {
            descriptor.set = function setter() {
                log.call(deprecate, message, site);
                return set.apply(this, arguments);
            };
        }
        Object.defineProperty(obj, prop, descriptor);
    }
    function DeprecationError(namespace, message, stack) {
        var error = new Error();
        var stackString;
        Object.defineProperty(error, 'constructor', {
            value: DeprecationError
        });
        Object.defineProperty(error, 'message', {
            configurable: true,
            enumerable: false,
            value: message,
            writable: true
        });
        Object.defineProperty(error, 'name', {
            enumerable: false,
            configurable: true,
            value: 'DeprecationError',
            writable: true
        });
        Object.defineProperty(error, 'namespace', {
            configurable: true,
            enumerable: false,
            value: namespace,
            writable: true
        });
        Object.defineProperty(error, 'stack', {
            configurable: true,
            enumerable: false,
            get: function() {
                if (stackString !== undefined) {
                    return stackString;
                }
                return stackString = createStackString.call(this, stack);
            },
            set: function setter(val) {
                stackString = val;
            }
        });
        return error;
    }
}
,
"cfe047c9":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "cssPluginWrap", ()=>cssPluginWrap);
    module.o(exports, "cssPluginUnwrap", ()=>cssPluginUnwrap);
    var _f_utils = farmRequire("e60815f7");
    const BEGIN = '__farm_vite_css_hack_start__=`';
    const END = '`;__farm_vite_css_hack_end__';
    function cssPluginWrap(options) {
        const { filtersUnion } = options;
        const resolvedPaths = Array.from(filtersUnion).map(_f_utils.normalizeFilterPath);
        return {
            name: 'vite-adapter-css-plugin-wrap',
            priority: 98,
            transform: {
                filters: {
                    resolvedPaths,
                    moduleTypes: []
                },
                async executor (param) {
                    if (param.moduleType === 'css') {
                        return {
                            content: BEGIN + param.content + END
                        };
                    }
                }
            }
        };
    }
    function cssPluginUnwrap(options) {
        const { filtersUnion } = options;
        const resolvedPaths = Array.from(filtersUnion).map(_f_utils.normalizeFilterPath);
        return {
            name: 'vite-adapter-css-plugin-unwrap',
            priority: 98,
            transform: {
                filters: {
                    resolvedPaths,
                    moduleTypes: []
                },
                async executor (param) {
                    if (param.moduleType === 'css') {
                        return {
                            content: param.content.replace(BEGIN, '').replace(END, '')
                        };
                    }
                }
            }
        };
    }
}
,
"d0446bff":/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    module.exports = farmRequire("2d715367", true);
}
,
"d0830e44":/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    var isExtglob = farmRequire("0da219b5", true);
    var chars = {
        '{': '}',
        '(': ')',
        '[': ']'
    };
    var strictCheck = function(str) {
        if (str[0] === '!') {
            return true;
        }
        var index = 0;
        var pipeIndex = -2;
        var closeSquareIndex = -2;
        var closeCurlyIndex = -2;
        var closeParenIndex = -2;
        var backSlashIndex = -2;
        while(index < str.length){
            if (str[index] === '*') {
                return true;
            }
            if (str[index + 1] === '?' && /[\].+)]/.test(str[index])) {
                return true;
            }
            if (closeSquareIndex !== -1 && str[index] === '[' && str[index + 1] !== ']') {
                if (closeSquareIndex < index) {
                    closeSquareIndex = str.indexOf(']', index);
                }
                if (closeSquareIndex > index) {
                    if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
                        return true;
                    }
                    backSlashIndex = str.indexOf('\\', index);
                    if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
                        return true;
                    }
                }
            }
            if (closeCurlyIndex !== -1 && str[index] === '{' && str[index + 1] !== '}') {
                closeCurlyIndex = str.indexOf('}', index);
                if (closeCurlyIndex > index) {
                    backSlashIndex = str.indexOf('\\', index);
                    if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
                        return true;
                    }
                }
            }
            if (closeParenIndex !== -1 && str[index] === '(' && str[index + 1] === '?' && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ')') {
                closeParenIndex = str.indexOf(')', index);
                if (closeParenIndex > index) {
                    backSlashIndex = str.indexOf('\\', index);
                    if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                        return true;
                    }
                }
            }
            if (pipeIndex !== -1 && str[index] === '(' && str[index + 1] !== '|') {
                if (pipeIndex < index) {
                    pipeIndex = str.indexOf('|', index);
                }
                if (pipeIndex !== -1 && str[pipeIndex + 1] !== ')') {
                    closeParenIndex = str.indexOf(')', pipeIndex);
                    if (closeParenIndex > pipeIndex) {
                        backSlashIndex = str.indexOf('\\', pipeIndex);
                        if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                            return true;
                        }
                    }
                }
            }
            if (str[index] === '\\') {
                var open = str[index + 1];
                index += 2;
                var close = chars[open];
                if (close) {
                    var n = str.indexOf(close, index);
                    if (n !== -1) {
                        index = n + 1;
                    }
                }
                if (str[index] === '!') {
                    return true;
                }
            } else {
                index++;
            }
        }
        return false;
    };
    var relaxedCheck = function(str) {
        if (str[0] === '!') {
            return true;
        }
        var index = 0;
        while(index < str.length){
            if (/[*?{}()[\]]/.test(str[index])) {
                return true;
            }
            if (str[index] === '\\') {
                var open = str[index + 1];
                index += 2;
                var close = chars[open];
                if (close) {
                    var n = str.indexOf(close, index);
                    if (n !== -1) {
                        index = n + 1;
                    }
                }
                if (str[index] === '!') {
                    return true;
                }
            } else {
                index++;
            }
        }
        return false;
    };
    module.exports = function isGlob(str, options) {
        if (typeof str !== 'string' || str === '') {
            return false;
        }
        if (isExtglob(str)) {
            return true;
        }
        var check = strictCheck;
        if (options && options.strict === false) {
            check = relaxedCheck;
        }
        return check(str);
    };
}
,
"d12f57da":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.read = void 0;
    function read(path, settings) {
        const lstat = settings.fs.lstatSync(path);
        if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
            return lstat;
        }
        try {
            const stat = settings.fs.statSync(path);
            if (settings.markSymbolicLink) {
                stat.isSymbolicLink = ()=>true;
            }
            return stat;
        } catch (error) {
            if (!settings.throwErrorOnBrokenSymbolicLink) {
                return lstat;
            }
            throw error;
        }
    }
    exports.read = read;
}
,
"d1ab6346":/*!
 * cookies
 * Copyright(c) 2014 Jed Schmidt, http://jed.is/
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    var deprecate = farmRequire("ceabc55b")('cookies');
    var Keygrip = farmRequire("7942e799", true);
    var http = global.nodeRequire('http', true);
    var cache = {};
    var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    var SAME_SITE_REGEXP = /^(?:lax|none|strict)$/i;
    function Cookies(request, response, options) {
        if (!(this instanceof Cookies)) return new Cookies(request, response, options);
        this.secure = undefined;
        this.request = request;
        this.response = response;
        if (options) {
            if (Array.isArray(options)) {
                deprecate('"keys" argument; provide using options {"keys": [...]}');
                this.keys = new Keygrip(options);
            } else if (options.constructor && options.constructor.name === 'Keygrip') {
                deprecate('"keys" argument; provide using options {"keys": keygrip}');
                this.keys = options;
            } else {
                this.keys = Array.isArray(options.keys) ? new Keygrip(options.keys) : options.keys;
                this.secure = options.secure;
            }
        }
    }
    Cookies.prototype.get = function(name, opts) {
        var sigName = name + ".sig", header, match, value, remote, data, index, signed = opts && opts.signed !== undefined ? opts.signed : !!this.keys;
        header = this.request.headers["cookie"];
        if (!header) return;
        match = header.match(getPattern(name));
        if (!match) return;
        value = match[1];
        if (!opts || !signed) return value;
        remote = this.get(sigName);
        if (!remote) return;
        data = name + "=" + value;
        if (!this.keys) throw new Error('.keys required for signed cookies');
        index = this.keys.index(data, remote);
        if (index < 0) {
            this.set(sigName, null, {
                path: "/",
                signed: false
            });
        } else {
            index && this.set(sigName, this.keys.sign(data), {
                signed: false
            });
            return value;
        }
    };
    Cookies.prototype.set = function(name, value, opts) {
        var res = this.response, req = this.request, headers = res.getHeader("Set-Cookie") || [], secure = this.secure !== undefined ? !!this.secure : req.protocol === 'https' || req.connection.encrypted, cookie = new Cookie(name, value, opts), signed = opts && opts.signed !== undefined ? opts.signed : !!this.keys;
        if (typeof headers == "string") headers = [
            headers
        ];
        if (!secure && opts && opts.secure) {
            throw new Error('Cannot send secure cookie over unencrypted connection');
        }
        cookie.secure = opts && opts.secure !== undefined ? opts.secure : secure;
        if (opts && "secureProxy" in opts) {
            deprecate('"secureProxy" option; use "secure" option, provide "secure" to constructor if needed');
            cookie.secure = opts.secureProxy;
        }
        pushCookie(headers, cookie);
        if (opts && signed) {
            if (!this.keys) throw new Error('.keys required for signed cookies');
            cookie.value = this.keys.sign(cookie.toString());
            cookie.name += ".sig";
            pushCookie(headers, cookie);
        }
        var setHeader = res.set ? http.OutgoingMessage.prototype.setHeader : res.setHeader;
        setHeader.call(res, 'Set-Cookie', headers);
        return this;
    };
    function Cookie(name, value, attrs) {
        if (!fieldContentRegExp.test(name)) {
            throw new TypeError('argument name is invalid');
        }
        if (value && !fieldContentRegExp.test(value)) {
            throw new TypeError('argument value is invalid');
        }
        this.name = name;
        this.value = value || "";
        for(var name in attrs){
            this[name] = attrs[name];
        }
        if (!this.value) {
            this.expires = new Date(0);
            this.maxAge = null;
        }
        if (this.path && !fieldContentRegExp.test(this.path)) {
            throw new TypeError('option path is invalid');
        }
        if (this.domain && !fieldContentRegExp.test(this.domain)) {
            throw new TypeError('option domain is invalid');
        }
        if (this.sameSite && this.sameSite !== true && !SAME_SITE_REGEXP.test(this.sameSite)) {
            throw new TypeError('option sameSite is invalid');
        }
    }
    Cookie.prototype.path = "/";
    Cookie.prototype.expires = undefined;
    Cookie.prototype.domain = undefined;
    Cookie.prototype.httpOnly = true;
    Cookie.prototype.sameSite = false;
    Cookie.prototype.secure = false;
    Cookie.prototype.overwrite = false;
    Cookie.prototype.toString = function() {
        return this.name + "=" + this.value;
    };
    Cookie.prototype.toHeader = function() {
        var header = this.toString();
        if (this.maxAge) this.expires = new Date(Date.now() + this.maxAge);
        if (this.path) header += "; path=" + this.path;
        if (this.expires) header += "; expires=" + this.expires.toUTCString();
        if (this.domain) header += "; domain=" + this.domain;
        if (this.sameSite) header += "; samesite=" + (this.sameSite === true ? 'strict' : this.sameSite.toLowerCase());
        if (this.secure) header += "; secure";
        if (this.httpOnly) header += "; httponly";
        return header;
    };
    Object.defineProperty(Cookie.prototype, 'maxage', {
        configurable: true,
        enumerable: true,
        get: function() {
            return this.maxAge;
        },
        set: function(val) {
            return this.maxAge = val;
        }
    });
    deprecate.property(Cookie.prototype, 'maxage', '"maxage"; use "maxAge" instead');
    function getPattern(name) {
        if (cache[name]) return cache[name];
        return cache[name] = new RegExp("(?:^|;) *" + name.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&") + "=([^;]*)");
    }
    function pushCookie(headers, cookie) {
        if (cookie.overwrite) {
            for(var i = headers.length - 1; i >= 0; i--){
                if (headers[i].indexOf(cookie.name + '=') === 0) {
                    headers.splice(i, 1);
                }
            }
        }
        headers.push(cookie.toHeader());
    }
    Cookies.connect = Cookies.express = function(keys) {
        return function(req, res, next) {
            req.cookies = res.cookies = new Cookies(req, res, {
                keys: keys
            });
            next();
        };
    };
    Cookies.Cookie = Cookie;
    module.exports = Cookies;
}
,
"d1ce3aa3":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const u = farmRequire("712c2dd4", true).fromCallback;
    module.exports = {
        copy: u(farmRequire("214cc0ba")),
        copySync: farmRequire("c9770ed1", true)
    };
}
,
"d2f32a4d":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const { signalsByName } = farmRequire("be796aa1", true);
    const getErrorPrefix = ({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled })=>{
        if (timedOut) {
            return `timed out after ${timeout} milliseconds`;
        }
        if (isCanceled) {
            return 'was canceled';
        }
        if (errorCode !== undefined) {
            return `failed with ${errorCode}`;
        }
        if (signal !== undefined) {
            return `was killed with ${signal} (${signalDescription})`;
        }
        if (exitCode !== undefined) {
            return `failed with exit code ${exitCode}`;
        }
        return 'failed';
    };
    const makeError = ({ stdout, stderr, all, error, signal, exitCode, command, escapedCommand, timedOut, isCanceled, killed, parsed: { options: { timeout } } })=>{
        exitCode = exitCode === null ? undefined : exitCode;
        signal = signal === null ? undefined : signal;
        const signalDescription = signal === undefined ? undefined : signalsByName[signal].description;
        const errorCode = error && error.code;
        const prefix = getErrorPrefix({
            timedOut,
            timeout,
            errorCode,
            signal,
            signalDescription,
            exitCode,
            isCanceled
        });
        const execaMessage = `Command ${prefix}: ${command}`;
        const isError = Object.prototype.toString.call(error) === '[object Error]';
        const shortMessage = isError ? `${execaMessage}\n${error.message}` : execaMessage;
        const message = [
            shortMessage,
            stderr,
            stdout
        ].filter(Boolean).join('\n');
        if (isError) {
            error.originalMessage = error.message;
            error.message = message;
        } else {
            error = new Error(message);
        }
        error.shortMessage = shortMessage;
        error.command = command;
        error.escapedCommand = escapedCommand;
        error.exitCode = exitCode;
        error.signal = signal;
        error.signalDescription = signalDescription;
        error.stdout = stdout;
        error.stderr = stderr;
        if (all !== undefined) {
            error.all = all;
        }
        if ('bufferedData' in error) {
            delete error.bufferedData;
        }
        error.failed = true;
        error.timedOut = Boolean(timedOut);
        error.isCanceled = isCanceled;
        error.killed = killed && !timedOut;
        return error;
    };
    module.exports = makeError;
}
,
"d42f4747":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "default", ()=>isInsideContainer);
    var _f_node_fs = module.i(farmRequire('node:fs'));
    var _f_is_docker = module.i(farmRequire("b949c668"));
    let cachedResult;
    const hasContainerEnv = ()=>{
        try {
            module.f(_f_node_fs).statSync('/run/.containerenv');
            return true;
        } catch  {
            return false;
        }
    };
    function isInsideContainer() {
        if (cachedResult === undefined) {
            cachedResult = hasContainerEnv() || module.f(_f_is_docker)();
        }
        return cachedResult;
    }
}
,
"d4405cd7":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "mergePromise", ()=>mergePromise);
    module.o(exports, "getSpawnedPromise", ()=>getSpawnedPromise);
    const nativePromisePrototype = (async ()=>{})().constructor.prototype;
    const descriptors = [
        'then',
        'catch',
        'finally'
    ].map((property)=>[
            property,
            Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
        ]);
    var mergePromise = (spawned, promise)=>{
        for (const [property, descriptor] of descriptors){
            const value = typeof promise === 'function' ? (...args)=>Reflect.apply(descriptor.value, promise(), args) : descriptor.value.bind(promise);
            Reflect.defineProperty(spawned, property, {
                ...descriptor,
                value
            });
        }
    };
    var getSpawnedPromise = (spawned)=>new Promise((resolve, reject)=>{
            spawned.on('exit', (exitCode, signal)=>{
                resolve({
                    exitCode,
                    signal
                });
            });
            spawned.on('error', (error)=>{
                reject(error);
            });
            if (spawned.stdin) {
                spawned.stdin.on('error', (error)=>{
                    reject(error);
                });
            }
        });
}
,
"d4b3f209":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    module.exports = compose;
    function compose(middleware) {
        if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!');
        for (const fn of middleware){
            if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!');
        }
        return function(context, next) {
            let index = -1;
            return dispatch(0);
            function dispatch(i) {
                if (i <= index) return Promise.reject(new Error('next() called multiple times'));
                index = i;
                let fn = middleware[i];
                if (i === middleware.length) fn = next;
                if (!fn) return Promise.resolve();
                try {
                    return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));
                } catch (err) {
                    return Promise.reject(err);
                }
            }
        };
    }
}
,
"d55f25ca":/*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    module.exports = onFinished;
    module.exports.isFinished = isFinished;
    var asyncHooks = tryRequireAsyncHooks();
    var first = farmRequire("acf9ef2b", true);
    var defer = typeof setImmediate === 'function' ? setImmediate : function(fn) {
        process.nextTick(fn.bind.apply(fn, arguments));
    };
    function onFinished(msg, listener) {
        if (isFinished(msg) !== false) {
            defer(listener, null, msg);
            return msg;
        }
        attachListener(msg, wrap(listener));
        return msg;
    }
    function isFinished(msg) {
        var socket = msg.socket;
        if (typeof msg.finished === 'boolean') {
            return Boolean(msg.finished || socket && !socket.writable);
        }
        if (typeof msg.complete === 'boolean') {
            return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
        }
        return undefined;
    }
    function attachFinishedListener(msg, callback) {
        var eeMsg;
        var eeSocket;
        var finished = false;
        function onFinish(error) {
            eeMsg.cancel();
            eeSocket.cancel();
            finished = true;
            callback(error);
        }
        eeMsg = eeSocket = first([
            [
                msg,
                'end',
                'finish'
            ]
        ], onFinish);
        function onSocket(socket) {
            msg.removeListener('socket', onSocket);
            if (finished) return;
            if (eeMsg !== eeSocket) return;
            eeSocket = first([
                [
                    socket,
                    'error',
                    'close'
                ]
            ], onFinish);
        }
        if (msg.socket) {
            onSocket(msg.socket);
            return;
        }
        msg.on('socket', onSocket);
        if (msg.socket === undefined) {
            patchAssignSocket(msg, onSocket);
        }
    }
    function attachListener(msg, listener) {
        var attached = msg.__onFinished;
        if (!attached || !attached.queue) {
            attached = msg.__onFinished = createListener(msg);
            attachFinishedListener(msg, attached);
        }
        attached.queue.push(listener);
    }
    function createListener(msg) {
        function listener(err) {
            if (msg.__onFinished === listener) msg.__onFinished = null;
            if (!listener.queue) return;
            var queue = listener.queue;
            listener.queue = null;
            for(var i = 0; i < queue.length; i++){
                queue[i](err, msg);
            }
        }
        listener.queue = [];
        return listener;
    }
    function patchAssignSocket(res, callback) {
        var assignSocket = res.assignSocket;
        if (typeof assignSocket !== 'function') return;
        res.assignSocket = function _assignSocket(socket) {
            assignSocket.call(this, socket);
            callback(socket);
        };
    }
    function tryRequireAsyncHooks() {
        try {
            return global.nodeRequire('async_hooks', true);
        } catch (e) {
            return {};
        }
    }
    function wrap(fn) {
        var res;
        if (asyncHooks.AsyncResource) {
            res = new asyncHooks.AsyncResource(fn.name || 'bound-anonymous-fn');
        }
        if (!res || !res.runInAsyncScope) {
            return fn;
        }
        return res.runInAsyncScope.bind(res, fn, null);
    }
}
,
"d6403b64":function  (module, exports, farmRequire, farmDynamicRequire) {
    if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
        module.exports = farmRequire("abea2f29", true);
    } else {
        module.exports = farmRequire("aa04e221", true);
    }
}
,
"d6873c6c":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.proxyEventsPlugin = void 0;
    const debug_1 = farmRequire("2f90b0a5", true);
    const function_1 = farmRequire("f8468536", true);
    const debug = debug_1.Debug.extend('proxy-events-plugin');
    const proxyEventsPlugin = (proxyServer, options)=>{
        Object.entries(options.on || {}).forEach(([eventName, handler])=>{
            debug(`register event handler: "${eventName}" -> "${(0, function_1.getFunctionName)(handler)}"`);
            proxyServer.on(eventName, handler);
        });
    };
    exports.proxyEventsPlugin = proxyEventsPlugin;
}
,
"d7234094":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const utils = farmRequire("781fd2fa", true);
    class Matcher {
        constructor(_patterns, _settings, _micromatchOptions){
            this._patterns = _patterns;
            this._settings = _settings;
            this._micromatchOptions = _micromatchOptions;
            this._storage = [];
            this._fillStorage();
        }
        _fillStorage() {
            for (const pattern of this._patterns){
                const segments = this._getPatternSegments(pattern);
                const sections = this._splitSegmentsIntoSections(segments);
                this._storage.push({
                    complete: sections.length <= 1,
                    pattern,
                    segments,
                    sections
                });
            }
        }
        _getPatternSegments(pattern) {
            const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);
            return parts.map((part)=>{
                const dynamic = utils.pattern.isDynamicPattern(part, this._settings);
                if (!dynamic) {
                    return {
                        dynamic: false,
                        pattern: part
                    };
                }
                return {
                    dynamic: true,
                    pattern: part,
                    patternRe: utils.pattern.makeRe(part, this._micromatchOptions)
                };
            });
        }
        _splitSegmentsIntoSections(segments) {
            return utils.array.splitWhen(segments, (segment)=>segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));
        }
    }
    exports.default = Matcher;
}
,
"d8312835":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
            desc = {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            };
        }
        Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    });
    var __exportStar = this && this.__exportStar || function(m, exports1) {
        for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
    };
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.createProxyMiddleware = void 0;
    const http_proxy_middleware_1 = farmRequire("81da7c90", true);
    function createProxyMiddleware(options) {
        const { middleware } = new http_proxy_middleware_1.HttpProxyMiddleware(options);
        return middleware;
    }
    exports.createProxyMiddleware = createProxyMiddleware;
    __exportStar(farmRequire("5bde615a", true), exports);
    __exportStar(farmRequire("31748dff", true), exports);
    __exportStar(farmRequire("fa0a3c2a", true), exports);
}
,
"d874708b":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "ViteDevServerAdapter", ()=>ViteDevServerAdapter);
    module.o(exports, "ViteModuleGraphAdapter", ()=>ViteModuleGraphAdapter);
    module.o(exports, "createViteDevServerAdapter", ()=>createViteDevServerAdapter);
    module.o(exports, "createViteModuleGraphAdapter", ()=>createViteModuleGraphAdapter);
    var _f_utils = farmRequire("e60815f7");
    class ViteDevServerAdapter {
        moduleGraph;
        config;
        pluginName;
        watcher;
        middlewares;
        middlewareCallbacks;
        ws;
        httpServer;
        constructor(pluginName, config, server){
            this.moduleGraph = createViteModuleGraphAdapter(pluginName);
            this.config = config;
            this.pluginName = pluginName;
            this.watcher = server.watcher.getInternalWatcher();
            this.middlewareCallbacks = [];
            this.middlewares = new Proxy({
                use: (...args)=>{
                    if (args.length === 2 && typeof args[0] === 'string' && typeof args[1] === 'function') {
                        this.middlewareCallbacks.push((req, res, next)=>{
                            const [url, cb] = args;
                            if (req.url.startsWith(url)) {
                                cb(req, res, next);
                            }
                        });
                    } else if (args.length === 1 && typeof args[0] === 'function') {
                        this.middlewareCallbacks.push(args[0]);
                    }
                }
            }, {
                get (target, key) {
                    if (key === 'use') {
                        return target[key];
                    }
                    _f_utils.throwIncompatibleError(pluginName, 'viteDevServer.middlewares', [
                        'use'
                    ], key);
                }
            });
            this.ws = server.ws;
            this.httpServer = server.server;
        }
    }
    class ViteModuleGraphAdapter {
        context;
        pluginName;
        constructor(pluginName){
            this.context = undefined;
            this.pluginName = pluginName;
        }
        getModulesByFile(file) {
            const raw = this.context.viteGetModulesByFile(file);
            return raw.map((item)=>{
                return proxyViteModuleNode(item, this.pluginName, this.context);
            });
        }
        getModuleById(id) {
            const raw = this.context.viteGetModuleById(id);
            if (raw) {
                return proxyViteModuleNode(raw, this.pluginName, this.context);
            }
        }
        async getModuleByUrl(url) {
            if (url.startsWith('/')) {
                url = url.slice(1);
                const raw = this.context.viteGetModuleById(url);
                if (raw) {
                    return proxyViteModuleNode(raw, this.pluginName, this.context);
                }
            }
        }
        invalidateModule() {}
    }
    function proxyViteModuleNode(node, pluginName, context) {
        const proxy = new Proxy(node, {
            get (target, key) {
                if (key === 'importers') {
                    return context.viteGetImporters(target.id);
                }
                const allowedKeys = [
                    'url',
                    'id',
                    'file',
                    'type'
                ];
                if (allowedKeys.includes(String(key))) {
                    return target[key];
                }
                _f_utils.throwIncompatibleError(pluginName, 'viteModuleNode', allowedKeys, key);
            }
        });
        return proxy;
    }
    function createViteDevServerAdapter(pluginName, config, server) {
        const proxy = new Proxy(new ViteDevServerAdapter(pluginName, config, server), {
            get (target, key) {
                const objectKeys = [
                    'constructor',
                    'Symbol(Symbol.toStringTag)',
                    'prototype'
                ];
                const allowedKeys = [
                    'moduleGraph',
                    'config',
                    'watcher',
                    'middlewares',
                    'middlewareCallbacks',
                    'ws',
                    'httpServer'
                ];
                if (objectKeys.includes(String(key)) || allowedKeys.includes(String(key))) {
                    return target[key];
                }
                _f_utils.throwIncompatibleError(pluginName, 'viteDevServer', allowedKeys, key);
            }
        });
        return proxy;
    }
    function createViteModuleGraphAdapter(pluginName) {
        const proxy = new Proxy(new ViteModuleGraphAdapter(pluginName), {
            get (target, key) {
                const allowedKeys = [
                    'getModulesByFile',
                    'getModuleById',
                    'getModuleByUrl',
                    'invalidateModule'
                ];
                const ownkeys = Reflect.ownKeys(target);
                if (allowedKeys.includes(String(key)) || ownkeys.includes(key)) {
                    return target[key];
                }
                _f_utils.throwIncompatibleError(pluginName, 'viteModuleGraph', allowedKeys, key);
            },
            set (target, p, newValue, _receiver) {
                if (p === 'context') {
                    target.context = newValue;
                    return true;
                }
                _f_utils.throwIncompatibleError(pluginName, 'viteModuleGraph', [
                    'context'
                ], p);
            }
        });
        return proxy;
    }
}
,
"d8812774":function  (module, exports, farmRequire, farmDynamicRequire) {
    module.exports = function(obj, keys) {
        obj = obj || {};
        if ('string' == typeof keys) keys = keys.split(/ +/);
        return keys.reduce(function(ret, key) {
            if (null == obj[key]) return ret;
            ret[key] = obj[key];
            return ret;
        }, {});
    };
}
,
"d8ec500a":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "hmrPing", ()=>hmrPing);
    function hmrPing() {
        return async (ctx, next)=>{
            if (ctx.get('accept') === 'text/x-farm-ping') {
                ctx.status = 204;
            } else {
                await next();
            }
        };
    }
}
,
"d932692c":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    module.exports = preferredCharsets;
    module.exports.preferredCharsets = preferredCharsets;
    var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
    function parseAcceptCharset(accept) {
        var accepts = accept.split(',');
        for(var i = 0, j = 0; i < accepts.length; i++){
            var charset = parseCharset(accepts[i].trim(), i);
            if (charset) {
                accepts[j++] = charset;
            }
        }
        accepts.length = j;
        return accepts;
    }
    function parseCharset(str, i) {
        var match = simpleCharsetRegExp.exec(str);
        if (!match) return null;
        var charset = match[1];
        var q = 1;
        if (match[2]) {
            var params = match[2].split(';');
            for(var j = 0; j < params.length; j++){
                var p = params[j].trim().split('=');
                if (p[0] === 'q') {
                    q = parseFloat(p[1]);
                    break;
                }
            }
        }
        return {
            charset: charset,
            q: q,
            i: i
        };
    }
    function getCharsetPriority(charset, accepted, index) {
        var priority = {
            o: -1,
            q: 0,
            s: 0
        };
        for(var i = 0; i < accepted.length; i++){
            var spec = specify(charset, accepted[i], index);
            if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
                priority = spec;
            }
        }
        return priority;
    }
    function specify(charset, spec, index) {
        var s = 0;
        if (spec.charset.toLowerCase() === charset.toLowerCase()) {
            s |= 1;
        } else if (spec.charset !== '*') {
            return null;
        }
        return {
            i: index,
            o: spec.i,
            q: spec.q,
            s: s
        };
    }
    function preferredCharsets(accept, provided) {
        var accepts = parseAcceptCharset(accept === undefined ? '*' : accept || '');
        if (!provided) {
            return accepts.filter(isQuality).sort(compareSpecs).map(getFullCharset);
        }
        var priorities = provided.map(function getPriority(type, index) {
            return getCharsetPriority(type, accepts, index);
        });
        return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
            return provided[priorities.indexOf(priority)];
        });
    }
    function compareSpecs(a, b) {
        return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }
    function getFullCharset(spec) {
        return spec.charset;
    }
    function isQuality(spec) {
        return spec.q > 0;
    }
}
,
"d974ce93":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    function setup(env) {
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = farmRequire("91b8e001", true);
        Object.keys(env).forEach(function(key) {
            createDebug[key] = env[key];
        });
        createDebug.instances = [];
        createDebug.names = [];
        createDebug.skips = [];
        createDebug.formatters = {};
        function selectColor(namespace) {
            var hash = 0;
            for(var i = 0; i < namespace.length; i++){
                hash = (hash << 5) - hash + namespace.charCodeAt(i);
                hash |= 0;
            }
            return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
        }
        createDebug.selectColor = selectColor;
        function createDebug(namespace) {
            var prevTime;
            function debug() {
                if (!debug.enabled) {
                    return;
                }
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                var self = debug;
                var curr = Number(new Date());
                var ms = curr - (prevTime || curr);
                self.diff = ms;
                self.prev = prevTime;
                self.curr = curr;
                prevTime = curr;
                args[0] = createDebug.coerce(args[0]);
                if (typeof args[0] !== 'string') {
                    args.unshift('%O');
                }
                var index = 0;
                args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
                    if (match === '%%') {
                        return match;
                    }
                    index++;
                    var formatter = createDebug.formatters[format];
                    if (typeof formatter === 'function') {
                        var val = args[index];
                        match = formatter.call(self, val);
                        args.splice(index, 1);
                        index--;
                    }
                    return match;
                });
                createDebug.formatArgs.call(self, args);
                var logFn = self.log || createDebug.log;
                logFn.apply(self, args);
            }
            debug.namespace = namespace;
            debug.enabled = createDebug.enabled(namespace);
            debug.useColors = createDebug.useColors();
            debug.color = selectColor(namespace);
            debug.destroy = destroy;
            debug.extend = extend;
            if (typeof createDebug.init === 'function') {
                createDebug.init(debug);
            }
            createDebug.instances.push(debug);
            return debug;
        }
        function destroy() {
            var index = createDebug.instances.indexOf(this);
            if (index !== -1) {
                createDebug.instances.splice(index, 1);
                return true;
            }
            return false;
        }
        function extend(namespace, delimiter) {
            return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
        }
        function enable(namespaces) {
            createDebug.save(namespaces);
            createDebug.names = [];
            createDebug.skips = [];
            var i;
            var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
            var len = split.length;
            for(i = 0; i < len; i++){
                if (!split[i]) {
                    continue;
                }
                namespaces = split[i].replace(/\*/g, '.*?');
                if (namespaces[0] === '-') {
                    createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
                } else {
                    createDebug.names.push(new RegExp('^' + namespaces + '$'));
                }
            }
            for(i = 0; i < createDebug.instances.length; i++){
                var instance = createDebug.instances[i];
                instance.enabled = createDebug.enabled(instance.namespace);
            }
        }
        function disable() {
            createDebug.enable('');
        }
        function enabled(name) {
            if (name[name.length - 1] === '*') {
                return true;
            }
            var i;
            var len;
            for(i = 0, len = createDebug.skips.length; i < len; i++){
                if (createDebug.skips[i].test(name)) {
                    return false;
                }
            }
            for(i = 0, len = createDebug.names.length; i < len; i++){
                if (createDebug.names[i].test(name)) {
                    return true;
                }
            }
            return false;
        }
        function coerce(val) {
            if (val instanceof Error) {
                return val.stack || val.message;
            }
            return val;
        }
        createDebug.enable(createDebug.load());
        return createDebug;
    }
    module.exports = setup;
}
,
"df6e4745":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.loggerPlugin = void 0;
    const logger_1 = farmRequire("634664d9", true);
    const loggerPlugin = (proxyServer, options)=>{
        const logger = (0, logger_1.getLogger)(options);
        proxyServer.on('error', (err, req, res, target)=>{
            const hostname = req?.headers?.host;
            const requestHref = `${hostname}${req?.url}`;
            const targetHref = `${target?.href}`;
            const errorMessage = '[HPM] Error occurred while proxying request %s to %s [%s] (%s)';
            const errReference = 'https://nodejs.org/api/errors.html#errors_common_system_errors';
            logger.error(errorMessage, requestHref, targetHref, err.code || err, errReference);
        });
        proxyServer.on('proxyRes', (proxyRes, req, res)=>{
            const originalUrl = req.originalUrl ?? `${req.baseUrl || ''}${req.url}`;
            const exchange = `[HPM] ${req.method} ${originalUrl} -> ${proxyRes.req.protocol}//${proxyRes.req.host}${proxyRes.req.path} [${proxyRes.statusCode}]`;
            logger.info(exchange);
        });
        proxyServer.on('open', (socket)=>{
            logger.info('[HPM] Client connected: %o', socket.address());
        });
        proxyServer.on('close', (req, proxySocket, proxyHead)=>{
            logger.info('[HPM] Client disconnected: %o', proxySocket.address());
        });
    };
    exports.loggerPlugin = loggerPlugin;
}
,
"dfdc0c03":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const isGeneratorFunction = farmRequire("fc37adc9", true);
    const debug = farmRequire("50d83445")('koa:application');
    const onFinished = farmRequire("d55f25ca", true);
    const assert = global.nodeRequire('assert', true);
    const response = farmRequire("650ab9d4", true);
    const compose = farmRequire("d4b3f209", true);
    const context = farmRequire("675a7cc5", true);
    const request = farmRequire("8f02d3ce", true);
    const statuses = farmRequire("5be87a60", true);
    const Emitter = global.nodeRequire('events', true);
    const util = global.nodeRequire('util', true);
    const Stream = global.nodeRequire('stream', true);
    const http = global.nodeRequire('http', true);
    const only = farmRequire("d8812774", true);
    const convert = farmRequire("8c2cda22", true);
    const deprecate = farmRequire("ceabc55b")('koa');
    const { HttpError } = farmRequire("48aa4d88", true);
    module.exports = class Application extends Emitter {
        constructor(options){
            super();
            options = options || {};
            this.proxy = options.proxy || false;
            this.subdomainOffset = options.subdomainOffset || 2;
            this.proxyIpHeader = options.proxyIpHeader || 'X-Forwarded-For';
            this.maxIpsCount = options.maxIpsCount || 0;
            this.env = options.env || process.env.NODE_ENV || 'development';
            if (options.keys) this.keys = options.keys;
            this.middleware = [];
            this.context = Object.create(context);
            this.request = Object.create(request);
            this.response = Object.create(response);
            if (util.inspect.custom) {
                this[util.inspect.custom] = this.inspect;
            }
            if (options.asyncLocalStorage) {
                const { AsyncLocalStorage } = global.nodeRequire('async_hooks', true);
                assert(AsyncLocalStorage, 'Requires node 12.17.0 or higher to enable asyncLocalStorage');
                this.ctxStorage = new AsyncLocalStorage();
            }
        }
        listen(...args) {
            debug('listen');
            const server = http.createServer(this.callback());
            return server.listen(...args);
        }
        toJSON() {
            return only(this, [
                'subdomainOffset',
                'proxy',
                'env'
            ]);
        }
        inspect() {
            return this.toJSON();
        }
        use(fn) {
            if (typeof fn !== 'function') throw new TypeError('middleware must be a function!');
            if (isGeneratorFunction(fn)) {
                deprecate('Support for generators will be removed in v3. ' + 'See the documentation for examples of how to convert old middleware ' + 'https://github.com/koajs/koa/blob/master/docs/migration.md');
                fn = convert(fn);
            }
            debug('use %s', fn._name || fn.name || '-');
            this.middleware.push(fn);
            return this;
        }
        callback() {
            const fn = compose(this.middleware);
            if (!this.listenerCount('error')) this.on('error', this.onerror);
            const handleRequest = (req, res)=>{
                const ctx = this.createContext(req, res);
                if (!this.ctxStorage) {
                    return this.handleRequest(ctx, fn);
                }
                return this.ctxStorage.run(ctx, async ()=>{
                    return await this.handleRequest(ctx, fn);
                });
            };
            return handleRequest;
        }
        get currentContext() {
            if (this.ctxStorage) return this.ctxStorage.getStore();
        }
        handleRequest(ctx, fnMiddleware) {
            const res = ctx.res;
            res.statusCode = 404;
            const onerror = (err)=>ctx.onerror(err);
            const handleResponse = ()=>respond(ctx);
            onFinished(res, onerror);
            return fnMiddleware(ctx).then(handleResponse).catch(onerror);
        }
        createContext(req, res) {
            const context = Object.create(this.context);
            const request = context.request = Object.create(this.request);
            const response = context.response = Object.create(this.response);
            context.app = request.app = response.app = this;
            context.req = request.req = response.req = req;
            context.res = request.res = response.res = res;
            request.ctx = response.ctx = context;
            request.response = response;
            response.request = request;
            context.originalUrl = request.originalUrl = req.url;
            context.state = {};
            return context;
        }
        onerror(err) {
            const isNativeError = Object.prototype.toString.call(err) === '[object Error]' || err instanceof Error;
            if (!isNativeError) throw new TypeError(util.format('non-error thrown: %j', err));
            if (404 === err.status || err.expose) return;
            if (this.silent) return;
            const msg = err.stack || err.toString();
            console.error(`\n${msg.replace(/^/gm, '  ')}\n`);
        }
        static get default() {
            return Application;
        }
        createAsyncCtxStorageMiddleware() {
            const app = this;
            return async function asyncCtxStorage(ctx, next) {
                await app.ctxStorage.run(ctx, async ()=>{
                    return await next();
                });
            };
        }
    };
    function respond(ctx) {
        if (false === ctx.respond) return;
        if (!ctx.writable) return;
        const res = ctx.res;
        let body = ctx.body;
        const code = ctx.status;
        if (statuses.empty[code]) {
            ctx.body = null;
            return res.end();
        }
        if ('HEAD' === ctx.method) {
            if (!res.headersSent && !ctx.response.has('Content-Length')) {
                const { length } = ctx.response;
                if (Number.isInteger(length)) ctx.length = length;
            }
            return res.end();
        }
        if (null == body) {
            if (ctx.response._explicitNullBody) {
                ctx.response.remove('Content-Type');
                ctx.response.remove('Transfer-Encoding');
                return res.end();
            }
            if (ctx.req.httpVersionMajor >= 2) {
                body = String(code);
            } else {
                body = ctx.message || String(code);
            }
            if (!res.headersSent) {
                ctx.type = 'text';
                ctx.length = Buffer.byteLength(body);
            }
            return res.end(body);
        }
        if (Buffer.isBuffer(body)) return res.end(body);
        if ('string' === typeof body) return res.end(body);
        if (body instanceof Stream) return body.pipe(res);
        body = JSON.stringify(body);
        if (!res.headersSent) {
            ctx.length = Buffer.byteLength(body);
        }
        res.end(body);
    }
    module.exports.HttpError = HttpError;
}
,
"e01aad99":function  (module, exports, farmRequire, farmDynamicRequire) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (()=>{
        let warned = false;
        return ()=>{
            if (!warned) {
                warned = true;
                console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
            }
        };
    })();
    exports.colors = [
        '#0000CC',
        '#0000FF',
        '#0033CC',
        '#0033FF',
        '#0066CC',
        '#0066FF',
        '#0099CC',
        '#0099FF',
        '#00CC00',
        '#00CC33',
        '#00CC66',
        '#00CC99',
        '#00CCCC',
        '#00CCFF',
        '#3300CC',
        '#3300FF',
        '#3333CC',
        '#3333FF',
        '#3366CC',
        '#3366FF',
        '#3399CC',
        '#3399FF',
        '#33CC00',
        '#33CC33',
        '#33CC66',
        '#33CC99',
        '#33CCCC',
        '#33CCFF',
        '#6600CC',
        '#6600FF',
        '#6633CC',
        '#6633FF',
        '#66CC00',
        '#66CC33',
        '#9900CC',
        '#9900FF',
        '#9933CC',
        '#9933FF',
        '#99CC00',
        '#99CC33',
        '#CC0000',
        '#CC0033',
        '#CC0066',
        '#CC0099',
        '#CC00CC',
        '#CC00FF',
        '#CC3300',
        '#CC3333',
        '#CC3366',
        '#CC3399',
        '#CC33CC',
        '#CC33FF',
        '#CC6600',
        '#CC6633',
        '#CC9900',
        '#CC9933',
        '#CCCC00',
        '#CCCC33',
        '#FF0000',
        '#FF0033',
        '#FF0066',
        '#FF0099',
        '#FF00CC',
        '#FF00FF',
        '#FF3300',
        '#FF3333',
        '#FF3366',
        '#FF3399',
        '#FF33CC',
        '#FF33FF',
        '#FF6600',
        '#FF6633',
        '#FF9900',
        '#FF9933',
        '#FFCC00',
        '#FFCC33'
    ];
    function useColors() {
        if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
            return true;
        }
        if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
            return false;
        }
        return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
        args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
        if (!this.useColors) {
            return;
        }
        const c = 'color: ' + this.color;
        args.splice(1, 0, c, 'color: inherit');
        let index = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match)=>{
            if (match === '%%') {
                return;
            }
            index++;
            if (match === '%c') {
                lastC = index;
            }
        });
        args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (()=>{});
    function save(namespaces) {
        try {
            if (namespaces) {
                exports.storage.setItem('debug', namespaces);
            } else {
                exports.storage.removeItem('debug');
            }
        } catch (error) {}
    }
    function load() {
        let r;
        try {
            r = exports.storage.getItem('debug');
        } catch (error) {}
        if (!r && typeof process !== 'undefined' && 'env' in process) {
            r = process.env.DEBUG;
        }
        return r;
    }
    function localstorage() {
        try {
            return localStorage;
        } catch (error) {}
    }
    module.exports = farmRequire("2b9488fe")(exports);
    const { formatters } = module.exports;
    formatters.j = function(v) {
        try {
            return JSON.stringify(v);
        } catch (error) {
            return '[UnexpectedJSONParseError]: ' + error.message;
        }
    };
}
,
"e07bf137":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.read = void 0;
    function read(path, settings, callback) {
        settings.fs.lstat(path, (lstatError, lstat)=>{
            if (lstatError !== null) {
                callFailureCallback(callback, lstatError);
                return;
            }
            if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
                callSuccessCallback(callback, lstat);
                return;
            }
            settings.fs.stat(path, (statError, stat)=>{
                if (statError !== null) {
                    if (settings.throwErrorOnBrokenSymbolicLink) {
                        callFailureCallback(callback, statError);
                        return;
                    }
                    callSuccessCallback(callback, lstat);
                    return;
                }
                if (settings.markSymbolicLink) {
                    stat.isSymbolicLink = ()=>true;
                }
                callSuccessCallback(callback, stat);
            });
        });
    }
    exports.read = read;
    function callFailureCallback(callback, error) {
        callback(error);
    }
    function callSuccessCallback(callback, result) {
        callback(null, result);
    }
}
,
"e0afbeaa":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "joinCommand", ()=>joinCommand);
    module.o(exports, "getEscapedCommand", ()=>getEscapedCommand);
    module.o(exports, "parseTemplates", ()=>parseTemplates);
    var _f_node_buffer = farmRequire('node:buffer');
    var _f_node_child_process = farmRequire('node:child_process');
    const normalizeArgs = (file, args = [])=>{
        if (!Array.isArray(args)) {
            return [
                file
            ];
        }
        return [
            file,
            ...args
        ];
    };
    const NO_ESCAPE_REGEXP = /^[\w.-]+$/;
    const DOUBLE_QUOTES_REGEXP = /"/g;
    const escapeArg = (arg)=>{
        if (typeof arg !== 'string' || NO_ESCAPE_REGEXP.test(arg)) {
            return arg;
        }
        return `"${arg.replace(DOUBLE_QUOTES_REGEXP, '\\"')}"`;
    };
    var joinCommand = (file, args)=>normalizeArgs(file, args).join(' ');
    var getEscapedCommand = (file, args)=>normalizeArgs(file, args).map((arg)=>escapeArg(arg)).join(' ');
    const SPACES_REGEXP = / +/g;
    const parseExpression = (expression)=>{
        const typeOfExpression = typeof expression;
        if (typeOfExpression === 'string') {
            return expression;
        }
        if (typeOfExpression === 'number') {
            return String(expression);
        }
        if (typeOfExpression === 'object' && expression !== null && !(expression instanceof _f_node_child_process.ChildProcess) && 'stdout' in expression) {
            const typeOfStdout = typeof expression.stdout;
            if (typeOfStdout === 'string') {
                return expression.stdout;
            }
            if (_f_node_buffer.Buffer.isBuffer(expression.stdout)) {
                return expression.stdout.toString();
            }
            throw new TypeError(`Unexpected "${typeOfStdout}" stdout in template expression`);
        }
        throw new TypeError(`Unexpected "${typeOfExpression}" in template expression`);
    };
    const concatTokens = (tokens, nextTokens, isNew)=>isNew || tokens.length === 0 || nextTokens.length === 0 ? [
            ...tokens,
            ...nextTokens
        ] : [
            ...tokens.slice(0, -1),
            `${tokens[tokens.length - 1]}${nextTokens[0]}`,
            ...nextTokens.slice(1)
        ];
    const parseTemplate = ({ templates, expressions, tokens, index, template })=>{
        const templateString = template ?? templates.raw[index];
        const templateTokens = templateString.split(SPACES_REGEXP).filter(Boolean);
        const newTokens = concatTokens(tokens, templateTokens, templateString.startsWith(' '));
        if (index === expressions.length) {
            return newTokens;
        }
        const expression = expressions[index];
        const expressionTokens = Array.isArray(expression) ? expression.map((expression)=>parseExpression(expression)) : [
            parseExpression(expression)
        ];
        return concatTokens(newTokens, expressionTokens, templateString.endsWith(' '));
    };
    var parseTemplates = (templates, expressions)=>{
        let tokens = [];
        for (const [index, template] of templates.entries()){
            tokens = parseTemplate({
                templates,
                expressions,
                tokens,
                index,
                template
            });
        }
        return tokens;
    };
}
,
"e0cde53a":/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    var db = farmRequire("d0446bff", true);
    var extname = global.nodeRequire('path', true).extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports.charset = charset;
    exports.charsets = {
        lookup: charset
    };
    exports.contentType = contentType;
    exports.extension = extension;
    exports.extensions = Object.create(null);
    exports.lookup = lookup;
    exports.types = Object.create(null);
    populateMaps(exports.extensions, exports.types);
    function charset(type) {
        if (!type || typeof type !== 'string') {
            return false;
        }
        var match = EXTRACT_TYPE_REGEXP.exec(type);
        var mime = match && db[match[1].toLowerCase()];
        if (mime && mime.charset) {
            return mime.charset;
        }
        if (match && TEXT_TYPE_REGEXP.test(match[1])) {
            return 'UTF-8';
        }
        return false;
    }
    function contentType(str) {
        if (!str || typeof str !== 'string') {
            return false;
        }
        var mime = str.indexOf('/') === -1 ? exports.lookup(str) : str;
        if (!mime) {
            return false;
        }
        if (mime.indexOf('charset') === -1) {
            var charset = exports.charset(mime);
            if (charset) mime += '; charset=' + charset.toLowerCase();
        }
        return mime;
    }
    function extension(type) {
        if (!type || typeof type !== 'string') {
            return false;
        }
        var match = EXTRACT_TYPE_REGEXP.exec(type);
        var exts = match && exports.extensions[match[1].toLowerCase()];
        if (!exts || !exts.length) {
            return false;
        }
        return exts[0];
    }
    function lookup(path) {
        if (!path || typeof path !== 'string') {
            return false;
        }
        var extension = extname('x.' + path).toLowerCase().substr(1);
        if (!extension) {
            return false;
        }
        return exports.types[extension] || false;
    }
    function populateMaps(extensions, types) {
        var preference = [
            'nginx',
            'apache',
            undefined,
            'iana'
        ];
        Object.keys(db).forEach(function forEachMimeType(type) {
            var mime = db[type];
            var exts = mime.extensions;
            if (!exts || !exts.length) {
                return;
            }
            extensions[type] = exts;
            for(var i = 0; i < exts.length; i++){
                var extension = exts[i];
                if (types[extension]) {
                    var from = preference.indexOf(db[types[extension]].source);
                    var to = preference.indexOf(mime.source);
                    if (types[extension] !== 'application/octet-stream' && (from > to || from === to && types[extension].substr(0, 12) === 'application/')) {
                        continue;
                    }
                }
                types[extension] = type;
            }
        });
    }
}
,
"e0e571dc":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const isWin = process.platform === 'win32';
    function notFoundError(original, syscall) {
        return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
            code: 'ENOENT',
            errno: 'ENOENT',
            syscall: `${syscall} ${original.command}`,
            path: original.command,
            spawnargs: original.args
        });
    }
    function hookChildProcess(cp, parsed) {
        if (!isWin) {
            return;
        }
        const originalEmit = cp.emit;
        cp.emit = function(name, arg1) {
            if (name === 'exit') {
                const err = verifyENOENT(arg1, parsed, 'spawn');
                if (err) {
                    return originalEmit.call(cp, 'error', err);
                }
            }
            return originalEmit.apply(cp, arguments);
        };
    }
    function verifyENOENT(status, parsed) {
        if (isWin && status === 1 && !parsed.file) {
            return notFoundError(parsed.original, 'spawn');
        }
        return null;
    }
    function verifyENOENTSync(status, parsed) {
        if (isWin && status === 1 && !parsed.file) {
            return notFoundError(parsed.original, 'spawnSync');
        }
        return null;
    }
    module.exports = {
        hookChildProcess,
        verifyENOENT,
        verifyENOENTSync,
        notFoundError
    };
}
,
"e1334335":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "slash", ()=>slash);
    module.o(exports, "withTrailingSlash", ()=>withTrailingSlash);
    module.o(exports, "stripQueryAndHash", ()=>stripQueryAndHash);
    const windowsSlashRE = /\\/g;
    function slash(p) {
        return p.replace(windowsSlashRE, '/');
    }
    function withTrailingSlash(path) {
        if (path[path.length - 1] !== '/') {
            return `${path}/`;
        }
        return path;
    }
    const postfixRE = /[?#].*$/;
    function stripQueryAndHash(path) {
        return path.replace(postfixRE, '');
    }
}
,
"e144cb35":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const fs = global.nodeRequire('fs', true);
    let isDocker;
    function hasDockerEnv() {
        try {
            fs.statSync('/.dockerenv');
            return true;
        } catch (_) {
            return false;
        }
    }
    function hasDockerCGroup() {
        try {
            return fs.readFileSync('/proc/self/cgroup', 'utf8').includes('docker');
        } catch (_) {
            return false;
        }
    }
    module.exports = ()=>{
        if (isDocker === undefined) {
            isDocker = hasDockerEnv() || hasDockerCGroup();
        }
        return isDocker;
    };
}
,
"e3384cb5":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "normalizeAsset", ()=>normalizeAsset);
    var _f_constants = farmRequire("97f6a66c");
    function normalizeAsset(config, resolvedCompilation) {
        if (config.compilation?.assets?.mode) {
            const mode = config.compilation.assets.mode;
            resolvedCompilation.custom[_f_constants.CUSTOM_KEYS.assets_mode] = JSON.stringify(mode);
        }
    }
}
,
"e4009425":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const EventEmitter = global.nodeRequire('events', true);
    const https = global.nodeRequire('https', true);
    const http = global.nodeRequire('http', true);
    const net = global.nodeRequire('net', true);
    const tls = global.nodeRequire('tls', true);
    const { randomBytes, createHash } = global.nodeRequire('crypto', true);
    const { Duplex, Readable } = global.nodeRequire('stream', true);
    const { URL } = global.nodeRequire('url', true);
    const PerMessageDeflate = farmRequire("6e9f2004", true);
    const Receiver = farmRequire("a575bc6d", true);
    const Sender = farmRequire("30e626fc", true);
    const { BINARY_TYPES, EMPTY_BUFFER, GUID, kForOnEventAttribute, kListener, kStatusCode, kWebSocket, NOOP } = farmRequire("75844d1d", true);
    const { EventTarget: { addEventListener, removeEventListener } } = farmRequire("42b516ab", true);
    const { format, parse } = farmRequire("e7a96878", true);
    const { toBuffer } = farmRequire("2be17525", true);
    const closeTimeout = 30 * 1000;
    const kAborted = Symbol('kAborted');
    const protocolVersions = [
        8,
        13
    ];
    const readyStates = [
        'CONNECTING',
        'OPEN',
        'CLOSING',
        'CLOSED'
    ];
    const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    class WebSocket extends EventEmitter {
        constructor(address, protocols, options){
            super();
            this._binaryType = BINARY_TYPES[0];
            this._closeCode = 1006;
            this._closeFrameReceived = false;
            this._closeFrameSent = false;
            this._closeMessage = EMPTY_BUFFER;
            this._closeTimer = null;
            this._extensions = {};
            this._paused = false;
            this._protocol = '';
            this._readyState = WebSocket.CONNECTING;
            this._receiver = null;
            this._sender = null;
            this._socket = null;
            if (address !== null) {
                this._bufferedAmount = 0;
                this._isServer = false;
                this._redirects = 0;
                if (protocols === undefined) {
                    protocols = [];
                } else if (!Array.isArray(protocols)) {
                    if (typeof protocols === 'object' && protocols !== null) {
                        options = protocols;
                        protocols = [];
                    } else {
                        protocols = [
                            protocols
                        ];
                    }
                }
                initAsClient(this, address, protocols, options);
            } else {
                this._isServer = true;
            }
        }
        get binaryType() {
            return this._binaryType;
        }
        set binaryType(type) {
            if (!BINARY_TYPES.includes(type)) return;
            this._binaryType = type;
            if (this._receiver) this._receiver._binaryType = type;
        }
        get bufferedAmount() {
            if (!this._socket) return this._bufferedAmount;
            return this._socket._writableState.length + this._sender._bufferedBytes;
        }
        get extensions() {
            return Object.keys(this._extensions).join();
        }
        get isPaused() {
            return this._paused;
        }
        get onclose() {
            return null;
        }
        get onerror() {
            return null;
        }
        get onopen() {
            return null;
        }
        get onmessage() {
            return null;
        }
        get protocol() {
            return this._protocol;
        }
        get readyState() {
            return this._readyState;
        }
        get url() {
            return this._url;
        }
        setSocket(socket, head, options) {
            const receiver = new Receiver({
                binaryType: this.binaryType,
                extensions: this._extensions,
                isServer: this._isServer,
                maxPayload: options.maxPayload,
                skipUTF8Validation: options.skipUTF8Validation
            });
            this._sender = new Sender(socket, this._extensions, options.generateMask);
            this._receiver = receiver;
            this._socket = socket;
            receiver[kWebSocket] = this;
            socket[kWebSocket] = this;
            receiver.on('conclude', receiverOnConclude);
            receiver.on('drain', receiverOnDrain);
            receiver.on('error', receiverOnError);
            receiver.on('message', receiverOnMessage);
            receiver.on('ping', receiverOnPing);
            receiver.on('pong', receiverOnPong);
            if (socket.setTimeout) socket.setTimeout(0);
            if (socket.setNoDelay) socket.setNoDelay();
            if (head.length > 0) socket.unshift(head);
            socket.on('close', socketOnClose);
            socket.on('data', socketOnData);
            socket.on('end', socketOnEnd);
            socket.on('error', socketOnError);
            this._readyState = WebSocket.OPEN;
            this.emit('open');
        }
        emitClose() {
            if (!this._socket) {
                this._readyState = WebSocket.CLOSED;
                this.emit('close', this._closeCode, this._closeMessage);
                return;
            }
            if (this._extensions[PerMessageDeflate.extensionName]) {
                this._extensions[PerMessageDeflate.extensionName].cleanup();
            }
            this._receiver.removeAllListeners();
            this._readyState = WebSocket.CLOSED;
            this.emit('close', this._closeCode, this._closeMessage);
        }
        close(code, data) {
            if (this.readyState === WebSocket.CLOSED) return;
            if (this.readyState === WebSocket.CONNECTING) {
                const msg = 'WebSocket was closed before the connection was established';
                abortHandshake(this, this._req, msg);
                return;
            }
            if (this.readyState === WebSocket.CLOSING) {
                if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
                    this._socket.end();
                }
                return;
            }
            this._readyState = WebSocket.CLOSING;
            this._sender.close(code, data, !this._isServer, (err)=>{
                if (err) return;
                this._closeFrameSent = true;
                if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
                    this._socket.end();
                }
            });
            this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);
        }
        pause() {
            if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
                return;
            }
            this._paused = true;
            this._socket.pause();
        }
        ping(data, mask, cb) {
            if (this.readyState === WebSocket.CONNECTING) {
                throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
            }
            if (typeof data === 'function') {
                cb = data;
                data = mask = undefined;
            } else if (typeof mask === 'function') {
                cb = mask;
                mask = undefined;
            }
            if (typeof data === 'number') data = data.toString();
            if (this.readyState !== WebSocket.OPEN) {
                sendAfterClose(this, data, cb);
                return;
            }
            if (mask === undefined) mask = !this._isServer;
            this._sender.ping(data || EMPTY_BUFFER, mask, cb);
        }
        pong(data, mask, cb) {
            if (this.readyState === WebSocket.CONNECTING) {
                throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
            }
            if (typeof data === 'function') {
                cb = data;
                data = mask = undefined;
            } else if (typeof mask === 'function') {
                cb = mask;
                mask = undefined;
            }
            if (typeof data === 'number') data = data.toString();
            if (this.readyState !== WebSocket.OPEN) {
                sendAfterClose(this, data, cb);
                return;
            }
            if (mask === undefined) mask = !this._isServer;
            this._sender.pong(data || EMPTY_BUFFER, mask, cb);
        }
        resume() {
            if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
                return;
            }
            this._paused = false;
            if (!this._receiver._writableState.needDrain) this._socket.resume();
        }
        send(data, options, cb) {
            if (this.readyState === WebSocket.CONNECTING) {
                throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
            }
            if (typeof options === 'function') {
                cb = options;
                options = {};
            }
            if (typeof data === 'number') data = data.toString();
            if (this.readyState !== WebSocket.OPEN) {
                sendAfterClose(this, data, cb);
                return;
            }
            const opts = {
                binary: typeof data !== 'string',
                mask: !this._isServer,
                compress: true,
                fin: true,
                ...options
            };
            if (!this._extensions[PerMessageDeflate.extensionName]) {
                opts.compress = false;
            }
            this._sender.send(data || EMPTY_BUFFER, opts, cb);
        }
        terminate() {
            if (this.readyState === WebSocket.CLOSED) return;
            if (this.readyState === WebSocket.CONNECTING) {
                const msg = 'WebSocket was closed before the connection was established';
                abortHandshake(this, this._req, msg);
                return;
            }
            if (this._socket) {
                this._readyState = WebSocket.CLOSING;
                this._socket.destroy();
            }
        }
    }
    Object.defineProperty(WebSocket, 'CONNECTING', {
        enumerable: true,
        value: readyStates.indexOf('CONNECTING')
    });
    Object.defineProperty(WebSocket.prototype, 'CONNECTING', {
        enumerable: true,
        value: readyStates.indexOf('CONNECTING')
    });
    Object.defineProperty(WebSocket, 'OPEN', {
        enumerable: true,
        value: readyStates.indexOf('OPEN')
    });
    Object.defineProperty(WebSocket.prototype, 'OPEN', {
        enumerable: true,
        value: readyStates.indexOf('OPEN')
    });
    Object.defineProperty(WebSocket, 'CLOSING', {
        enumerable: true,
        value: readyStates.indexOf('CLOSING')
    });
    Object.defineProperty(WebSocket.prototype, 'CLOSING', {
        enumerable: true,
        value: readyStates.indexOf('CLOSING')
    });
    Object.defineProperty(WebSocket, 'CLOSED', {
        enumerable: true,
        value: readyStates.indexOf('CLOSED')
    });
    Object.defineProperty(WebSocket.prototype, 'CLOSED', {
        enumerable: true,
        value: readyStates.indexOf('CLOSED')
    });
    [
        'binaryType',
        'bufferedAmount',
        'extensions',
        'isPaused',
        'protocol',
        'readyState',
        'url'
    ].forEach((property)=>{
        Object.defineProperty(WebSocket.prototype, property, {
            enumerable: true
        });
    });
    [
        'open',
        'error',
        'close',
        'message'
    ].forEach((method)=>{
        Object.defineProperty(WebSocket.prototype, `on${method}`, {
            enumerable: true,
            get () {
                for (const listener of this.listeners(method)){
                    if (listener[kForOnEventAttribute]) return listener[kListener];
                }
                return null;
            },
            set (handler) {
                for (const listener of this.listeners(method)){
                    if (listener[kForOnEventAttribute]) {
                        this.removeListener(method, listener);
                        break;
                    }
                }
                if (typeof handler !== 'function') return;
                this.addEventListener(method, handler, {
                    [kForOnEventAttribute]: true
                });
            }
        });
    });
    WebSocket.prototype.addEventListener = addEventListener;
    WebSocket.prototype.removeEventListener = removeEventListener;
    module.exports = WebSocket;
    function initAsClient(websocket, address, protocols, options) {
        const opts = {
            protocolVersion: protocolVersions[1],
            maxPayload: 100 * 1024 * 1024,
            skipUTF8Validation: false,
            perMessageDeflate: true,
            followRedirects: false,
            maxRedirects: 10,
            ...options,
            createConnection: undefined,
            socketPath: undefined,
            hostname: undefined,
            protocol: undefined,
            timeout: undefined,
            method: 'GET',
            host: undefined,
            path: undefined,
            port: undefined
        };
        if (!protocolVersions.includes(opts.protocolVersion)) {
            throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} ` + `(supported versions: ${protocolVersions.join(', ')})`);
        }
        let parsedUrl;
        if (address instanceof URL) {
            parsedUrl = address;
        } else {
            try {
                parsedUrl = new URL(address);
            } catch (e) {
                throw new SyntaxError(`Invalid URL: ${address}`);
            }
        }
        if (parsedUrl.protocol === 'http:') {
            parsedUrl.protocol = 'ws:';
        } else if (parsedUrl.protocol === 'https:') {
            parsedUrl.protocol = 'wss:';
        }
        websocket._url = parsedUrl.href;
        const isSecure = parsedUrl.protocol === 'wss:';
        const isIpcUrl = parsedUrl.protocol === 'ws+unix:';
        let invalidUrlMessage;
        if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {
            invalidUrlMessage = 'The URL\'s protocol must be one of "ws:", "wss:", ' + '"http:", "https", or "ws+unix:"';
        } else if (isIpcUrl && !parsedUrl.pathname) {
            invalidUrlMessage = "The URL's pathname is empty";
        } else if (parsedUrl.hash) {
            invalidUrlMessage = 'The URL contains a fragment identifier';
        }
        if (invalidUrlMessage) {
            const err = new SyntaxError(invalidUrlMessage);
            if (websocket._redirects === 0) {
                throw err;
            } else {
                emitErrorAndClose(websocket, err);
                return;
            }
        }
        const defaultPort = isSecure ? 443 : 80;
        const key = randomBytes(16).toString('base64');
        const request = isSecure ? https.request : http.request;
        const protocolSet = new Set();
        let perMessageDeflate;
        opts.createConnection = isSecure ? tlsConnect : netConnect;
        opts.defaultPort = opts.defaultPort || defaultPort;
        opts.port = parsedUrl.port || defaultPort;
        opts.host = parsedUrl.hostname.startsWith('[') ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
        opts.headers = {
            ...opts.headers,
            'Sec-WebSocket-Version': opts.protocolVersion,
            'Sec-WebSocket-Key': key,
            Connection: 'Upgrade',
            Upgrade: 'websocket'
        };
        opts.path = parsedUrl.pathname + parsedUrl.search;
        opts.timeout = opts.handshakeTimeout;
        if (opts.perMessageDeflate) {
            perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
            opts.headers['Sec-WebSocket-Extensions'] = format({
                [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
            });
        }
        if (protocols.length) {
            for (const protocol of protocols){
                if (typeof protocol !== 'string' || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
                    throw new SyntaxError('An invalid or duplicated subprotocol was specified');
                }
                protocolSet.add(protocol);
            }
            opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');
        }
        if (opts.origin) {
            if (opts.protocolVersion < 13) {
                opts.headers['Sec-WebSocket-Origin'] = opts.origin;
            } else {
                opts.headers.Origin = opts.origin;
            }
        }
        if (parsedUrl.username || parsedUrl.password) {
            opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
        }
        if (isIpcUrl) {
            const parts = opts.path.split(':');
            opts.socketPath = parts[0];
            opts.path = parts[1];
        }
        let req;
        if (opts.followRedirects) {
            if (websocket._redirects === 0) {
                websocket._originalIpc = isIpcUrl;
                websocket._originalSecure = isSecure;
                websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
                const headers = options && options.headers;
                options = {
                    ...options,
                    headers: {}
                };
                if (headers) {
                    for (const [key, value] of Object.entries(headers)){
                        options.headers[key.toLowerCase()] = value;
                    }
                }
            } else if (websocket.listenerCount('redirect') === 0) {
                const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
                if (!isSameHost || websocket._originalSecure && !isSecure) {
                    delete opts.headers.authorization;
                    delete opts.headers.cookie;
                    if (!isSameHost) delete opts.headers.host;
                    opts.auth = undefined;
                }
            }
            if (opts.auth && !options.headers.authorization) {
                options.headers.authorization = 'Basic ' + Buffer.from(opts.auth).toString('base64');
            }
            req = websocket._req = request(opts);
            if (websocket._redirects) {
                websocket.emit('redirect', websocket.url, req);
            }
        } else {
            req = websocket._req = request(opts);
        }
        if (opts.timeout) {
            req.on('timeout', ()=>{
                abortHandshake(websocket, req, 'Opening handshake has timed out');
            });
        }
        req.on('error', (err)=>{
            if (req === null || req[kAborted]) return;
            req = websocket._req = null;
            emitErrorAndClose(websocket, err);
        });
        req.on('response', (res)=>{
            const location = res.headers.location;
            const statusCode = res.statusCode;
            if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
                if (++websocket._redirects > opts.maxRedirects) {
                    abortHandshake(websocket, req, 'Maximum redirects exceeded');
                    return;
                }
                req.abort();
                let addr;
                try {
                    addr = new URL(location, address);
                } catch (e) {
                    const err = new SyntaxError(`Invalid URL: ${location}`);
                    emitErrorAndClose(websocket, err);
                    return;
                }
                initAsClient(websocket, addr, protocols, options);
            } else if (!websocket.emit('unexpected-response', req, res)) {
                abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
            }
        });
        req.on('upgrade', (res, socket, head)=>{
            websocket.emit('upgrade', res);
            if (websocket.readyState !== WebSocket.CONNECTING) return;
            req = websocket._req = null;
            if (res.headers.upgrade.toLowerCase() !== 'websocket') {
                abortHandshake(websocket, socket, 'Invalid Upgrade header');
                return;
            }
            const digest = createHash('sha1').update(key + GUID).digest('base64');
            if (res.headers['sec-websocket-accept'] !== digest) {
                abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
                return;
            }
            const serverProt = res.headers['sec-websocket-protocol'];
            let protError;
            if (serverProt !== undefined) {
                if (!protocolSet.size) {
                    protError = 'Server sent a subprotocol but none was requested';
                } else if (!protocolSet.has(serverProt)) {
                    protError = 'Server sent an invalid subprotocol';
                }
            } else if (protocolSet.size) {
                protError = 'Server sent no subprotocol';
            }
            if (protError) {
                abortHandshake(websocket, socket, protError);
                return;
            }
            if (serverProt) websocket._protocol = serverProt;
            const secWebSocketExtensions = res.headers['sec-websocket-extensions'];
            if (secWebSocketExtensions !== undefined) {
                if (!perMessageDeflate) {
                    const message = 'Server sent a Sec-WebSocket-Extensions header but no extension ' + 'was requested';
                    abortHandshake(websocket, socket, message);
                    return;
                }
                let extensions;
                try {
                    extensions = parse(secWebSocketExtensions);
                } catch (err) {
                    const message = 'Invalid Sec-WebSocket-Extensions header';
                    abortHandshake(websocket, socket, message);
                    return;
                }
                const extensionNames = Object.keys(extensions);
                if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
                    const message = 'Server indicated an extension that was not requested';
                    abortHandshake(websocket, socket, message);
                    return;
                }
                try {
                    perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
                } catch (err) {
                    const message = 'Invalid Sec-WebSocket-Extensions header';
                    abortHandshake(websocket, socket, message);
                    return;
                }
                websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
            websocket.setSocket(socket, head, {
                generateMask: opts.generateMask,
                maxPayload: opts.maxPayload,
                skipUTF8Validation: opts.skipUTF8Validation
            });
        });
        if (opts.finishRequest) {
            opts.finishRequest(req, websocket);
        } else {
            req.end();
        }
    }
    function emitErrorAndClose(websocket, err) {
        websocket._readyState = WebSocket.CLOSING;
        websocket.emit('error', err);
        websocket.emitClose();
    }
    function netConnect(options) {
        options.path = options.socketPath;
        return net.connect(options);
    }
    function tlsConnect(options) {
        options.path = undefined;
        if (!options.servername && options.servername !== '') {
            options.servername = net.isIP(options.host) ? '' : options.host;
        }
        return tls.connect(options);
    }
    function abortHandshake(websocket, stream, message) {
        websocket._readyState = WebSocket.CLOSING;
        const err = new Error(message);
        Error.captureStackTrace(err, abortHandshake);
        if (stream.setHeader) {
            stream[kAborted] = true;
            stream.abort();
            if (stream.socket && !stream.socket.destroyed) {
                stream.socket.destroy();
            }
            process.nextTick(emitErrorAndClose, websocket, err);
        } else {
            stream.destroy(err);
            stream.once('error', websocket.emit.bind(websocket, 'error'));
            stream.once('close', websocket.emitClose.bind(websocket));
        }
    }
    function sendAfterClose(websocket, data, cb) {
        if (data) {
            const length = toBuffer(data).length;
            if (websocket._socket) websocket._sender._bufferedBytes += length;
            else websocket._bufferedAmount += length;
        }
        if (cb) {
            const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} ` + `(${readyStates[websocket.readyState]})`);
            process.nextTick(cb, err);
        }
    }
    function receiverOnConclude(code, reason) {
        const websocket = this[kWebSocket];
        websocket._closeFrameReceived = true;
        websocket._closeMessage = reason;
        websocket._closeCode = code;
        if (websocket._socket[kWebSocket] === undefined) return;
        websocket._socket.removeListener('data', socketOnData);
        process.nextTick(resume, websocket._socket);
        if (code === 1005) websocket.close();
        else websocket.close(code, reason);
    }
    function receiverOnDrain() {
        const websocket = this[kWebSocket];
        if (!websocket.isPaused) websocket._socket.resume();
    }
    function receiverOnError(err) {
        const websocket = this[kWebSocket];
        if (websocket._socket[kWebSocket] !== undefined) {
            websocket._socket.removeListener('data', socketOnData);
            process.nextTick(resume, websocket._socket);
            websocket.close(err[kStatusCode]);
        }
        websocket.emit('error', err);
    }
    function receiverOnFinish() {
        this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data, isBinary) {
        this[kWebSocket].emit('message', data, isBinary);
    }
    function receiverOnPing(data) {
        const websocket = this[kWebSocket];
        websocket.pong(data, !websocket._isServer, NOOP);
        websocket.emit('ping', data);
    }
    function receiverOnPong(data) {
        this[kWebSocket].emit('pong', data);
    }
    function resume(stream) {
        stream.resume();
    }
    function socketOnClose() {
        const websocket = this[kWebSocket];
        this.removeListener('close', socketOnClose);
        this.removeListener('data', socketOnData);
        this.removeListener('end', socketOnEnd);
        websocket._readyState = WebSocket.CLOSING;
        let chunk;
        if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
            websocket._receiver.write(chunk);
        }
        websocket._receiver.end();
        this[kWebSocket] = undefined;
        clearTimeout(websocket._closeTimer);
        if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
            websocket.emitClose();
        } else {
            websocket._receiver.on('error', receiverOnFinish);
            websocket._receiver.on('finish', receiverOnFinish);
        }
    }
    function socketOnData(chunk) {
        if (!this[kWebSocket]._receiver.write(chunk)) {
            this.pause();
        }
    }
    function socketOnEnd() {
        const websocket = this[kWebSocket];
        websocket._readyState = WebSocket.CLOSING;
        websocket._receiver.end();
        this.end();
    }
    function socketOnError() {
        const websocket = this[kWebSocket];
        this.removeListener('error', socketOnError);
        this.on('error', NOOP);
        if (websocket) {
            websocket._readyState = WebSocket.CLOSING;
            this.destroy();
        }
    }
}
,
"e4d98328":/*!
 * depd
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    module.exports = callSiteToString;
    function callSiteFileLocation(callSite) {
        var fileName;
        var fileLocation = '';
        if (callSite.isNative()) {
            fileLocation = 'native';
        } else if (callSite.isEval()) {
            fileName = callSite.getScriptNameOrSourceURL();
            if (!fileName) {
                fileLocation = callSite.getEvalOrigin();
            }
        } else {
            fileName = callSite.getFileName();
        }
        if (fileName) {
            fileLocation += fileName;
            var lineNumber = callSite.getLineNumber();
            if (lineNumber != null) {
                fileLocation += ':' + lineNumber;
                var columnNumber = callSite.getColumnNumber();
                if (columnNumber) {
                    fileLocation += ':' + columnNumber;
                }
            }
        }
        return fileLocation || 'unknown source';
    }
    function callSiteToString(callSite) {
        var addSuffix = true;
        var fileLocation = callSiteFileLocation(callSite);
        var functionName = callSite.getFunctionName();
        var isConstructor = callSite.isConstructor();
        var isMethodCall = !(callSite.isToplevel() || isConstructor);
        var line = '';
        if (isMethodCall) {
            var methodName = callSite.getMethodName();
            var typeName = getConstructorName(callSite);
            if (functionName) {
                if (typeName && functionName.indexOf(typeName) !== 0) {
                    line += typeName + '.';
                }
                line += functionName;
                if (methodName && functionName.lastIndexOf('.' + methodName) !== functionName.length - methodName.length - 1) {
                    line += ' [as ' + methodName + ']';
                }
            } else {
                line += typeName + '.' + (methodName || '<anonymous>');
            }
        } else if (isConstructor) {
            line += 'new ' + (functionName || '<anonymous>');
        } else if (functionName) {
            line += functionName;
        } else {
            addSuffix = false;
            line += fileLocation;
        }
        if (addSuffix) {
            line += ' (' + fileLocation + ')';
        }
        return line;
    }
    function getConstructorName(obj) {
        var receiver = obj.receiver;
        return receiver.constructor && receiver.constructor.name || null;
    }
}
,
"e60815f7":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "convertEnforceToPriority", ()=>convertEnforceToPriority);
    module.o(exports, "getContentValue", ()=>getContentValue);
    module.o(exports, "isString", ()=>isString);
    module.o(exports, "isObject", ()=>isObject);
    module.o(exports, "customParseQueryString", ()=>customParseQueryString);
    module.o(exports, "VITE_PLUGIN_DEFAULT_MODULE_TYPE", ()=>VITE_PLUGIN_DEFAULT_MODULE_TYPE);
    module.o(exports, "CSS_LANGS_RES", ()=>CSS_LANGS_RES);
    module.o(exports, "JS_LANGS_RES", ()=>JS_LANGS_RES);
    module.o(exports, "DEFAULT_FILTERS", ()=>DEFAULT_FILTERS);
    module.o(exports, "FARM_CSS_MODULES_SUFFIX", ()=>FARM_CSS_MODULES_SUFFIX);
    module.o(exports, "stringifyQuery", ()=>stringifyQuery);
    module.o(exports, "formatId", ()=>formatId);
    module.o(exports, "isStartAdapterVirtualModule", ()=>isStartAdapterVirtualModule);
    module.o(exports, "isStartsWithSlash", ()=>isStartsWithSlash);
    module.o(exports, "addAdapterVirtualModuleFlag", ()=>addAdapterVirtualModuleFlag);
    module.o(exports, "normalizeAdapterVirtualModule", ()=>normalizeAdapterVirtualModule);
    module.o(exports, "normalizePath", ()=>normalizePath);
    module.o(exports, "removeQuery", ()=>removeQuery);
    module.o(exports, "revertNormalizePath", ()=>revertNormalizePath);
    module.o(exports, "getCssModuleType", ()=>getCssModuleType);
    module.o(exports, "getJsModuleType", ()=>getJsModuleType);
    module.o(exports, "formatLoadModuleType", ()=>formatLoadModuleType);
    module.o(exports, "formatTransformModuleType", ()=>formatTransformModuleType);
    module.o(exports, "encodeStr", ()=>encodeStr);
    module.o(exports, "decodeStr", ()=>decodeStr);
    module.o(exports, "deleteUndefinedPropertyDeeply", ()=>deleteUndefinedPropertyDeeply);
    module.o(exports, "throwIncompatibleError", ()=>throwIncompatibleError);
    module.o(exports, "transformResourceInfo2RollupRenderedChunk", ()=>transformResourceInfo2RollupRenderedChunk);
    module.o(exports, "transformResourceInfo2RollupResource", ()=>transformResourceInfo2RollupResource);
    module.o(exports, "transformRollupResource2FarmResource", ()=>transformRollupResource2FarmResource);
    module.o(exports, "transformFarmConfigToRollupNormalizedOutputOptions", ()=>transformFarmConfigToRollupNormalizedOutputOptions);
    module.o(exports, "transformFarmConfigToRollupNormalizedInputOptions", ()=>transformFarmConfigToRollupNormalizedInputOptions);
    module.o(exports, "normalizeFilterPath", ()=>normalizeFilterPath);
    var _f_node_path = module.i(farmRequire('node:path'));
    var _f_node_querystring = module.w(farmRequire('node:querystring'));
    var querystring = _f_node_querystring;
    var _f_fs_extra = module.i(farmRequire("77e37188"));
    var _f_constants = farmRequire("28e36a2d");
    function convertEnforceToPriority(value) {
        const defaultPriority = 100;
        const enforceToPriority = {
            pre: 101,
            post: 98
        };
        return enforceToPriority[value] !== undefined ? enforceToPriority[value] : defaultPriority;
    }
    function getContentValue(content) {
        return encodeStr(typeof content === 'string' ? content : content.code);
    }
    function isString(variable) {
        return typeof variable === 'string';
    }
    function isObject(variable) {
        return typeof variable === 'object' && variable !== null;
    }
    function customParseQueryString(url) {
        if (!url) {
            return [];
        }
        const queryString = url.split('?')[1];
        const parsedParams = querystring.parse(queryString);
        const paramsArray = [];
        for(const key in parsedParams){
            paramsArray.push([
                key,
                parsedParams[key]
            ]);
        }
        return paramsArray;
    }
    var VITE_PLUGIN_DEFAULT_MODULE_TYPE = 'VITE_PLUGIN_DEFAULT_MODULE_TYPE';
    var CSS_LANGS_RES = [
        [
            /\.(less)(?:$|\?)/,
            'less'
        ],
        [
            /\.(scss|sass)(?:$|\?)/,
            'sass'
        ],
        [
            /\.(styl|stylus)(?:$|\?)/,
            'stylus'
        ],
        [
            /\.(css)(?:$|\?)/,
            'css'
        ]
    ];
    var JS_LANGS_RES = [
        [
            /\.(js|mjs|cjs|)(?:$|\?)/,
            'js'
        ],
        [
            /\.(jsx)(?:$|\?)/,
            'jsx'
        ],
        [
            /\.(ts|cts|mts)(?:$|\?)/,
            'ts'
        ],
        [
            /\.(tsx)(?:$|\?)/,
            'tsx'
        ]
    ];
    var DEFAULT_FILTERS = [
        '!node_modules'
    ];
    var FARM_CSS_MODULES_SUFFIX = /(?:\?|&)farm_css_modules/;
    var stringifyQuery = (query)=>{
        if (!query.length) {
            return '';
        }
        let queryStr = '';
        for (const [key, value] of query){
            queryStr += `${key}${value ? `=${value}` : ''}&`;
        }
        return `${queryStr.slice(0, -1)}`;
    };
    function formatId(id, query) {
        if (isStartAdapterVirtualModule(id)) {
            id = id?.replace(_f_constants.VITE_ADAPTER_VIRTUAL_MODULE, '');
        }
        if (!query.length) {
            return id;
        }
        return `${id}?${stringifyQuery(query)}`;
    }
    function isStartAdapterVirtualModule(id) {
        return id?.startsWith(_f_constants.VITE_ADAPTER_VIRTUAL_MODULE);
    }
    function isStartsWithSlash(str) {
        return str?.startsWith('/');
    }
    function addAdapterVirtualModuleFlag(id) {
        return _f_constants.VITE_ADAPTER_VIRTUAL_MODULE + id;
    }
    function normalizeAdapterVirtualModule(id) {
        const path = removeQuery(id);
        if (isStartsWithSlash(path) && !module.f(_f_fs_extra).pathExistsSync(path)) return addAdapterVirtualModuleFlag(id);
        return id;
    }
    function normalizePath(p) {
        return module.f(_f_node_path).posix.normalize(process.platform === 'win32' ? p.replace(/\\/g, '/') : p);
    }
    var removeQuery = (path)=>{
        const queryIndex = path.indexOf('?');
        if (queryIndex !== -1) {
            return path.slice(0, queryIndex);
        }
        return revertNormalizePath(path.concat(''));
    };
    function revertNormalizePath(p) {
        return process.platform === 'win32' ? p.replace(/\//g, '\\') : p;
    }
    function getCssModuleType(id) {
        for (const [reg, lang] of CSS_LANGS_RES){
            if (reg.test(id)) {
                return lang;
            }
        }
        return null;
    }
    function getJsModuleType(id) {
        for (const [reg, lang] of JS_LANGS_RES){
            if (reg.test(id)) {
                return lang;
            }
        }
        return null;
    }
    function formatLoadModuleType(id) {
        const cssModuleType = getCssModuleType(id);
        if (cssModuleType) {
            return cssModuleType;
        }
        const jsModuleType = getJsModuleType(id);
        if (jsModuleType) {
            return jsModuleType;
        }
        return 'js';
    }
    function formatTransformModuleType(id) {
        return formatLoadModuleType(id);
    }
    function encodeStr(str) {
        return str.replace(/\0/g, '\\0');
    }
    function decodeStr(str) {
        return str.replace(/\\0/g, '\0');
    }
    function deleteUndefinedPropertyDeeply(obj) {
        if (typeof obj !== 'object') {
            return;
        }
        for(const key in obj){
            if (!Object.prototype.hasOwnProperty.call(obj, key)) {
                continue;
            }
            if (Array.isArray(obj[key])) {
                obj[key] = obj[key].filter((item)=>item !== undefined);
            } else if (obj[key] === undefined) {
                delete obj[key];
            } else if (typeof obj[key] === 'object') {
                deleteUndefinedPropertyDeeply(obj[key]);
            }
        }
    }
    function throwIncompatibleError(pluginName, readingObject, allowedKeys, key) {
        throw new Error(`Vite plugin '${pluginName}' is not compatible with Farm for now. Because it uses ${readingObject}['${String(key)}'] which is not supported by Farm. Current supported keys are: ${allowedKeys.join(',')}`);
    }
    function transformResourceInfo2RollupRenderedChunk(info) {
        const { modules, moduleIds, name, data } = info;
        const { dynamicImports, importedBindings, imports, exports: exports1, isDynamicEntry, isEntry, isImplicitEntry } = data;
        return {
            dynamicImports,
            fileName: name,
            implicitlyLoadedBefore: [],
            importedBindings,
            imports,
            modules: Object.entries(modules).reduce((result, [key, val])=>({
                    ...result,
                    [key]: {
                        code: val.renderedContent,
                        renderedLength: val.renderedLength,
                        originalLength: val.originalLength,
                        removedExports: [],
                        renderedExports: []
                    }
                }), {}),
            referencedFiles: [],
            exports: exports1,
            facadeModuleId: null,
            isDynamicEntry,
            isEntry,
            isImplicitEntry,
            moduleIds,
            name,
            type: 'chunk'
        };
    }
    function transformResourceInfo2RollupResource(resource) {
        if (resource.info && resource.resourceType === 'js') {
            const source = Buffer.from(resource.bytes).toString('utf-8');
            return {
                ...transformResourceInfo2RollupRenderedChunk(resource.info),
                type: 'chunk',
                code: source,
                name: resource.name,
                map: undefined,
                sourcemapFileName: null,
                preliminaryFileName: resource.origin.value
            };
        } else {
            return {
                fileName: resource.name,
                name: resource.name,
                needsCodeReference: false,
                source: Uint8Array.from(resource.bytes),
                type: 'asset'
            };
        }
    }
    function transformRollupResource2FarmResource(chunk, originResource) {
        if (chunk.type === 'chunk') {
            return {
                ...originResource,
                bytes: Array.from(Buffer.from(chunk.code)),
                emitted: originResource.emitted,
                name: chunk.name
            };
        } else {
            return {
                bytes: Array.from(chunk.source),
                emitted: originResource.emitted,
                name: chunk.name,
                origin: originResource.origin,
                resourceType: originResource.resourceType
            };
        }
    }
    const notSupport = (method)=>()=>{
            console.warn(`${method} not support`);
        };
    const noop = ()=>void 0;
    function transformFarmFormatToRollupFormat(config) {
        if (config.format === 'esm') {
            return 'es';
        } else if (config.format === 'cjs') {
            if (config.targetEnv === 'node') return 'cjs';
            return 'amd';
        }
    }
    function transformFarmConfigToRollupNormalizedOutputOptions(config) {
        return {
            amd: {
                autoId: false,
                define: 'define',
                forceJsExtensionForImports: false
            },
            assetFileNames: config.output.assetsFilename,
            chunkFileNames: config.output.filename,
            compact: Boolean(config.minify),
            dir: config.output.path,
            dynamicImportInCjs: true,
            entryFileNames: config.output.entryFilename,
            esModule: 'if-default-prop',
            experimentalMinChunkSize: config?.partialBundling?.targetMinSize || 1,
            exports: 'auto',
            extend: false,
            externalImportAssertions: false,
            externalLiveBindings: true,
            format: transformFarmFormatToRollupFormat(config.output),
            freeze: false,
            generatedCode: {
                arrowFunctions: false,
                constBindings: false,
                objectShorthand: false,
                reservedNamesAsProps: true,
                symbols: false
            },
            globals: {},
            hoistTransitiveImports: true,
            indent: true,
            inlineDynamicImports: false,
            manualChunks: {},
            minifyInternalExports: true,
            noConflict: false,
            paths: {},
            plugins: [],
            preserveModules: false,
            sourcemap: Boolean(config.sourcemap),
            sourcemapExcludeSources: false,
            strict: true,
            systemNullSetters: true,
            validate: false,
            banner: notSupport('banner'),
            footer: notSupport('footer'),
            interop: notSupport('interop'),
            outro: notSupport('outro'),
            intro: notSupport('intro'),
            sanitizeFileName: notSupport('sanitizeFileName'),
            sourcemapIgnoreList: notSupport('sourcemapIgnoreList'),
            dynamicImportFunction: undefined,
            experimentalDeepDynamicChunkOptimization: false,
            file: undefined,
            name: undefined,
            namespaceToStringTag: false,
            preferConst: false,
            preserveModulesRoot: undefined,
            sourcemapBaseUrl: undefined,
            sourcemapFile: undefined,
            sourcemapFileNames: undefined,
            sourcemapPathTransform: undefined
        };
    }
    function transformFarmConfigToRollupNormalizedInputOptions(config) {
        return {
            context: 'undefined',
            experimentalCacheExpiry: 10,
            experimentalLogSideEffects: false,
            input: config.input,
            logLevel: 'info',
            makeAbsoluteExternalsRelative: 'ifRelativeSource',
            maxParallelFileOps: 20,
            perf: false,
            plugins: [],
            preserveEntrySignatures: 'exports-only',
            preserveSymlinks: false,
            shimMissingExports: false,
            strictDeprecations: false,
            treeshake: config.treeShaking && {
                moduleSideEffects: ()=>false,
                annotations: true,
                correctVarValueBeforeDeclaration: false,
                manualPureFunctions: [],
                propertyReadSideEffects: true,
                tryCatchDeoptimization: true,
                unknownGlobalSideEffects: true
            },
            acorn: undefined,
            acornInjectPlugins: undefined,
            cache: undefined,
            external: undefined,
            inlineDynamicImports: undefined,
            manualChunks: undefined,
            maxParallelFileReads: undefined,
            moduleContext: undefined,
            onLog: noop,
            onwarn: noop,
            preserveModules: undefined
        };
    }
    function normalizeFilterPath(path) {
        if (process.platform === 'win32') {
            return compatibleWin32Path(path);
        }
        return path;
    }
    function compatibleWin32Path(path) {
        return path.replaceAll('/', '\\\\');
    }
}
,
"e6b6986c":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const path = global.nodeRequire('path', true);
    const which = farmRequire("9996a2b2", true);
    const getPathKey = farmRequire("ba69a156", true);
    function resolveCommandAttempt(parsed, withoutPathExt) {
        const env = parsed.options.env || process.env;
        const cwd = process.cwd();
        const hasCustomCwd = parsed.options.cwd != null;
        const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;
        if (shouldSwitchCwd) {
            try {
                process.chdir(parsed.options.cwd);
            } catch (err) {}
        }
        let resolved;
        try {
            resolved = which.sync(parsed.command, {
                path: env[getPathKey({
                    env
                })],
                pathExt: withoutPathExt ? path.delimiter : undefined
            });
        } catch (e) {} finally{
            if (shouldSwitchCwd) {
                process.chdir(cwd);
            }
        }
        if (resolved) {
            resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : '', resolved);
        }
        return resolved;
    }
    function resolveCommand(parsed) {
        return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
    }
    module.exports = resolveCommand;
}
,
"e7253e09":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "isStream", ()=>isStream);
    module.o(exports, "isWritableStream", ()=>isWritableStream);
    function isStream(stream) {
        return stream !== null && typeof stream === 'object' && typeof stream.pipe === 'function';
    }
    function isWritableStream(stream) {
        return isStream(stream) && stream.writable !== false && typeof stream._write === 'function' && typeof stream._writableState === 'object';
    }
}
,
"e78d61ad":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    var crypto = global.nodeRequire('crypto', true);
    function bufferEqual(a, b) {
        if (a.length !== b.length) {
            return false;
        }
        if (crypto.timingSafeEqual) {
            return crypto.timingSafeEqual(a, b);
        }
        for(var i = 0; i < a.length; i++){
            if (a[i] !== b[i]) {
                return false;
            }
        }
        return true;
    }
    function timeSafeCompare(a, b) {
        var sa = String(a);
        var sb = String(b);
        var key = crypto.pseudoRandomBytes(32);
        var ah = crypto.createHmac('sha256', key).update(sa).digest();
        var bh = crypto.createHmac('sha256', key).update(sb).digest();
        return bufferEqual(ah, bh) && a === b;
    }
    module.exports = timeSafeCompare;
}
,
"e7a96878":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const { tokenChars } = farmRequire("9887cd18", true);
    function push(dest, name, elem) {
        if (dest[name] === undefined) dest[name] = [
            elem
        ];
        else dest[name].push(elem);
    }
    function parse(header) {
        const offers = Object.create(null);
        let params = Object.create(null);
        let mustUnescape = false;
        let isEscaping = false;
        let inQuotes = false;
        let extensionName;
        let paramName;
        let start = -1;
        let code = -1;
        let end = -1;
        let i = 0;
        for(; i < header.length; i++){
            code = header.charCodeAt(i);
            if (extensionName === undefined) {
                if (end === -1 && tokenChars[code] === 1) {
                    if (start === -1) start = i;
                } else if (i !== 0 && (code === 0x20 || code === 0x09)) {
                    if (end === -1 && start !== -1) end = i;
                } else if (code === 0x3b || code === 0x2c) {
                    if (start === -1) {
                        throw new SyntaxError(`Unexpected character at index ${i}`);
                    }
                    if (end === -1) end = i;
                    const name = header.slice(start, end);
                    if (code === 0x2c) {
                        push(offers, name, params);
                        params = Object.create(null);
                    } else {
                        extensionName = name;
                    }
                    start = end = -1;
                } else {
                    throw new SyntaxError(`Unexpected character at index ${i}`);
                }
            } else if (paramName === undefined) {
                if (end === -1 && tokenChars[code] === 1) {
                    if (start === -1) start = i;
                } else if (code === 0x20 || code === 0x09) {
                    if (end === -1 && start !== -1) end = i;
                } else if (code === 0x3b || code === 0x2c) {
                    if (start === -1) {
                        throw new SyntaxError(`Unexpected character at index ${i}`);
                    }
                    if (end === -1) end = i;
                    push(params, header.slice(start, end), true);
                    if (code === 0x2c) {
                        push(offers, extensionName, params);
                        params = Object.create(null);
                        extensionName = undefined;
                    }
                    start = end = -1;
                } else if (code === 0x3d && start !== -1 && end === -1) {
                    paramName = header.slice(start, i);
                    start = end = -1;
                } else {
                    throw new SyntaxError(`Unexpected character at index ${i}`);
                }
            } else {
                if (isEscaping) {
                    if (tokenChars[code] !== 1) {
                        throw new SyntaxError(`Unexpected character at index ${i}`);
                    }
                    if (start === -1) start = i;
                    else if (!mustUnescape) mustUnescape = true;
                    isEscaping = false;
                } else if (inQuotes) {
                    if (tokenChars[code] === 1) {
                        if (start === -1) start = i;
                    } else if (code === 0x22 && start !== -1) {
                        inQuotes = false;
                        end = i;
                    } else if (code === 0x5c) {
                        isEscaping = true;
                    } else {
                        throw new SyntaxError(`Unexpected character at index ${i}`);
                    }
                } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
                    inQuotes = true;
                } else if (end === -1 && tokenChars[code] === 1) {
                    if (start === -1) start = i;
                } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
                    if (end === -1) end = i;
                } else if (code === 0x3b || code === 0x2c) {
                    if (start === -1) {
                        throw new SyntaxError(`Unexpected character at index ${i}`);
                    }
                    if (end === -1) end = i;
                    let value = header.slice(start, end);
                    if (mustUnescape) {
                        value = value.replace(/\\/g, '');
                        mustUnescape = false;
                    }
                    push(params, paramName, value);
                    if (code === 0x2c) {
                        push(offers, extensionName, params);
                        params = Object.create(null);
                        extensionName = undefined;
                    }
                    paramName = undefined;
                    start = end = -1;
                } else {
                    throw new SyntaxError(`Unexpected character at index ${i}`);
                }
            }
        }
        if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {
            throw new SyntaxError('Unexpected end of input');
        }
        if (end === -1) end = i;
        const token = header.slice(start, end);
        if (extensionName === undefined) {
            push(offers, token, params);
        } else {
            if (paramName === undefined) {
                push(params, token, true);
            } else if (mustUnescape) {
                push(params, paramName, token.replace(/\\/g, ''));
            } else {
                push(params, paramName, token);
            }
            push(offers, extensionName, params);
        }
        return offers;
    }
    function format(extensions) {
        return Object.keys(extensions).map((extension)=>{
            let configurations = extensions[extension];
            if (!Array.isArray(configurations)) configurations = [
                configurations
            ];
            return configurations.map((params)=>{
                return [
                    extension
                ].concat(Object.keys(params).map((k)=>{
                    let values = params[k];
                    if (!Array.isArray(values)) values = [
                        values
                    ];
                    return values.map((v)=>v === true ? k : `${k}=${v}`).join('; ');
                })).join('; ');
            }).join(', ');
        }).join(', ');
    }
    module.exports = {
        format,
        parse
    };
}
,
"e7d04bd9":/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ function  (module, exports, farmRequire, farmDynamicRequire) {
    var buffer = global.nodeRequire('buffer', true);
    var Buffer = buffer.Buffer;
    function copyProps(src, dst) {
        for(var key in src){
            dst[key] = src[key];
        }
    }
    if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
        module.exports = buffer;
    } else {
        copyProps(buffer, exports);
        exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer.prototype);
    copyProps(Buffer, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
        if (typeof arg === 'number') {
            throw new TypeError('Argument must not be a number');
        }
        return Buffer(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
        if (typeof size !== 'number') {
            throw new TypeError('Argument must be a number');
        }
        var buf = Buffer(size);
        if (fill !== undefined) {
            if (typeof encoding === 'string') {
                buf.fill(fill, encoding);
            } else {
                buf.fill(fill);
            }
        } else {
            buf.fill(0);
        }
        return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
        if (typeof size !== 'number') {
            throw new TypeError('Argument must be a number');
        }
        return Buffer(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
        if (typeof size !== 'number') {
            throw new TypeError('Argument must be a number');
        }
        return buffer.SlowBuffer(size);
    };
}
,
"e82dd834":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "default", ()=>pathKey);
    function pathKey(options = {}) {
        const { env = process.env, platform = process.platform } = options;
        if (platform !== 'win32') {
            return 'PATH';
        }
        return Object.keys(env).reverse().find((key)=>key.toUpperCase() === 'PATH') || 'Path';
    }
}
,
"ea5249cf":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    module.exports = /^#!(.*)/;
}
,
"eac2581d":function  (module, exports, farmRequire, farmDynamicRequire) {
    var common = exports, url = global.nodeRequire('url', true), extend = global.nodeRequire('util', true)._extend, required = farmRequire("a1439f88", true);
    var upgradeHeader = /(^|,)\s*upgrade\s*($|,)/i, isSSL = /^https|wss/;
    common.isSSL = isSSL;
    common.setupOutgoing = function(outgoing, options, req, forward) {
        outgoing.port = options[forward || 'target'].port || (isSSL.test(options[forward || 'target'].protocol) ? 443 : 80);
        [
            'host',
            'hostname',
            'socketPath',
            'pfx',
            'key',
            'passphrase',
            'cert',
            'ca',
            'ciphers',
            'secureProtocol'
        ].forEach(function(e) {
            outgoing[e] = options[forward || 'target'][e];
        });
        outgoing.method = options.method || req.method;
        outgoing.headers = extend({}, req.headers);
        if (options.headers) {
            extend(outgoing.headers, options.headers);
        }
        if (options.auth) {
            outgoing.auth = options.auth;
        }
        if (options.ca) {
            outgoing.ca = options.ca;
        }
        if (isSSL.test(options[forward || 'target'].protocol)) {
            outgoing.rejectUnauthorized = typeof options.secure === "undefined" ? true : options.secure;
        }
        outgoing.agent = options.agent || false;
        outgoing.localAddress = options.localAddress;
        if (!outgoing.agent) {
            outgoing.headers = outgoing.headers || {};
            if (typeof outgoing.headers.connection !== 'string' || !upgradeHeader.test(outgoing.headers.connection)) {
                outgoing.headers.connection = 'close';
            }
        }
        var target = options[forward || 'target'];
        var targetPath = target && options.prependPath !== false ? target.path || '' : '';
        var outgoingPath = !options.toProxy ? url.parse(req.url).path || '' : req.url;
        outgoingPath = !options.ignorePath ? outgoingPath : '';
        outgoing.path = common.urlJoin(targetPath, outgoingPath);
        if (options.changeOrigin) {
            outgoing.headers.host = required(outgoing.port, options[forward || 'target'].protocol) && !hasPort(outgoing.host) ? outgoing.host + ':' + outgoing.port : outgoing.host;
        }
        return outgoing;
    };
    common.setupSocket = function(socket) {
        socket.setTimeout(0);
        socket.setNoDelay(true);
        socket.setKeepAlive(true, 0);
        return socket;
    };
    common.getPort = function(req) {
        var res = req.headers.host ? req.headers.host.match(/:(\d+)/) : '';
        return res ? res[1] : common.hasEncryptedConnection(req) ? '443' : '80';
    };
    common.hasEncryptedConnection = function(req) {
        return Boolean(req.connection.encrypted || req.connection.pair);
    };
    common.urlJoin = function() {
        var args = Array.prototype.slice.call(arguments), lastIndex = args.length - 1, last = args[lastIndex], lastSegs = last.split('?'), retSegs;
        args[lastIndex] = lastSegs.shift();
        retSegs = [
            args.filter(Boolean).join('/').replace(/\/+/g, '/').replace('http:/', 'http://').replace('https:/', 'https://')
        ];
        retSegs.push.apply(retSegs, lastSegs);
        return retSegs.join('?');
    };
    common.rewriteCookieProperty = function rewriteCookieProperty(header, config, property) {
        if (Array.isArray(header)) {
            return header.map(function(headerElement) {
                return rewriteCookieProperty(headerElement, config, property);
            });
        }
        return header.replace(new RegExp("(;\\s*" + property + "=)([^;]+)", 'i'), function(match, prefix, previousValue) {
            var newValue;
            if (previousValue in config) {
                newValue = config[previousValue];
            } else if ('*' in config) {
                newValue = config['*'];
            } else {
                return match;
            }
            if (newValue) {
                return prefix + newValue;
            } else {
                return '';
            }
        });
    };
    function hasPort(host) {
        return !!~host.indexOf(':');
    }
    ;
}
,
"eb010733":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "staticMiddleware", ()=>staticMiddleware);
    var _f_fs = module.i(farmRequire('fs'));
    var _f_path = module.w(farmRequire('path'));
    var _f_koa_static = module.i(farmRequire("c0be1d25"));
    function staticMiddleware(devServerContext) {
        const { config } = devServerContext;
        const staticMiddleware = module.f(_f_koa_static)(config.distDir, {
            extensions: [
                'html'
            ]
        });
        const fallbackMiddleware = async (ctx, next)=>{
            await next();
            if (ctx.status === 404 && !ctx.body) {
                ctx.type = 'html';
                ctx.body = module.f(_f_fs).createReadStream(module.f(_f_path).join(config.distDir, 'index.html'));
            }
        };
        return async (ctx, next)=>{
            if (ctx.status !== 404 || ctx.body) {
                await next();
                return;
            }
            const requestPath = ctx.request?.path;
            let modifiedPath = requestPath;
            if (requestPath) {
                if (config.output.publicPath.startsWith('/')) {
                    modifiedPath = requestPath.substring(config.output.publicPath.length);
                } else {
                    const publicPath = _f_path.relative(module.f(_f_path).join(config.distDir, config.output.publicPath), config.distDir);
                    modifiedPath = requestPath.substring(publicPath.length + 1);
                }
            }
            ctx.request.path = `/${modifiedPath}`;
            try {
                await staticMiddleware(ctx, async ()=>{
                    await fallbackMiddleware(ctx, next);
                });
            } catch (error) {
                devServerContext.logger.error('Static file handling error:', error);
                ctx.status = 500;
            }
        };
    }
}
,
"ec8939b7":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const u = farmRequire("712c2dd4", true).fromCallback;
    const path = global.nodeRequire('path', true);
    const fs = farmRequire("f2e2163e", true);
    const _mkdirs = farmRequire("abdb8a71", true);
    const mkdirs = _mkdirs.mkdirs;
    const mkdirsSync = _mkdirs.mkdirsSync;
    const _symlinkPaths = farmRequire("73492c43", true);
    const symlinkPaths = _symlinkPaths.symlinkPaths;
    const symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
    const _symlinkType = farmRequire("1c7522fd", true);
    const symlinkType = _symlinkType.symlinkType;
    const symlinkTypeSync = _symlinkType.symlinkTypeSync;
    const pathExists = farmRequire("05a93efb", true).pathExists;
    const { areIdentical } = farmRequire("9c9fbd11", true);
    function createSymlink(srcpath, dstpath, type, callback) {
        callback = typeof type === 'function' ? type : callback;
        type = typeof type === 'function' ? false : type;
        fs.lstat(dstpath, (err, stats)=>{
            if (!err && stats.isSymbolicLink()) {
                Promise.all([
                    fs.stat(srcpath),
                    fs.stat(dstpath)
                ]).then(([srcStat, dstStat])=>{
                    if (areIdentical(srcStat, dstStat)) return callback(null);
                    _createSymlink(srcpath, dstpath, type, callback);
                });
            } else _createSymlink(srcpath, dstpath, type, callback);
        });
    }
    function _createSymlink(srcpath, dstpath, type, callback) {
        symlinkPaths(srcpath, dstpath, (err, relative)=>{
            if (err) return callback(err);
            srcpath = relative.toDst;
            symlinkType(relative.toCwd, type, (err, type)=>{
                if (err) return callback(err);
                const dir = path.dirname(dstpath);
                pathExists(dir, (err, dirExists)=>{
                    if (err) return callback(err);
                    if (dirExists) return fs.symlink(srcpath, dstpath, type, callback);
                    mkdirs(dir, (err)=>{
                        if (err) return callback(err);
                        fs.symlink(srcpath, dstpath, type, callback);
                    });
                });
            });
        });
    }
    function createSymlinkSync(srcpath, dstpath, type) {
        let stats;
        try {
            stats = fs.lstatSync(dstpath);
        } catch  {}
        if (stats && stats.isSymbolicLink()) {
            const srcStat = fs.statSync(srcpath);
            const dstStat = fs.statSync(dstpath);
            if (areIdentical(srcStat, dstStat)) return;
        }
        const relative = symlinkPathsSync(srcpath, dstpath);
        srcpath = relative.toDst;
        type = symlinkTypeSync(relative.toCwd, type);
        const dir = path.dirname(dstpath);
        const exists = fs.existsSync(dir);
        if (exists) return fs.symlinkSync(srcpath, dstpath, type);
        mkdirsSync(dir);
        return fs.symlinkSync(srcpath, dstpath, type);
    }
    module.exports = {
        createSymlink: u(createSymlink),
        createSymlinkSync
    };
}
,
"ec975e7c":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const path = global.nodeRequire('path', true);
    const resolveCommand = farmRequire("e6b6986c", true);
    const escape = farmRequire("2e2a91c0", true);
    const readShebang = farmRequire("5ad07f45", true);
    const isWin = process.platform === 'win32';
    const isExecutableRegExp = /\.(?:com|exe)$/i;
    const isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
    function detectShebang(parsed) {
        parsed.file = resolveCommand(parsed);
        const shebang = parsed.file && readShebang(parsed.file);
        if (shebang) {
            parsed.args.unshift(parsed.file);
            parsed.command = shebang;
            return resolveCommand(parsed);
        }
        return parsed.file;
    }
    function parseNonShell(parsed) {
        if (!isWin) {
            return parsed;
        }
        const commandFile = detectShebang(parsed);
        const needsShell = !isExecutableRegExp.test(commandFile);
        if (parsed.options.forceShell || needsShell) {
            const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
            parsed.command = path.normalize(parsed.command);
            parsed.command = escape.command(parsed.command);
            parsed.args = parsed.args.map((arg)=>escape.argument(arg, needsDoubleEscapeMetaChars));
            const shellCommand = [
                parsed.command
            ].concat(parsed.args).join(' ');
            parsed.args = [
                '/d',
                '/s',
                '/c',
                `"${shellCommand}"`
            ];
            parsed.command = process.env.comspec || 'cmd.exe';
            parsed.options.windowsVerbatimArguments = true;
        }
        return parsed;
    }
    function parse(command, args, options) {
        if (args && !Array.isArray(args)) {
            options = args;
            args = null;
        }
        args = args ? args.slice(0) : [];
        options = Object.assign({}, options);
        const parsed = {
            command,
            args,
            options,
            file: undefined,
            original: {
                command,
                args
            }
        };
        return options.shell ? parsed : parseNonShell(parsed);
    }
    module.exports = parse;
}
,
"ecabb81e":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "normalizeStdio", ()=>normalizeStdio);
    const aliases = [
        'stdin',
        'stdout',
        'stderr'
    ];
    const hasAlias = (options)=>aliases.some((alias)=>options[alias] !== undefined);
    var normalizeStdio = (options)=>{
        if (!options) {
            return;
        }
        const { stdio } = options;
        if (stdio === undefined) {
            return aliases.map((alias)=>options[alias]);
        }
        if (hasAlias(options)) {
            throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${aliases.map((alias)=>`\`${alias}\``).join(', ')}`);
        }
        if (typeof stdio === 'string') {
            return stdio;
        }
        if (!Array.isArray(stdio)) {
            throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
        }
        const length = Math.max(stdio.length, aliases.length);
        return Array.from({
            length
        }, (value, index)=>stdio[index]);
    };
}
,
"ecdcd3ff":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "UnknownBrowserError", ()=>UnknownBrowserError);
    module.o(exports, "default", ()=>defaultBrowser);
    var _f_execa = farmRequire("1bdb2cdd");
    const windowsBrowserProgIds = {
        AppXq0fevzme2pys62n3e0fbqa7peapykr8v: {
            name: 'Edge',
            id: 'com.microsoft.edge.old'
        },
        MSEdgeDHTML: {
            name: 'Edge',
            id: 'com.microsoft.edge'
        },
        MSEdgeHTM: {
            name: 'Edge',
            id: 'com.microsoft.edge'
        },
        'IE.HTTP': {
            name: 'Internet Explorer',
            id: 'com.microsoft.ie'
        },
        FirefoxURL: {
            name: 'Firefox',
            id: 'org.mozilla.firefox'
        },
        ChromeHTML: {
            name: 'Chrome',
            id: 'com.google.chrome'
        }
    };
    class UnknownBrowserError extends Error {
    }
    async function defaultBrowser(_execa = _f_execa.execa) {
        const result = await _execa('reg', [
            'QUERY',
            ' HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\Shell\\Associations\\UrlAssociations\\http\\UserChoice',
            '/v',
            'ProgId'
        ]);
        const match = /ProgId\s*REG_SZ\s*(?<id>\S+)/.exec(result.stdout);
        if (!match) {
            throw new UnknownBrowserError(`Cannot find Windows browser in stdout: ${JSON.stringify(result.stdout)}`);
        }
        const { id } = match.groups;
        const browser = windowsBrowserProgIds[id];
        if (!browser) {
            throw new UnknownBrowserError(`Unknown browser ID: ${id}`);
        }
        return browser;
    }
}
,
"ed98161c":function  (module, exports, farmRequire, farmDynamicRequire) {}
,
"ee2469d1":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "resolveFarmPlugins", ()=>resolveFarmPlugins);
    module.o(exports, "resolveAsyncPlugins", ()=>resolveAsyncPlugins);
    module.o(exports, "resolveConfigHook", ()=>resolveConfigHook);
    module.o(exports, "resolveConfigResolvedHook", ()=>resolveConfigResolvedHook);
    module.o(exports, "getSortedPlugins", ()=>getSortedPlugins);
    var _f_index = farmRequire("65ad6846");
    var _f_index1 = farmRequire("3b82e8e5");
    var _f_index2 = farmRequire("7b6ea513");
    var _f_merge = module.i(farmRequire("c074a41a"));
    var _f_index3 = farmRequire("3b82e8e5");
    module._e(exports, _f_index3);
    var _f_index4 = farmRequire("7b6ea513");
    module._e(exports, _f_index4);
    async function resolveFarmPlugins(config) {
        const plugins = config.plugins ?? [];
        if (!plugins.length) {
            return {
                rustPlugins: [],
                jsPlugins: []
            };
        }
        const rustPlugins = [];
        const jsPlugins = [];
        for (const plugin of plugins){
            if (!plugin) {
                continue;
            }
            if (typeof plugin === 'string' || _f_index.isArray(plugin) && typeof plugin[0] === 'string') {
                rustPlugins.push(await _f_index2.rustPluginResolver(plugin, config.root ?? process.cwd()));
            } else if (_f_index.isObject(plugin)) {
                _f_index1.convertPlugin(plugin);
                jsPlugins.push(plugin);
            } else if (_f_index.isArray(plugin)) {
                for (const pluginNestItem of plugin){
                    _f_index1.convertPlugin(pluginNestItem);
                    jsPlugins.push(pluginNestItem);
                }
            } else {
                throw new Error(`plugin ${plugin} is not supported, Please pass the correct plugin type`);
            }
        }
        return {
            rustPlugins,
            jsPlugins
        };
    }
    async function resolveAsyncPlugins(arr) {
        return arr.reduce(async (acc, current)=>{
            const flattenedAcc = await acc;
            if (current instanceof Promise) {
                const resolvedElement = await current;
                return flattenedAcc.concat(resolvedElement);
            } else if (Array.isArray(current)) {
                const flattenedArray = await resolveAsyncPlugins(current);
                return flattenedAcc.concat(flattenedArray);
            } else {
                return flattenedAcc.concat(current);
            }
        }, Promise.resolve([]));
    }
    async function resolveConfigHook(config, plugins) {
        let conf = config;
        const uniqueVitePlugins = new Map();
        for (const p of plugins){
            const pluginName = p.name;
            if (!uniqueVitePlugins.has(pluginName)) {
                uniqueVitePlugins.set(pluginName, p);
            }
        }
        for (const p of uniqueVitePlugins.values()){
            if (p.config) {
                const res = await p.config(conf);
                if (res) {
                    conf = module.f(_f_merge)(conf, res);
                }
            }
        }
        return conf;
    }
    async function resolveConfigResolvedHook(config, plugins) {
        for (const p of plugins){
            if (p.configResolved) {
                await p.configResolved(config);
            }
        }
    }
    function getSortedPlugins(plugins) {
        const DEFAULT_PRIORITY = 100;
        const sortedPlugins = plugins.filter((plugin)=>typeof plugin === 'object' && typeof plugin.priority === 'number').sort((a, b)=>b.priority - a.priority);
        const prePlugins = sortedPlugins.filter((plugin)=>plugin?.priority > DEFAULT_PRIORITY);
        const postPlugins = sortedPlugins.filter((plugin)=>plugin?.priority < DEFAULT_PRIORITY);
        const normalPlugins = plugins.filter((plugin)=>typeof plugin === 'object' && typeof plugin.priority !== 'number' || plugin?.priority === DEFAULT_PRIORITY);
        return [
            ...prePlugins,
            ...normalPlugins,
            ...postPlugins
        ];
    }
}
,
"ee4d4390":/*!
 * accepts
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    var Negotiator = farmRequire("5cb1eb7b", true);
    var mime = farmRequire("e0cde53a", true);
    module.exports = Accepts;
    function Accepts(req) {
        if (!(this instanceof Accepts)) {
            return new Accepts(req);
        }
        this.headers = req.headers;
        this.negotiator = new Negotiator(req);
    }
    Accepts.prototype.type = Accepts.prototype.types = function(types_) {
        var types = types_;
        if (types && !Array.isArray(types)) {
            types = new Array(arguments.length);
            for(var i = 0; i < types.length; i++){
                types[i] = arguments[i];
            }
        }
        if (!types || types.length === 0) {
            return this.negotiator.mediaTypes();
        }
        if (!this.headers.accept) {
            return types[0];
        }
        var mimes = types.map(extToMime);
        var accepts = this.negotiator.mediaTypes(mimes.filter(validMime));
        var first = accepts[0];
        return first ? types[mimes.indexOf(first)] : false;
    };
    Accepts.prototype.encoding = Accepts.prototype.encodings = function(encodings_) {
        var encodings = encodings_;
        if (encodings && !Array.isArray(encodings)) {
            encodings = new Array(arguments.length);
            for(var i = 0; i < encodings.length; i++){
                encodings[i] = arguments[i];
            }
        }
        if (!encodings || encodings.length === 0) {
            return this.negotiator.encodings();
        }
        return this.negotiator.encodings(encodings)[0] || false;
    };
    Accepts.prototype.charset = Accepts.prototype.charsets = function(charsets_) {
        var charsets = charsets_;
        if (charsets && !Array.isArray(charsets)) {
            charsets = new Array(arguments.length);
            for(var i = 0; i < charsets.length; i++){
                charsets[i] = arguments[i];
            }
        }
        if (!charsets || charsets.length === 0) {
            return this.negotiator.charsets();
        }
        return this.negotiator.charsets(charsets)[0] || false;
    };
    Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function(languages_) {
        var languages = languages_;
        if (languages && !Array.isArray(languages)) {
            languages = new Array(arguments.length);
            for(var i = 0; i < languages.length; i++){
                languages[i] = arguments[i];
            }
        }
        if (!languages || languages.length === 0) {
            return this.negotiator.languages();
        }
        return this.negotiator.languages(languages)[0] || false;
    };
    function extToMime(type) {
        return type.indexOf('/') === -1 ? mime.lookup(type) : type;
    }
    function validMime(type) {
        return typeof type === 'string';
    }
}
,
"ee7201d5":/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    module.exports = bytes;
    module.exports.format = format;
    module.exports.parse = parse;
    var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
    var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
    var map = {
        b: 1,
        kb: 1 << 10,
        mb: 1 << 20,
        gb: 1 << 30,
        tb: Math.pow(1024, 4),
        pb: Math.pow(1024, 5)
    };
    var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
    function bytes(value, options) {
        if (typeof value === 'string') {
            return parse(value);
        }
        if (typeof value === 'number') {
            return format(value, options);
        }
        return null;
    }
    function format(value, options) {
        if (!Number.isFinite(value)) {
            return null;
        }
        var mag = Math.abs(value);
        var thousandsSeparator = options && options.thousandsSeparator || '';
        var unitSeparator = options && options.unitSeparator || '';
        var decimalPlaces = options && options.decimalPlaces !== undefined ? options.decimalPlaces : 2;
        var fixedDecimals = Boolean(options && options.fixedDecimals);
        var unit = options && options.unit || '';
        if (!unit || !map[unit.toLowerCase()]) {
            if (mag >= map.pb) {
                unit = 'PB';
            } else if (mag >= map.tb) {
                unit = 'TB';
            } else if (mag >= map.gb) {
                unit = 'GB';
            } else if (mag >= map.mb) {
                unit = 'MB';
            } else if (mag >= map.kb) {
                unit = 'KB';
            } else {
                unit = 'B';
            }
        }
        var val = value / map[unit.toLowerCase()];
        var str = val.toFixed(decimalPlaces);
        if (!fixedDecimals) {
            str = str.replace(formatDecimalsRegExp, '$1');
        }
        if (thousandsSeparator) {
            str = str.split('.').map(function(s, i) {
                return i === 0 ? s.replace(formatThousandsRegExp, thousandsSeparator) : s;
            }).join('.');
        }
        return str + unitSeparator + unit;
    }
    function parse(val) {
        if (typeof val === 'number' && !isNaN(val)) {
            return val;
        }
        if (typeof val !== 'string') {
            return null;
        }
        var results = parseRegExp.exec(val);
        var floatValue;
        var unit = 'b';
        if (!results) {
            floatValue = parseInt(val, 10);
            unit = 'b';
        } else {
            floatValue = parseFloat(results[1]);
            unit = results[4].toLowerCase();
        }
        if (isNaN(floatValue)) {
            return null;
        }
        return Math.floor(map[unit] * floatValue);
    }
}
,
"eedce71a":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "convertErrorMessage", ()=>convertErrorMessage);
    function convertErrorMessage(error) {
        let errorMessage = '';
        try {
            errorMessage = JSON.parse(error.message).join('\n');
        } catch  {
            errorMessage = error.message;
        }
        return errorMessage;
    }
}
,
"f0ba01fa":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.createPathRewriter = void 0;
    const isPlainObj = farmRequire("17cd914f", true);
    const errors_1 = farmRequire("12559428", true);
    const debug_1 = farmRequire("2f90b0a5", true);
    const debug = debug_1.Debug.extend('path-rewriter');
    function createPathRewriter(rewriteConfig) {
        let rulesCache;
        if (!isValidRewriteConfig(rewriteConfig)) {
            return;
        }
        if (typeof rewriteConfig === 'function') {
            const customRewriteFn = rewriteConfig;
            return customRewriteFn;
        } else {
            rulesCache = parsePathRewriteRules(rewriteConfig);
            return rewritePath;
        }
        function rewritePath(path) {
            let result = path;
            for (const rule of rulesCache){
                if (rule.regex.test(path)) {
                    result = result.replace(rule.regex, rule.value);
                    debug('rewriting path from "%s" to "%s"', path, result);
                    break;
                }
            }
            return result;
        }
    }
    exports.createPathRewriter = createPathRewriter;
    function isValidRewriteConfig(rewriteConfig) {
        if (typeof rewriteConfig === 'function') {
            return true;
        } else if (isPlainObj(rewriteConfig)) {
            return Object.keys(rewriteConfig).length !== 0;
        } else if (rewriteConfig === undefined || rewriteConfig === null) {
            return false;
        } else {
            throw new Error(errors_1.ERRORS.ERR_PATH_REWRITER_CONFIG);
        }
    }
    function parsePathRewriteRules(rewriteConfig) {
        const rules = [];
        if (isPlainObj(rewriteConfig)) {
            for (const [key, value] of Object.entries(rewriteConfig)){
                rules.push({
                    regex: new RegExp(key),
                    value: value
                });
                debug('rewrite rule created: "%s" ~> "%s"', key, value);
            }
        }
        return rules;
    }
}
,
"f19542e0":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    var _f_colors = farmRequire("ccfc2d75");
    module._e(exports, _f_colors);
}
,
"f2828d33":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const fsStat = farmRequire("be5cf725", true);
    const fsWalk = farmRequire("410b6735", true);
    const reader_1 = farmRequire("7af0e906", true);
    class ReaderSync extends reader_1.default {
        constructor(){
            super(...arguments);
            this._walkSync = fsWalk.walkSync;
            this._statSync = fsStat.statSync;
        }
        dynamic(root, options) {
            return this._walkSync(root, options);
        }
        static(patterns, options) {
            const entries = [];
            for (const pattern of patterns){
                const filepath = this._getFullEntryPath(pattern);
                const entry = this._getEntry(filepath, pattern, options);
                if (entry === null || !options.entryFilter(entry)) {
                    continue;
                }
                entries.push(entry);
            }
            return entries;
        }
        _getEntry(filepath, pattern, options) {
            try {
                const stats = this._getStat(filepath);
                return this._makeEntry(stats, pattern);
            } catch (error) {
                if (options.errorFilter(error)) {
                    return null;
                }
                throw error;
            }
        }
        _getStat(filepath) {
            return this._statSync(filepath, this._fsStatSettings);
        }
    }
    exports.default = ReaderSync;
}
,
"f2e2163e":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const u = farmRequire("712c2dd4", true).fromCallback;
    const fs = farmRequire("ffc819a8", true);
    const api = [
        'access',
        'appendFile',
        'chmod',
        'chown',
        'close',
        'copyFile',
        'fchmod',
        'fchown',
        'fdatasync',
        'fstat',
        'fsync',
        'ftruncate',
        'futimes',
        'lchmod',
        'lchown',
        'link',
        'lstat',
        'mkdir',
        'mkdtemp',
        'open',
        'opendir',
        'readdir',
        'readFile',
        'readlink',
        'realpath',
        'rename',
        'rm',
        'rmdir',
        'stat',
        'symlink',
        'truncate',
        'unlink',
        'utimes',
        'writeFile'
    ].filter((key)=>{
        return typeof fs[key] === 'function';
    });
    Object.assign(exports, fs);
    api.forEach((method)=>{
        exports[method] = u(fs[method]);
    });
    exports.exists = function(filename, callback) {
        if (typeof callback === 'function') {
            return fs.exists(filename, callback);
        }
        return new Promise((resolve)=>{
            return fs.exists(filename, resolve);
        });
    };
    exports.read = function(fd, buffer, offset, length, position, callback) {
        if (typeof callback === 'function') {
            return fs.read(fd, buffer, offset, length, position, callback);
        }
        return new Promise((resolve, reject)=>{
            fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer)=>{
                if (err) return reject(err);
                resolve({
                    bytesRead,
                    buffer
                });
            });
        });
    };
    exports.write = function(fd, buffer, ...args) {
        if (typeof args[args.length - 1] === 'function') {
            return fs.write(fd, buffer, ...args);
        }
        return new Promise((resolve, reject)=>{
            fs.write(fd, buffer, ...args, (err, bytesWritten, buffer)=>{
                if (err) return reject(err);
                resolve({
                    bytesWritten,
                    buffer
                });
            });
        });
    };
    exports.readv = function(fd, buffers, ...args) {
        if (typeof args[args.length - 1] === 'function') {
            return fs.readv(fd, buffers, ...args);
        }
        return new Promise((resolve, reject)=>{
            fs.readv(fd, buffers, ...args, (err, bytesRead, buffers)=>{
                if (err) return reject(err);
                resolve({
                    bytesRead,
                    buffers
                });
            });
        });
    };
    exports.writev = function(fd, buffers, ...args) {
        if (typeof args[args.length - 1] === 'function') {
            return fs.writev(fd, buffers, ...args);
        }
        return new Promise((resolve, reject)=>{
            fs.writev(fd, buffers, ...args, (err, bytesWritten, buffers)=>{
                if (err) return reject(err);
                resolve({
                    bytesWritten,
                    buffers
                });
            });
        });
    };
    if (typeof fs.realpath.native === 'function') {
        exports.realpath.native = u(fs.realpath.native);
    } else {
        process.emitWarning('fs.realpath.native is not a function. Is fs being monkey-patched?', 'Warning', 'fs-extra-WARN0003');
    }
}
,
"f3250925":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    const fsWalk = farmRequire("410b6735", true);
    const reader_1 = farmRequire("7af0e906", true);
    const stream_1 = farmRequire("5a3e24d0", true);
    class ReaderAsync extends reader_1.default {
        constructor(){
            super(...arguments);
            this._walkAsync = fsWalk.walk;
            this._readerStream = new stream_1.default(this._settings);
        }
        dynamic(root, options) {
            return new Promise((resolve, reject)=>{
                this._walkAsync(root, options, (error, entries)=>{
                    if (error === null) {
                        resolve(entries);
                    } else {
                        reject(error);
                    }
                });
            });
        }
        async static(patterns, options) {
            const entries = [];
            const stream = this._readerStream.static(patterns, options);
            return new Promise((resolve, reject)=>{
                stream.once('error', reject);
                stream.on('data', (entry)=>entries.push(entry));
                stream.once('end', ()=>resolve(entries));
            });
        }
    }
    exports.default = ReaderAsync;
}
,
"f3639a9d":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.fixRequestBody = void 0;
    const querystring = global.nodeRequire("querystring", true);
    function fixRequestBody(proxyReq, req) {
        const requestBody = req.body;
        if (!requestBody) {
            return;
        }
        const contentType = proxyReq.getHeader('Content-Type');
        const writeBody = (bodyData)=>{
            proxyReq.setHeader('Content-Length', Buffer.byteLength(bodyData));
            proxyReq.write(bodyData);
        };
        if (contentType && contentType.includes('application/json')) {
            writeBody(JSON.stringify(requestBody));
        }
        if (contentType && contentType.includes('application/x-www-form-urlencoded')) {
            writeBody(querystring.stringify(requestBody));
        }
    }
    exports.fixRequestBody = fixRequestBody;
}
,
"f3a11347":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    function posix(path) {
        return path.charAt(0) === '/';
    }
    function win32(path) {
        var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
        var result = splitDeviceRe.exec(path);
        var device = result[1] || '';
        var isUnc = Boolean(device && device.charAt(1) !== ':');
        return Boolean(result[2] || isUnc);
    }
    module.exports = process.platform === 'win32' ? win32 : posix;
    module.exports.posix = posix;
    module.exports.win32 = win32;
}
,
"f3d69eed":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "default", ()=>bundleName);
    var _f_run_applescript = farmRequire("6ce4fd89");
    async function bundleName(bundleId) {
        return _f_run_applescript.runAppleScriptAsync(`tell application "Finder" to set app_path to application file id "${bundleId}" as string\ntell application "System Events" to get value of property list item "CFBundleName" of property list file (app_path & ":Contents:Info.plist")`);
    }
}
,
"f4086ed0":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const utils = farmRequire("29769a7a", true);
    module.exports = (ast, options = {})=>{
        let stringify = (node, parent = {})=>{
            let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
            let invalidNode = node.invalid === true && options.escapeInvalid === true;
            let output = '';
            if (node.value) {
                if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
                    return '\\' + node.value;
                }
                return node.value;
            }
            if (node.value) {
                return node.value;
            }
            if (node.nodes) {
                for (let child of node.nodes){
                    output += stringify(child);
                }
            }
            return output;
        };
        return stringify(ast);
    };
}
,
"f491c1b2":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const u = farmRequire("712c2dd4", true).fromPromise;
    const fs = farmRequire("f2e2163e", true);
    const path = global.nodeRequire('path', true);
    const mkdir = farmRequire("abdb8a71", true);
    const remove = farmRequire("4ffdf2a8", true);
    const emptyDir = u(async function emptyDir(dir) {
        let items;
        try {
            items = await fs.readdir(dir);
        } catch  {
            return mkdir.mkdirs(dir);
        }
        return Promise.all(items.map((item)=>remove.remove(path.join(dir, item))));
    });
    function emptyDirSync(dir) {
        let items;
        try {
            items = fs.readdirSync(dir);
        } catch  {
            return mkdir.mkdirsSync(dir);
        }
        items.forEach((item)=>{
            item = path.join(dir, item);
            remove.removeSync(item);
        });
    }
    module.exports = {
        emptyDirSync,
        emptydirSync: emptyDirSync,
        emptyDir,
        emptydir: emptyDir
    };
}
,
"f69bc856":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const u = farmRequire("712c2dd4", true).fromCallback;
    const fs = farmRequire("ffc819a8", true);
    const path = global.nodeRequire('path', true);
    const mkdir = farmRequire("abdb8a71", true);
    const pathExists = farmRequire("05a93efb", true).pathExists;
    function outputFile(file, data, encoding, callback) {
        if (typeof encoding === 'function') {
            callback = encoding;
            encoding = 'utf8';
        }
        const dir = path.dirname(file);
        pathExists(dir, (err, itDoes)=>{
            if (err) return callback(err);
            if (itDoes) return fs.writeFile(file, data, encoding, callback);
            mkdir.mkdirs(dir, (err)=>{
                if (err) return callback(err);
                fs.writeFile(file, data, encoding, callback);
            });
        });
    }
    function outputFileSync(file, ...args) {
        const dir = path.dirname(file);
        if (fs.existsSync(dir)) {
            return fs.writeFileSync(file, ...args);
        }
        mkdir.mkdirsSync(dir);
        fs.writeFileSync(file, ...args);
    }
    module.exports = {
        outputFile: u(outputFile),
        outputFileSync
    };
}
,
"f6aa6113":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const nativePromisePrototype = (async ()=>{})().constructor.prototype;
    const descriptors = [
        'then',
        'catch',
        'finally'
    ].map((property)=>[
            property,
            Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
        ]);
    const mergePromise = (spawned, promise)=>{
        for (const [property, descriptor] of descriptors){
            const value = typeof promise === 'function' ? (...args)=>Reflect.apply(descriptor.value, promise(), args) : descriptor.value.bind(promise);
            Reflect.defineProperty(spawned, property, {
                ...descriptor,
                value
            });
        }
        return spawned;
    };
    const getSpawnedPromise = (spawned)=>{
        return new Promise((resolve, reject)=>{
            spawned.on('exit', (exitCode, signal)=>{
                resolve({
                    exitCode,
                    signal
                });
            });
            spawned.on('error', (error)=>{
                reject(error);
            });
            if (spawned.stdin) {
                spawned.stdin.on('error', (error)=>{
                    reject(error);
                });
            }
        });
    };
    module.exports = {
        mergePromise,
        getSpawnedPromise
    };
}
,
"f6eecd34":/*!
 * depd
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ function  (module, exports, farmRequire, farmDynamicRequire) {
    var callSiteToString = farmRequire("4af6935d", true).callSiteToString;
    var eventListenerCount = farmRequire("4af6935d", true).eventListenerCount;
    var relative = global.nodeRequire('path', true).relative;
    module.exports = depd;
    var basePath = process.cwd();
    function containsNamespace(str, namespace) {
        var vals = str.split(/[ ,]+/);
        var ns = String(namespace).toLowerCase();
        for(var i = 0; i < vals.length; i++){
            var val = vals[i];
            if (val && (val === '*' || val.toLowerCase() === ns)) {
                return true;
            }
        }
        return false;
    }
    function convertDataDescriptorToAccessor(obj, prop, message) {
        var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
        var value = descriptor.value;
        descriptor.get = function getter() {
            return value;
        };
        if (descriptor.writable) {
            descriptor.set = function setter(val) {
                return value = val;
            };
        }
        delete descriptor.value;
        delete descriptor.writable;
        Object.defineProperty(obj, prop, descriptor);
        return descriptor;
    }
    function createArgumentsString(arity) {
        var str = '';
        for(var i = 0; i < arity; i++){
            str += ', arg' + i;
        }
        return str.substr(2);
    }
    function createStackString(stack) {
        var str = this.name + ': ' + this.namespace;
        if (this.message) {
            str += ' deprecated ' + this.message;
        }
        for(var i = 0; i < stack.length; i++){
            str += '\n    at ' + callSiteToString(stack[i]);
        }
        return str;
    }
    function depd(namespace) {
        if (!namespace) {
            throw new TypeError('argument namespace is required');
        }
        var stack = getStack();
        var site = callSiteLocation(stack[1]);
        var file = site[0];
        function deprecate(message) {
            log.call(deprecate, message);
        }
        deprecate._file = file;
        deprecate._ignored = isignored(namespace);
        deprecate._namespace = namespace;
        deprecate._traced = istraced(namespace);
        deprecate._warned = Object.create(null);
        deprecate.function = wrapfunction;
        deprecate.property = wrapproperty;
        return deprecate;
    }
    function isignored(namespace) {
        if (process.noDeprecation) {
            return true;
        }
        var str = process.env.NO_DEPRECATION || '';
        return containsNamespace(str, namespace);
    }
    function istraced(namespace) {
        if (process.traceDeprecation) {
            return true;
        }
        var str = process.env.TRACE_DEPRECATION || '';
        return containsNamespace(str, namespace);
    }
    function log(message, site) {
        var haslisteners = eventListenerCount(process, 'deprecation') !== 0;
        if (!haslisteners && this._ignored) {
            return;
        }
        var caller;
        var callFile;
        var callSite;
        var depSite;
        var i = 0;
        var seen = false;
        var stack = getStack();
        var file = this._file;
        if (site) {
            depSite = site;
            callSite = callSiteLocation(stack[1]);
            callSite.name = depSite.name;
            file = callSite[0];
        } else {
            i = 2;
            depSite = callSiteLocation(stack[i]);
            callSite = depSite;
        }
        for(; i < stack.length; i++){
            caller = callSiteLocation(stack[i]);
            callFile = caller[0];
            if (callFile === file) {
                seen = true;
            } else if (callFile === this._file) {
                file = this._file;
            } else if (seen) {
                break;
            }
        }
        var key = caller ? depSite.join(':') + '__' + caller.join(':') : undefined;
        if (key !== undefined && key in this._warned) {
            return;
        }
        this._warned[key] = true;
        var msg = message;
        if (!msg) {
            msg = callSite === depSite || !callSite.name ? defaultMessage(depSite) : defaultMessage(callSite);
        }
        if (haslisteners) {
            var err = DeprecationError(this._namespace, msg, stack.slice(i));
            process.emit('deprecation', err);
            return;
        }
        var format = process.stderr.isTTY ? formatColor : formatPlain;
        var output = format.call(this, msg, caller, stack.slice(i));
        process.stderr.write(output + '\n', 'utf8');
    }
    function callSiteLocation(callSite) {
        var file = callSite.getFileName() || '<anonymous>';
        var line = callSite.getLineNumber();
        var colm = callSite.getColumnNumber();
        if (callSite.isEval()) {
            file = callSite.getEvalOrigin() + ', ' + file;
        }
        var site = [
            file,
            line,
            colm
        ];
        site.callSite = callSite;
        site.name = callSite.getFunctionName();
        return site;
    }
    function defaultMessage(site) {
        var callSite = site.callSite;
        var funcName = site.name;
        if (!funcName) {
            funcName = '<anonymous@' + formatLocation(site) + '>';
        }
        var context = callSite.getThis();
        var typeName = context && callSite.getTypeName();
        if (typeName === 'Object') {
            typeName = undefined;
        }
        if (typeName === 'Function') {
            typeName = context.name || typeName;
        }
        return typeName && callSite.getMethodName() ? typeName + '.' + funcName : funcName;
    }
    function formatPlain(msg, caller, stack) {
        var timestamp = new Date().toUTCString();
        var formatted = timestamp + ' ' + this._namespace + ' deprecated ' + msg;
        if (this._traced) {
            for(var i = 0; i < stack.length; i++){
                formatted += '\n    at ' + callSiteToString(stack[i]);
            }
            return formatted;
        }
        if (caller) {
            formatted += ' at ' + formatLocation(caller);
        }
        return formatted;
    }
    function formatColor(msg, caller, stack) {
        var formatted = '\x1b[36;1m' + this._namespace + '\x1b[22;39m' + ' \x1b[33;1mdeprecated\x1b[22;39m' + ' \x1b[0m' + msg + '\x1b[39m';
        if (this._traced) {
            for(var i = 0; i < stack.length; i++){
                formatted += '\n    \x1b[36mat ' + callSiteToString(stack[i]) + '\x1b[39m';
            }
            return formatted;
        }
        if (caller) {
            formatted += ' \x1b[36m' + formatLocation(caller) + '\x1b[39m';
        }
        return formatted;
    }
    function formatLocation(callSite) {
        return relative(basePath, callSite[0]) + ':' + callSite[1] + ':' + callSite[2];
    }
    function getStack() {
        var limit = Error.stackTraceLimit;
        var obj = {};
        var prep = Error.prepareStackTrace;
        Error.prepareStackTrace = prepareObjectStackTrace;
        Error.stackTraceLimit = Math.max(10, limit);
        Error.captureStackTrace(obj);
        var stack = obj.stack.slice(1);
        Error.prepareStackTrace = prep;
        Error.stackTraceLimit = limit;
        return stack;
    }
    function prepareObjectStackTrace(obj, stack) {
        return stack;
    }
    function wrapfunction(fn, message) {
        if (typeof fn !== 'function') {
            throw new TypeError('argument fn must be a function');
        }
        var args = createArgumentsString(fn.length);
        var deprecate = this;
        var stack = getStack();
        var site = callSiteLocation(stack[1]);
        site.name = fn.name;
        var deprecatedfn = eval('(function (' + args + ') {\n' + '"use strict"\n' + 'log.call(deprecate, message, site)\n' + 'return fn.apply(this, arguments)\n' + '})');
        return deprecatedfn;
    }
    function wrapproperty(obj, prop, message) {
        if (!obj || typeof obj !== 'object' && typeof obj !== 'function') {
            throw new TypeError('argument obj must be object');
        }
        var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
        if (!descriptor) {
            throw new TypeError('must call property on owner object');
        }
        if (!descriptor.configurable) {
            throw new TypeError('property must be configurable');
        }
        var deprecate = this;
        var stack = getStack();
        var site = callSiteLocation(stack[1]);
        site.name = prop;
        if ('value' in descriptor) {
            descriptor = convertDataDescriptorToAccessor(obj, prop, message);
        }
        var get = descriptor.get;
        var set = descriptor.set;
        if (typeof get === 'function') {
            descriptor.get = function getter() {
                log.call(deprecate, message, site);
                return get.apply(this, arguments);
            };
        }
        if (typeof set === 'function') {
            descriptor.set = function setter() {
                log.call(deprecate, message, site);
                return set.apply(this, arguments);
            };
        }
        Object.defineProperty(obj, prop, descriptor);
    }
    function DeprecationError(namespace, message, stack) {
        var error = new Error();
        var stackString;
        Object.defineProperty(error, 'constructor', {
            value: DeprecationError
        });
        Object.defineProperty(error, 'message', {
            configurable: true,
            enumerable: false,
            value: message,
            writable: true
        });
        Object.defineProperty(error, 'name', {
            enumerable: false,
            configurable: true,
            value: 'DeprecationError',
            writable: true
        });
        Object.defineProperty(error, 'namespace', {
            configurable: true,
            enumerable: false,
            value: namespace,
            writable: true
        });
        Object.defineProperty(error, 'stack', {
            configurable: true,
            enumerable: false,
            get: function() {
                if (stackString !== undefined) {
                    return stackString;
                }
                return stackString = createStackString.call(this, stack);
            },
            set: function setter(val) {
                stackString = val;
            }
        });
        return error;
    }
}
,
"f8468536":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.getFunctionName = void 0;
    function getFunctionName(fn) {
        return fn.name || '[anonymous Function]';
    }
    exports.getFunctionName = getFunctionName;
}
,
"f8f16f68":function  (module, exports, farmRequire, farmDynamicRequire) {
    var ProxyServer = farmRequire("1e6e5b87", true).Server;
    function createProxyServer(options) {
        return new ProxyServer(options);
    }
    ProxyServer.createProxyServer = createProxyServer;
    ProxyServer.createServer = createProxyServer;
    ProxyServer.createProxy = createProxyServer;
    module.exports = ProxyServer;
}
,
"f9eb5ea0":function  (module, exports, farmRequire, farmDynamicRequire) {
    if (typeof Object.create === 'function') {
        module.exports = function inherits(ctor, superCtor) {
            if (superCtor) {
                ctor.super_ = superCtor;
                ctor.prototype = Object.create(superCtor.prototype, {
                    constructor: {
                        value: ctor,
                        enumerable: false,
                        writable: true,
                        configurable: true
                    }
                });
            }
        };
    } else {
        module.exports = function inherits(ctor, superCtor) {
            if (superCtor) {
                ctor.super_ = superCtor;
                var TempCtor = function() {};
                TempCtor.prototype = superCtor.prototype;
                ctor.prototype = new TempCtor();
                ctor.prototype.constructor = ctor;
            }
        };
    }
}
,
"fa0a3c2a":function  (module, exports, farmRequire, farmDynamicRequire) {
    "use strict";
    var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
            desc = {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            };
        }
        Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    });
    var __exportStar = this && this.__exportStar || function(m, exports1) {
        for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
    };
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    __exportStar(farmRequire("79404dc4", true), exports);
}
,
"fb482e15":function  (module, exports, farmRequire, farmDynamicRequire) {
    module.exports = Delegator;
    function Delegator(proto, target) {
        if (!(this instanceof Delegator)) return new Delegator(proto, target);
        this.proto = proto;
        this.target = target;
        this.methods = [];
        this.getters = [];
        this.setters = [];
        this.fluents = [];
    }
    Delegator.prototype.method = function(name) {
        var proto = this.proto;
        var target = this.target;
        this.methods.push(name);
        proto[name] = function() {
            return this[target][name].apply(this[target], arguments);
        };
        return this;
    };
    Delegator.prototype.access = function(name) {
        return this.getter(name).setter(name);
    };
    Delegator.prototype.getter = function(name) {
        var proto = this.proto;
        var target = this.target;
        this.getters.push(name);
        proto.__defineGetter__(name, function() {
            return this[target][name];
        });
        return this;
    };
    Delegator.prototype.setter = function(name) {
        var proto = this.proto;
        var target = this.target;
        this.setters.push(name);
        proto.__defineSetter__(name, function(val) {
            return this[target][name] = val;
        });
        return this;
    };
    Delegator.prototype.fluent = function(name) {
        var proto = this.proto;
        var target = this.target;
        this.fluents.push(name);
        proto[name] = function(val) {
            if ('undefined' != typeof val) {
                this[target][name] = val;
                return this;
            } else {
                return this[target][name];
            }
        };
        return this;
    };
}
,
"fb66eeb6":function  (module, exports, farmRequire, farmDynamicRequire) {
    var process = global.process;
    const processOk = function(process) {
        return process && typeof process === 'object' && typeof process.removeListener === 'function' && typeof process.emit === 'function' && typeof process.reallyExit === 'function' && typeof process.listeners === 'function' && typeof process.kill === 'function' && typeof process.pid === 'number' && typeof process.on === 'function';
    };
    if (!processOk(process)) {
        module.exports = function() {
            return function() {};
        };
    } else {
        var assert = global.nodeRequire('assert', true);
        var signals = farmRequire("776bdf70", true);
        var isWin = /^win/i.test(process.platform);
        var EE = global.nodeRequire('events', true);
        if (typeof EE !== 'function') {
            EE = EE.EventEmitter;
        }
        var emitter;
        if (process.__signal_exit_emitter__) {
            emitter = process.__signal_exit_emitter__;
        } else {
            emitter = process.__signal_exit_emitter__ = new EE();
            emitter.count = 0;
            emitter.emitted = {};
        }
        if (!emitter.infinite) {
            emitter.setMaxListeners(Infinity);
            emitter.infinite = true;
        }
        module.exports = function(cb, opts) {
            if (!processOk(global.process)) {
                return function() {};
            }
            assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler');
            if (loaded === false) {
                load();
            }
            var ev = 'exit';
            if (opts && opts.alwaysLast) {
                ev = 'afterexit';
            }
            var remove = function() {
                emitter.removeListener(ev, cb);
                if (emitter.listeners('exit').length === 0 && emitter.listeners('afterexit').length === 0) {
                    unload();
                }
            };
            emitter.on(ev, cb);
            return remove;
        };
        var unload = function unload() {
            if (!loaded || !processOk(global.process)) {
                return;
            }
            loaded = false;
            signals.forEach(function(sig) {
                try {
                    process.removeListener(sig, sigListeners[sig]);
                } catch (er) {}
            });
            process.emit = originalProcessEmit;
            process.reallyExit = originalProcessReallyExit;
            emitter.count -= 1;
        };
        module.exports.unload = unload;
        var emit = function emit(event, code, signal) {
            if (emitter.emitted[event]) {
                return;
            }
            emitter.emitted[event] = true;
            emitter.emit(event, code, signal);
        };
        var sigListeners = {};
        signals.forEach(function(sig) {
            sigListeners[sig] = function listener() {
                if (!processOk(global.process)) {
                    return;
                }
                var listeners = process.listeners(sig);
                if (listeners.length === emitter.count) {
                    unload();
                    emit('exit', null, sig);
                    emit('afterexit', null, sig);
                    if (isWin && sig === 'SIGHUP') {
                        sig = 'SIGINT';
                    }
                    process.kill(process.pid, sig);
                }
            };
        });
        module.exports.signals = function() {
            return signals;
        };
        var loaded = false;
        var load = function load() {
            if (loaded || !processOk(global.process)) {
                return;
            }
            loaded = true;
            emitter.count += 1;
            signals = signals.filter(function(sig) {
                try {
                    process.on(sig, sigListeners[sig]);
                    return true;
                } catch (er) {
                    return false;
                }
            });
            process.emit = processEmit;
            process.reallyExit = processReallyExit;
        };
        module.exports.load = load;
        var originalProcessReallyExit = process.reallyExit;
        var processReallyExit = function processReallyExit(code) {
            if (!processOk(global.process)) {
                return;
            }
            process.exitCode = code || 0;
            emit('exit', process.exitCode, null);
            emit('afterexit', process.exitCode, null);
            originalProcessReallyExit.call(process, process.exitCode);
        };
        var originalProcessEmit = process.emit;
        var processEmit = function processEmit(ev, arg) {
            if (ev === 'exit' && processOk(global.process)) {
                if (arg !== undefined) {
                    process.exitCode = arg;
                }
                var ret = originalProcessEmit.apply(this, arguments);
                emit('exit', process.exitCode, null);
                emit('afterexit', process.exitCode, null);
                return ret;
            } else {
                return originalProcessEmit.apply(this, arguments);
            }
        };
    }
}
,
"fb675039":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const u = farmRequire("712c2dd4", true).fromCallback;
    const path = global.nodeRequire('path', true);
    const fs = farmRequire("ffc819a8", true);
    const mkdir = farmRequire("abdb8a71", true);
    function createFile(file, callback) {
        function makeFile() {
            fs.writeFile(file, '', (err)=>{
                if (err) return callback(err);
                callback();
            });
        }
        fs.stat(file, (err, stats)=>{
            if (!err && stats.isFile()) return callback();
            const dir = path.dirname(file);
            fs.stat(dir, (err, stats)=>{
                if (err) {
                    if (err.code === 'ENOENT') {
                        return mkdir.mkdirs(dir, (err)=>{
                            if (err) return callback(err);
                            makeFile();
                        });
                    }
                    return callback(err);
                }
                if (stats.isDirectory()) makeFile();
                else {
                    fs.readdir(dir, (err)=>{
                        if (err) return callback(err);
                    });
                }
            });
        });
    }
    function createFileSync(file) {
        let stats;
        try {
            stats = fs.statSync(file);
        } catch  {}
        if (stats && stats.isFile()) return;
        const dir = path.dirname(file);
        try {
            if (!fs.statSync(dir).isDirectory()) {
                fs.readdirSync(dir);
            }
        } catch (err) {
            if (err && err.code === 'ENOENT') mkdir.mkdirsSync(dir);
            else throw err;
        }
        fs.writeFileSync(file, '');
    }
    module.exports = {
        createFile: u(createFile),
        createFileSync
    };
}
,
"fbafd9e4":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    module.exports = {
        MAX_LENGTH: 1024 * 64,
        CHAR_0: '0',
        CHAR_9: '9',
        CHAR_UPPERCASE_A: 'A',
        CHAR_LOWERCASE_A: 'a',
        CHAR_UPPERCASE_Z: 'Z',
        CHAR_LOWERCASE_Z: 'z',
        CHAR_LEFT_PARENTHESES: '(',
        CHAR_RIGHT_PARENTHESES: ')',
        CHAR_ASTERISK: '*',
        CHAR_AMPERSAND: '&',
        CHAR_AT: '@',
        CHAR_BACKSLASH: '\\',
        CHAR_BACKTICK: '`',
        CHAR_CARRIAGE_RETURN: '\r',
        CHAR_CIRCUMFLEX_ACCENT: '^',
        CHAR_COLON: ':',
        CHAR_COMMA: ',',
        CHAR_DOLLAR: '$',
        CHAR_DOT: '.',
        CHAR_DOUBLE_QUOTE: '"',
        CHAR_EQUAL: '=',
        CHAR_EXCLAMATION_MARK: '!',
        CHAR_FORM_FEED: '\f',
        CHAR_FORWARD_SLASH: '/',
        CHAR_HASH: '#',
        CHAR_HYPHEN_MINUS: '-',
        CHAR_LEFT_ANGLE_BRACKET: '<',
        CHAR_LEFT_CURLY_BRACE: '{',
        CHAR_LEFT_SQUARE_BRACKET: '[',
        CHAR_LINE_FEED: '\n',
        CHAR_NO_BREAK_SPACE: '\u00A0',
        CHAR_PERCENT: '%',
        CHAR_PLUS: '+',
        CHAR_QUESTION_MARK: '?',
        CHAR_RIGHT_ANGLE_BRACKET: '>',
        CHAR_RIGHT_CURLY_BRACE: '}',
        CHAR_RIGHT_SQUARE_BRACKET: ']',
        CHAR_SEMICOLON: ';',
        CHAR_SINGLE_QUOTE: '\'',
        CHAR_SPACE: ' ',
        CHAR_TAB: '\t',
        CHAR_UNDERSCORE: '_',
        CHAR_VERTICAL_LINE: '|',
        CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\uFEFF'
    };
}
,
"fc37adc9":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    var toStr = Object.prototype.toString;
    var fnToStr = Function.prototype.toString;
    var isFnRegex = /^\s*(?:function)?\*/;
    var hasToStringTag = farmRequire("c43cfb2b", true)();
    var getProto = Object.getPrototypeOf;
    var getGeneratorFunc = function() {
        if (!hasToStringTag) {
            return false;
        }
        try {
            return Function('return function*() {}')();
        } catch (e) {}
    };
    var GeneratorFunction;
    module.exports = function isGeneratorFunction(fn) {
        if (typeof fn !== 'function') {
            return false;
        }
        if (isFnRegex.test(fnToStr.call(fn))) {
            return true;
        }
        if (!hasToStringTag) {
            var str = toStr.call(fn);
            return str === '[object GeneratorFunction]';
        }
        if (!getProto) {
            return false;
        }
        if (typeof GeneratorFunction === 'undefined') {
            var generatorFunc = getGeneratorFunc();
            GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
        }
        return getProto(fn) === GeneratorFunction;
    };
}
,
"fc3f5f8e":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "normalizeCss", ()=>normalizeCss);
    var _f_constants = farmRequire("97f6a66c");
    function normalizeCss(config, resolvedCompilation) {
        if (config.compilation?.css?.modules) {
            normalizeCssModules(config, resolvedCompilation);
        }
    }
    function normalizeCssModules(config, resolvedCompilation) {
        if (config.compilation.css.modules.localsConversion) {
            const localsConvention = config.compilation.css.modules.localsConversion;
            delete resolvedCompilation.css.modules.localsConversion;
            if (typeof localsConvention === 'string') {
                resolvedCompilation.custom[_f_constants.CUSTOM_KEYS.css_locals_conversion] = JSON.stringify(localsConvention);
            }
        }
    }
}
,
"fcaf28bf":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const fill = farmRequire("4278e518", true);
    const utils = farmRequire("29769a7a", true);
    const compile = (ast, options = {})=>{
        let walk = (node, parent = {})=>{
            let invalidBlock = utils.isInvalidBrace(parent);
            let invalidNode = node.invalid === true && options.escapeInvalid === true;
            let invalid = invalidBlock === true || invalidNode === true;
            let prefix = options.escapeInvalid === true ? '\\' : '';
            let output = '';
            if (node.isOpen === true) {
                return prefix + node.value;
            }
            if (node.isClose === true) {
                return prefix + node.value;
            }
            if (node.type === 'open') {
                return invalid ? prefix + node.value : '(';
            }
            if (node.type === 'close') {
                return invalid ? prefix + node.value : ')';
            }
            if (node.type === 'comma') {
                return node.prev.type === 'comma' ? '' : invalid ? node.value : '|';
            }
            if (node.value) {
                return node.value;
            }
            if (node.nodes && node.ranges > 0) {
                let args = utils.reduce(node.nodes);
                let range = fill(...args, {
                    ...options,
                    wrap: false,
                    toRegex: true
                });
                if (range.length !== 0) {
                    return args.length > 1 && range.length > 1 ? `(${range})` : range;
                }
            }
            if (node.nodes) {
                for (let child of node.nodes){
                    output += walk(child, node);
                }
            }
            return output;
        };
        return walk(ast);
    };
    module.exports = compile;
}
,
"ff96d815":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "normalizePersistentCache", ()=>normalizePersistentCache);
    var _f_node_fs = farmRequire('node:fs');
    var _f_node_module = farmRequire('node:module');
    var _f_node_path = module.i(farmRequire('node:path'));
    var _f_trace_dependencies = farmRequire("16544049");
    var _f_env = farmRequire("83b19369");
    const defaultGlobalBuiltinCacheKeyStrategy = {
        define: true,
        buildDependencies: true,
        lockfile: true,
        packageJson: true,
        env: true
    };
    async function normalizePersistentCache(config, resolvedUserConfig, logger) {
        if (_f_env.isDisableCache()) {
            config.persistentCache = false;
        }
        if (config?.persistentCache === false) {
            return;
        }
        if (config.persistentCache === true || config.persistentCache == undefined) {
            config.persistentCache = {
                buildDependencies: [],
                moduleCacheKeyStrategy: {},
                envs: {}
            };
        }
        let { globalBuiltinCacheKeyStrategy } = config.persistentCache;
        delete config.persistentCache.globalBuiltinCacheKeyStrategy;
        if (!globalBuiltinCacheKeyStrategy) {
            globalBuiltinCacheKeyStrategy = {};
        }
        globalBuiltinCacheKeyStrategy = {
            ...defaultGlobalBuiltinCacheKeyStrategy,
            ...globalBuiltinCacheKeyStrategy
        };
        if (globalBuiltinCacheKeyStrategy.env) {
            config.persistentCache.envs = {
                ...resolvedUserConfig.env ?? {},
                ...config.persistentCache.envs ?? {}
            };
        }
        if (globalBuiltinCacheKeyStrategy.define) {
            if (config.define && typeof config.define === 'object') {
                config.persistentCache.envs = {
                    ...Object.entries(config.define).map(([k, v])=>typeof v !== 'string' ? [
                            k,
                            JSON.stringify(v)
                        ] : [
                            k,
                            v
                        ]).reduce((acc, [k, v])=>{
                        acc[k] = v;
                        return acc;
                    }, {}),
                    ...config.persistentCache.envs
                };
            }
        }
        const packageJsonPath = module.f(_f_node_path).join(config.root ?? process.cwd(), 'package.json');
        if (globalBuiltinCacheKeyStrategy.packageJson) {
            if (_f_node_fs.existsSync(packageJsonPath)) {
                const s = _f_node_fs.readFileSync(packageJsonPath).toString();
                const packageJson = JSON.parse(s);
                const affectedKeys = [
                    'type',
                    'name',
                    'exports',
                    'browser',
                    'main',
                    'module'
                ];
                for (const key of affectedKeys){
                    const value = packageJson[key] ?? 'unknown';
                    config.persistentCache.envs[`package.json[${key}]`] = typeof value !== 'string' ? JSON.stringify(value) : value;
                }
            }
        }
        if (!config.persistentCache.buildDependencies) {
            config.persistentCache.buildDependencies = [];
        }
        if (globalBuiltinCacheKeyStrategy.lockfile) {
            for (const lockfile of [
                'package-lock.json',
                'yarn.lock',
                'pnpm-lock.yaml'
            ]){
                if (!config.persistentCache.buildDependencies.includes(lockfile)) {
                    config.persistentCache.buildDependencies.push(lockfile);
                }
            }
        }
        if (config?.output?.targetEnv === 'node') {
            if (!config.persistentCache.moduleCacheKeyStrategy) {
                config.persistentCache.moduleCacheKeyStrategy = {};
            }
            config.persistentCache.moduleCacheKeyStrategy.timestamp = false;
        }
        if (globalBuiltinCacheKeyStrategy.buildDependencies && resolvedUserConfig.configFilePath) {
            const files = resolvedUserConfig?.configFileDependencies?.length ? resolvedUserConfig.configFileDependencies : await _f_trace_dependencies.traceDependencies(resolvedUserConfig.configFilePath, logger);
            const packages = [];
            for (const file of files){
                if (module.f(_f_node_path).isAbsolute(file)) {
                    config.persistentCache.buildDependencies.push(file);
                } else {
                    packages.push(file);
                }
            }
            const rustPlugins = resolvedUserConfig.plugins?.filter((plugin)=>typeof plugin === 'string' || Array.isArray(plugin));
            packages.push(...rustPlugins ?? []);
            if (packages?.length) {
                const require = _f_node_module.createRequire(module.f(_f_node_path).join(config.root, 'package.json'));
                for (const p of packages){
                    try {
                        let packageJsonPath;
                        if (typeof p === 'string') {
                            packageJsonPath = require.resolve(`${p}/package.json`);
                        } else {
                            packageJsonPath = require.resolve(`${p[0]}/package.json`);
                        }
                        const packageJson = require(packageJsonPath);
                        const key = `${packageJson.name}@${packageJson.version}`;
                        config.persistentCache.buildDependencies.push(key);
                    } catch  {
                        if (typeof p === 'string') {
                            config.persistentCache.buildDependencies.push(p);
                        } else if (Array.isArray(p) && typeof p[0] === 'string') {
                            config.persistentCache.buildDependencies.push(p[0]);
                        }
                        continue;
                    }
                }
            }
            config.persistentCache.buildDependencies.sort();
        }
    }
}
,
"ffc819a8":function  (module, exports, farmRequire, farmDynamicRequire) {
    var fs = global.nodeRequire('fs', true);
    var polyfills = farmRequire("1aaeac37", true);
    var legacy = farmRequire("8ab57d03", true);
    var clone = farmRequire("774c471c", true);
    var util = global.nodeRequire('util', true);
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === 'function' && typeof Symbol.for === 'function') {
        gracefulQueue = Symbol.for('graceful-fs.queue');
        previousSymbol = Symbol.for('graceful-fs.previous');
    } else {
        gracefulQueue = '___graceful-fs.queue';
        previousSymbol = '___graceful-fs.previous';
    }
    function noop() {}
    function publishQueue(context, queue) {
        Object.defineProperty(context, gracefulQueue, {
            get: function() {
                return queue;
            }
        });
    }
    var debug = noop;
    if (util.debuglog) debug = util.debuglog('gfs4');
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) debug = function() {
        var m = util.format.apply(util, arguments);
        m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ');
        console.error(m);
    };
    if (!fs[gracefulQueue]) {
        var queue = global[gracefulQueue] || [];
        publishQueue(fs, queue);
        fs.close = function(fs$close) {
            function close(fd, cb) {
                return fs$close.call(fs, fd, function(err) {
                    if (!err) {
                        resetQueue();
                    }
                    if (typeof cb === 'function') cb.apply(this, arguments);
                });
            }
            Object.defineProperty(close, previousSymbol, {
                value: fs$close
            });
            return close;
        }(fs.close);
        fs.closeSync = function(fs$closeSync) {
            function closeSync(fd) {
                fs$closeSync.apply(fs, arguments);
                resetQueue();
            }
            Object.defineProperty(closeSync, previousSymbol, {
                value: fs$closeSync
            });
            return closeSync;
        }(fs.closeSync);
        if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
            process.on('exit', function() {
                debug(fs[gracefulQueue]);
                global.nodeRequire('assert', true).equal(fs[gracefulQueue].length, 0);
            });
        }
    }
    if (!global[gracefulQueue]) {
        publishQueue(global, fs[gracefulQueue]);
    }
    module.exports = patch(clone(fs));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
        module.exports = patch(fs);
        fs.__patched = true;
    }
    function patch(fs) {
        polyfills(fs);
        fs.gracefulify = patch;
        fs.createReadStream = createReadStream;
        fs.createWriteStream = createWriteStream;
        var fs$readFile = fs.readFile;
        fs.readFile = readFile;
        function readFile(path, options, cb) {
            if (typeof options === 'function') cb = options, options = null;
            return go$readFile(path, options, cb);
            function go$readFile(path, options, cb, startTime) {
                return fs$readFile(path, options, function(err) {
                    if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                        go$readFile,
                        [
                            path,
                            options,
                            cb
                        ],
                        err,
                        startTime || Date.now(),
                        Date.now()
                    ]);
                    else {
                        if (typeof cb === 'function') cb.apply(this, arguments);
                    }
                });
            }
        }
        var fs$writeFile = fs.writeFile;
        fs.writeFile = writeFile;
        function writeFile(path, data, options, cb) {
            if (typeof options === 'function') cb = options, options = null;
            return go$writeFile(path, data, options, cb);
            function go$writeFile(path, data, options, cb, startTime) {
                return fs$writeFile(path, data, options, function(err) {
                    if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                        go$writeFile,
                        [
                            path,
                            data,
                            options,
                            cb
                        ],
                        err,
                        startTime || Date.now(),
                        Date.now()
                    ]);
                    else {
                        if (typeof cb === 'function') cb.apply(this, arguments);
                    }
                });
            }
        }
        var fs$appendFile = fs.appendFile;
        if (fs$appendFile) fs.appendFile = appendFile;
        function appendFile(path, data, options, cb) {
            if (typeof options === 'function') cb = options, options = null;
            return go$appendFile(path, data, options, cb);
            function go$appendFile(path, data, options, cb, startTime) {
                return fs$appendFile(path, data, options, function(err) {
                    if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                        go$appendFile,
                        [
                            path,
                            data,
                            options,
                            cb
                        ],
                        err,
                        startTime || Date.now(),
                        Date.now()
                    ]);
                    else {
                        if (typeof cb === 'function') cb.apply(this, arguments);
                    }
                });
            }
        }
        var fs$copyFile = fs.copyFile;
        if (fs$copyFile) fs.copyFile = copyFile;
        function copyFile(src, dest, flags, cb) {
            if (typeof flags === 'function') {
                cb = flags;
                flags = 0;
            }
            return go$copyFile(src, dest, flags, cb);
            function go$copyFile(src, dest, flags, cb, startTime) {
                return fs$copyFile(src, dest, flags, function(err) {
                    if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                        go$copyFile,
                        [
                            src,
                            dest,
                            flags,
                            cb
                        ],
                        err,
                        startTime || Date.now(),
                        Date.now()
                    ]);
                    else {
                        if (typeof cb === 'function') cb.apply(this, arguments);
                    }
                });
            }
        }
        var fs$readdir = fs.readdir;
        fs.readdir = readdir;
        var noReaddirOptionVersions = /^v[0-5]\./;
        function readdir(path, options, cb) {
            if (typeof options === 'function') cb = options, options = null;
            var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir(path, options, cb, startTime) {
                return fs$readdir(path, fs$readdirCallback(path, options, cb, startTime));
            } : function go$readdir(path, options, cb, startTime) {
                return fs$readdir(path, options, fs$readdirCallback(path, options, cb, startTime));
            };
            return go$readdir(path, options, cb);
            function fs$readdirCallback(path, options, cb, startTime) {
                return function(err, files) {
                    if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                        go$readdir,
                        [
                            path,
                            options,
                            cb
                        ],
                        err,
                        startTime || Date.now(),
                        Date.now()
                    ]);
                    else {
                        if (files && files.sort) files.sort();
                        if (typeof cb === 'function') cb.call(this, err, files);
                    }
                };
            }
        }
        if (process.version.substr(0, 4) === 'v0.8') {
            var legStreams = legacy(fs);
            ReadStream = legStreams.ReadStream;
            WriteStream = legStreams.WriteStream;
        }
        var fs$ReadStream = fs.ReadStream;
        if (fs$ReadStream) {
            ReadStream.prototype = Object.create(fs$ReadStream.prototype);
            ReadStream.prototype.open = ReadStream$open;
        }
        var fs$WriteStream = fs.WriteStream;
        if (fs$WriteStream) {
            WriteStream.prototype = Object.create(fs$WriteStream.prototype);
            WriteStream.prototype.open = WriteStream$open;
        }
        Object.defineProperty(fs, 'ReadStream', {
            get: function() {
                return ReadStream;
            },
            set: function(val) {
                ReadStream = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(fs, 'WriteStream', {
            get: function() {
                return WriteStream;
            },
            set: function(val) {
                WriteStream = val;
            },
            enumerable: true,
            configurable: true
        });
        var FileReadStream = ReadStream;
        Object.defineProperty(fs, 'FileReadStream', {
            get: function() {
                return FileReadStream;
            },
            set: function(val) {
                FileReadStream = val;
            },
            enumerable: true,
            configurable: true
        });
        var FileWriteStream = WriteStream;
        Object.defineProperty(fs, 'FileWriteStream', {
            get: function() {
                return FileWriteStream;
            },
            set: function(val) {
                FileWriteStream = val;
            },
            enumerable: true,
            configurable: true
        });
        function ReadStream(path, options) {
            if (this instanceof ReadStream) return fs$ReadStream.apply(this, arguments), this;
            else return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
        }
        function ReadStream$open() {
            var that = this;
            open(that.path, that.flags, that.mode, function(err, fd) {
                if (err) {
                    if (that.autoClose) that.destroy();
                    that.emit('error', err);
                } else {
                    that.fd = fd;
                    that.emit('open', fd);
                    that.read();
                }
            });
        }
        function WriteStream(path, options) {
            if (this instanceof WriteStream) return fs$WriteStream.apply(this, arguments), this;
            else return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
        }
        function WriteStream$open() {
            var that = this;
            open(that.path, that.flags, that.mode, function(err, fd) {
                if (err) {
                    that.destroy();
                    that.emit('error', err);
                } else {
                    that.fd = fd;
                    that.emit('open', fd);
                }
            });
        }
        function createReadStream(path, options) {
            return new fs.ReadStream(path, options);
        }
        function createWriteStream(path, options) {
            return new fs.WriteStream(path, options);
        }
        var fs$open = fs.open;
        fs.open = open;
        function open(path, flags, mode, cb) {
            if (typeof mode === 'function') cb = mode, mode = null;
            return go$open(path, flags, mode, cb);
            function go$open(path, flags, mode, cb, startTime) {
                return fs$open(path, flags, mode, function(err, fd) {
                    if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                        go$open,
                        [
                            path,
                            flags,
                            mode,
                            cb
                        ],
                        err,
                        startTime || Date.now(),
                        Date.now()
                    ]);
                    else {
                        if (typeof cb === 'function') cb.apply(this, arguments);
                    }
                });
            }
        }
        return fs;
    }
    function enqueue(elem) {
        debug('ENQUEUE', elem[0].name, elem[1]);
        fs[gracefulQueue].push(elem);
        retry();
    }
    var retryTimer;
    function resetQueue() {
        var now = Date.now();
        for(var i = 0; i < fs[gracefulQueue].length; ++i){
            if (fs[gracefulQueue][i].length > 2) {
                fs[gracefulQueue][i][3] = now;
                fs[gracefulQueue][i][4] = now;
            }
        }
        retry();
    }
    function retry() {
        clearTimeout(retryTimer);
        retryTimer = undefined;
        if (fs[gracefulQueue].length === 0) return;
        var elem = fs[gracefulQueue].shift();
        var fn = elem[0];
        var args = elem[1];
        var err = elem[2];
        var startTime = elem[3];
        var lastTime = elem[4];
        if (startTime === undefined) {
            debug('RETRY', fn.name, args);
            fn.apply(null, args);
        } else if (Date.now() - startTime >= 60000) {
            debug('TIMEOUT', fn.name, args);
            var cb = args.pop();
            if (typeof cb === 'function') cb.call(null, err);
        } else {
            var sinceAttempt = Date.now() - lastTime;
            var sinceStart = Math.max(lastTime - startTime, 1);
            var desiredDelay = Math.min(sinceStart * 1.2, 100);
            if (sinceAttempt >= desiredDelay) {
                debug('RETRY', fn.name, args);
                fn.apply(null, args.concat([
                    startTime
                ]));
            } else {
                fs[gracefulQueue].push(elem);
            }
        }
        if (retryTimer === undefined) {
            retryTimer = setTimeout(retry, 0);
        }
    }
}
,});global['973501ed6cc362643bd39f42d007cdf1'].__farm_module_system__.setInitialLoadedResources([]);global['973501ed6cc362643bd39f42d007cdf1'].__farm_module_system__.setDynamicModuleResourcesMap([{ path: 'index.cjs', type: 0 }],{ '1f8eda05': [0],'bf50199b': [0] });var farmModuleSystem = global['973501ed6cc362643bd39f42d007cdf1'].__farm_module_system__;farmModuleSystem.bootstrap();var entry = farmModuleSystem.require("953dfae2");module.exports.VIRTUAL_FARM_DYNAMIC_IMPORT_SUFFIX = entry.VIRTUAL_FARM_DYNAMIC_IMPORT_SUFFIX;module.exports.Compiler = entry.Compiler;module.exports.defineFarmConfig = entry.defineFarmConfig;module.exports.resolveConfig = entry.resolveConfig;module.exports.normalizeUserCompilationConfig = entry.normalizeUserCompilationConfig;module.exports.DEFAULT_HMR_OPTIONS = entry.DEFAULT_HMR_OPTIONS;module.exports.DEFAULT_DEV_SERVER_OPTIONS = entry.DEFAULT_DEV_SERVER_OPTIONS;module.exports.DEFAULT_COMPILATION_OPTIONS = entry.DEFAULT_COMPILATION_OPTIONS;module.exports.normalizeDevServerConfig = entry.normalizeDevServerConfig;module.exports.normalizePublicDir = entry.normalizePublicDir;module.exports.checkClearScreen = entry.checkClearScreen;module.exports.resolveMergedUserConfig = entry.resolveMergedUserConfig;module.exports.loadConfigFile = entry.loadConfigFile;module.exports.getConfigFilePath = entry.getConfigFilePath;module.exports.resolvePlugins = entry.resolvePlugins;module.exports.Server = entry.Server;module.exports.rustPluginResolver = entry.rustPluginResolver;module.exports.FARM_TARGET_NODE_ENVS = entry.FARM_TARGET_NODE_ENVS;module.exports.FARM_TARGET_BROWSER_ENVS = entry.FARM_TARGET_BROWSER_ENVS;module.exports.FARM_TARGET_LIBRARY_ENVS = entry.FARM_TARGET_LIBRARY_ENVS;module.exports.isObject = entry.isObject;module.exports.isArray = entry.isArray;module.exports.isEmptyObject = entry.isEmptyObject;module.exports.isUndefined = entry.isUndefined;module.exports.isString = entry.isString;module.exports.isNumber = entry.isNumber;module.exports.isEmpty = entry.isEmpty;module.exports.isSymbol = entry.isSymbol;module.exports.isWindows = entry.isWindows;module.exports.pad = entry.pad;module.exports.clearScreen = entry.clearScreen;module.exports.version = entry.version;module.exports.normalizePath = entry.normalizePath;module.exports.normalizeBasePath = entry.normalizeBasePath;module.exports.arraify = entry.arraify;module.exports.getFileSystemStats = entry.getFileSystemStats;module.exports.toArray = entry.toArray;module.exports.mergeObjects = entry.mergeObjects;module.exports.asyncFlatten = entry.asyncFlatten;module.exports.sleep = entry.sleep;module.exports.preventExperimentalWarning = entry.preventExperimentalWarning;module.exports.mapTargetEnvValue = entry.mapTargetEnvValue;module.exports.tryStatSync = entry.tryStatSync;module.exports.isNodeEnv = entry.isNodeEnv;module.exports.Logger = entry.Logger;module.exports.NoopLogger = entry.NoopLogger;module.exports.printServerUrls = entry.printServerUrls;module.exports.bootstrapLogger = entry.bootstrapLogger;module.exports.bootstrap = entry.bootstrap;module.exports.logger = entry.logger;module.exports.buildErrorMessage = entry.buildErrorMessage;module.exports.compilerHandler = entry.compilerHandler;module.exports.generateFileTree = entry.generateFileTree;module.exports.buildFileTreeHtml = entry.buildFileTreeHtml;module.exports.generateFileTreeHtml = entry.generateFileTreeHtml;module.exports.ERR_SYMLINK_IN_RECURSIVE_READDIR = entry.ERR_SYMLINK_IN_RECURSIVE_READDIR;module.exports.recursiveReaddir = entry.recursiveReaddir;module.exports.reset = entry.reset;module.exports.bold = entry.bold;module.exports.dim = entry.dim;module.exports.italic = entry.italic;module.exports.underline = entry.underline;module.exports.inverse = entry.inverse;module.exports.hidden = entry.hidden;module.exports.strikethrough = entry.strikethrough;module.exports.debugColor = entry.debugColor;module.exports.brandColor = entry.brandColor;module.exports.black = entry.black;module.exports.red = entry.red;module.exports.green = entry.green;module.exports.yellow = entry.yellow;module.exports.blue = entry.blue;module.exports.magenta = entry.magenta;module.exports.purple = entry.purple;module.exports.orange = entry.orange;module.exports.cyan = entry.cyan;module.exports.white = entry.white;module.exports.bgBlack = entry.bgBlack;module.exports.bgRed = entry.bgRed;module.exports.bgGreen = entry.bgGreen;module.exports.bgYellow = entry.bgYellow;module.exports.bgBlue = entry.bgBlue;module.exports.bgMagenta = entry.bgMagenta;module.exports.bgCyan = entry.bgCyan;module.exports.bgWhite = entry.bgWhite;module.exports.gradientString = entry.gradientString;module.exports.interpolateColor = entry.interpolateColor;module.exports.PersistentCacheBrand = entry.PersistentCacheBrand;module.exports.handleBrandText = entry.handleBrandText;module.exports.BrandText = entry.BrandText;module.exports.colors = entry.colors;module.exports.cleanUrl = entry.cleanUrl;module.exports.slash = entry.slash;module.exports.withTrailingSlash = entry.withTrailingSlash;module.exports.stripQueryAndHash = entry.stripQueryAndHash;module.exports.checkPublicFile = entry.checkPublicFile;module.exports.initPublicFiles = entry.initPublicFiles;module.exports.cssUrlRE = entry.cssUrlRE;module.exports.cssDataUriRE = entry.cssDataUriRE;module.exports.importCssRE = entry.importCssRE;module.exports.rebaseUrls = entry.rebaseUrls;module.exports.externalRE = entry.externalRE;module.exports.isExternalUrl = entry.isExternalUrl;module.exports.dataUrlRE = entry.dataUrlRE;module.exports.isDataUrl = entry.isDataUrl;module.exports.getAdditionContext = entry.getAdditionContext;module.exports.throwError = entry.throwError;module.exports.getAliasEntries = entry.getAliasEntries;module.exports.transformAliasWithVite = entry.transformAliasWithVite;module.exports.getDynamicResources = entry.getDynamicResources;module.exports.start = entry.start;module.exports.build = entry.build;module.exports.preview = entry.preview;module.exports.watch = entry.watch;module.exports.clean = entry.clean;module.exports.createBundleHandler = entry.createBundleHandler;module.exports.createCompiler = entry.createCompiler;module.exports.createDevServer = entry.createDevServer;module.exports.createFileWatcher = entry.createFileWatcher;module.exports.logFileChanges = entry.logFileChanges;module.exports.defineConfig = entry.defineConfig;module.exports.loadEnv = entry.loadEnv;